<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap9.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:41:07 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="Chap9_files/filelist.html">
<link rel=Edit-Time-Data href="Chap9_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Miscellaneous - C# Nuts and Bolt - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T12:20:00Z</o:Created>
  <o:LastSaved>2001-09-27T12:21:00Z</o:LastSaved>
  <o:Pages>19</o:Pages>
  <o:Words>4591</o:Words>
  <o:Characters>26173</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>218</o:Lines>
  <o:Paragraphs>52</o:Paragraphs>
  <o:CharactersWithSpaces>32142</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:Garamond;
	panose-1:2 2 4 4 3 3 1 1 8 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:15.0pt;font-family:Garamond;
color:black'>Chapter 9</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:26.0pt;font-family:Garamond;
color:black'>Miscellaneous</span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Members<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are only two types of
entities that can contain members, namely, types and namespaces. These members
can be accessed using the same rules i.e. the name of an entity to be followed
by a dot '.' and then the member name to be given. This cardinal rule is never
ever broken. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>All derived classes inherit every
member of a base class with the exception of constructors and destructors. This
rule applies to private members also. Regardless of inheriting all the members,
the base class members may/may not be accessible to the derived class members.
Thus, the access modifiers have nothing to contribute to inheritance. In other
words, the rules of inheritance ignore the access modifiers.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If a namespace is not specified
for a member, it belongs to a default namespace called the global namespace.
Like it or not, all members are part and parcel of a namespace. They cannot
exist out of a namespace under any circumstance. It makes logical sense
creating our own namespaces thereby avoiding the unnecessary clutter in the
global namespace with the members we create.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The word int is an alias for
System.Int32. A variable of type int is internally known as System.Int32. The
basic types like int are internally not known by their name but something else
that is entirely different.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Type t = typeof(int);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(t.FullName);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>System.Int32<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The above example reconfirms the
point we enumerated a little earlier. The compiler does not understand an int
as a data type but knows all about a structure called System.Int32 instead.
When we coached you earlier about the compiler understanding about data types
like int at birth, what we truly meant was that there exists structures in the
System namespace relating to these datatypes. The compiler is informed well in
advance about the one-to-one connection between the alias name and their
structures. When we get some time on our hand, we will list out and explain all
the members of this structure. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To explain the above example, we
use a keyword typeof, which accepts the name of a class or structure. This
returns an object that looks like Type. The Type object consists of methods and
properties that publish everything you ever wanted to know about a type but
were afraid to ask. We are only using one member called FullName to prove our
hypothesis. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void<span style="mso-spacerun: yes">  </span>Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>string yyy = &quot;hell&quot;;<o:p></o:p></p>

<p class=Cprg>string s = yyy;<o:p></o:p></p>

<p class=Cprg>System.Type t = typeof(yyy);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(s);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(t);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hell<o:p></o:p></p>

<p class=Coutput>yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>typeof expects the name of a
class as a parameter. C# allows a variable name and a class name to be the
same. At the line s = yyy, C# assumes yyy to be the name of a variable. yyy is
considered to be a class name and t is initialised to the typeof returned by
it. Thus, C# uses a lot of intelligence to read between the lines. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Our resident astrologer informed
us that at least 1.54234 per cent of our book must be copied from the
documentation. To make sure that no ill luck befalls us, we copied a couple of
lines from it. Thus an sbyte is an alias for System.Sbyte,byte System.Byte,
short System.Int16, ushort System.UInt16, uint System.UInt32, long
System.Int64, ulong System.UInt64, char System.Char, float System.Single,
double System.Double, decimal System.Decimal, and, finally, bool
System.Boolean. Enums are simple derived from System.Enum and are simple
constants. Object is an alias for System.Object and string System.String.
Interfaces are only derived from object and arrays form System.Array. Delegates
are from System.Delegate. These have been mentioned earlier, they have been
placed here only as a ready reckner.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Member
Lookup<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A member lookup is a way by means
of which the meaning of a name in a type is determined or figured out. A class
can have base classes and all classes have one base class object. The compiler
first figures out all the names that match in the class and base class. We can
have a constant and a property with the same name in a base class and derived
class. We mentioned this earlier, but it merits repeating. If we ever have an
override modifier in front of a member name, then this name has overridden the
earlier name in the base class. It is thus removed from the list as it is a
different name. If the name is a constant, field, property, event, type or
enum, it hides all the members of the base class. If it is function, then all
non-methods are hidden in the base class. The end result could either be a
single non-method name or a series of methods. Anything else is an error. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Every known entity is derived
from object. We have mentioned this at least a hundred times already. Value
types cannot derive from any other type except object unlike classes and
interfaces. However, arrays and delegates are derived from System.Array and
System.Delegate respectively. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Name
Resolution<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After the giving a namespace and
a period, we can either use the name of another namespace or the name of a
type. If we start, however, with the name of a type, then what follows can be
one of the following. Either a type as in a nested types, or a method, a static
property, static readonly field or a static field, static event, constant, or
finally an enum. Anything else signals an error. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aaa aaa;<o:p></o:p></p>

<p class=Cprg>aaa bbb = aaa.bbb();<o:p></o:p></p>

<p class=Cprg>aaa ccc = aaa.ccc;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static aaa ccc = new aaa();<o:p></o:p></p>

<p class=Cprg>public static aaa bbb()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return new aaa();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If you want to confuse any person
using your code, use the above code. The above explanation clearly states that
we can create a constant, field, local variable or a parameter with the same
name as the name of a type. Thus, we have a class aaa which contains two
members. One is a static field called ccc and<span style="mso-spacerun: yes"> 
</span>the other is a static function bbb which returns an aaa type. In Main,
we create a variable called aaa, same as the data type. Then we call static
members of the class aaa using the name of the type. All this leeway is given
to us because we are allowed access to static members of the class aaa without
any ambiguity.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An invocation expression can
either be a method group or a delegate. Nothing else can be executable. If the
function returns void, the result is nothing. Thus, an expression which results
in nothing cannot obviously be the operand of a operator, it can only be used a
statement. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A method group can either be one
method or a group of methods. The parameter types decide which of the methods
would be chosen. To execute a certain method, the compiler starts with the type
before the method. It then proceeds up the inheritance chain and finds an
applicable, accessible, non-override method. If it finds more than one, it uses
overload resolution to decide the best one. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Constructor
Signatures<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 3;<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy(ref i);<o:p></o:p></p>

<p class=Cprg>int j;<o:p></o:p></p>

<p class=Cprg>yyy b = new yyy(out j);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i + &quot; &quot; + j);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy(ref int p)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>p = 100;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public yyy(out int q)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>q = 1000;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(18,8): error CS0663: '.ctor' cannot define overloaded
methods which differ only on ref and out<o:p></o:p></p>

<p class=Coutput>a.cs(14,8): (Location of symbol related to previous error)<o:p></o:p></p>

<p class=Cbase><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase>A constructor cannot define overloaded methods differing only on
ref or out. The above logic makes sense as a constructor is nothing but a
function that is called automatically at birth. It is in no way different from
any other functions that we have worked with.<span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy(1,2,3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy(params int [] q)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>foreach ( int i in q)<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot; &quot; );<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1 2 3<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can use the params modifier to
our hearts content in displaying the parameters to the constructors.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u> <o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy(1,2,3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy(params int [] q)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>foreach ( int i in q)<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot; &quot; );<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public yyy ( int i, int j , int k)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(&quot;int&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>int<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>However, the params modifier is
given the last priority by the compiler. If there is an exact match, a
one-to-one with the parameters in the constructors, the compiler gives
precedence to it and the params is ignored for good. For three ints, the
constructor with three parameters will be called and for any other combination
of ints, the params constructor will be called.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy(1,2,3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy(int p, int p1,int p2,params int [] q)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public yyy ( int i, int j , int k)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(&quot;int&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>int<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Regardless of both the
constructors matching very closely, the compiler yet does not give us any
error. This is because it treats the params as a second class citizen of the
world. We would never like to be in the shoes of a params parameter.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>This
<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This is only permitted to be used
in three places namely a constructor, instance method and an instance accessor.
<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(this);<o:p></o:p></p>

<p class=Cprg>if ( this is yyy)<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yes yyy&quot;);<o:p></o:p></p>

<p class=Cprg>if ( this is zzz)<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yes zzz&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static implicit operator string (yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return &quot;hi&quot;;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,6): warning CS0183: The given expression is always of
the provided ('yyy') type<o:p></o:p></p>

<p class=Coutput>a.cs(15,6): warning CS0184: The given expression is never of
the provided ('zzz') type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>yes yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A this in a constructor is
considered to be the value of the data type of the class that contains the
constructor. In the above program, the is operator is used to reconfirm the
above statement. Also, the implicit string operator is called as the this has to
be converted to a string for WriteLine function. Ditto for instance members and
accessors. Comment out the string operator and the output will be <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>yyy<o:p></o:p></p>

<p class=Coutput>yes yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>For a constructor in a structure,
the rules change dramatically. Here it is a variable. Like earlier, it stands
for a reference to the structure it is placed in, but a major difference is
that it is classified as an out parameter. Thus, all the members of the
structure must be initialized before we leave the constructor. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the case of an instance
method, everything remains the same as above, but now it behaves as a ref
parameter instead of an out. Being a ref parameter, someone else is responsible
for initializing the variable. The function can access all the instance
variables in the structure and also infringe the benefit of changing them if we
so choose to. A this is not used on anything remotely connected with static or
in variable initializer of a field declaration. A program relating to this is
as follows.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int j = 10;<o:p></o:p></p>

<p class=Cprg>int i = this.j;<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,9): error CS0027: Keyword this is not available in the
current context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This variable is available only
in certain places within a class type and can be assumed as the first parameter
to the functions in the type. If we have a function abc accepting two ints as a
parameter, we would write it as abc(int i, int j). In class yyy, the function
gets rewritten as abc( yyy this, int i, int j). <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This is passed as the first
parameter and refers to the class the function resides in. As the programming
language C++ called this reference variable as this, C# copied the same concept
but with a small change for structures.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Base<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We use the variable base in a
completely different manner. A function in the base class gets hidden by the
same function name in a derived class.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs </u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aaa a = new aaa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;xxx abc&quot;);<o:p></o:p></p>

<p class=Cprg>base.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class aaa : xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;aaa abc&quot;);<o:p></o:p></p>

<p class=Cprg>base.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>aaa abc<o:p></o:p></p>

<p class=Coutput>xxx abc<o:p></o:p></p>

<p class=Coutput>yyy abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The base variable has absolutely
nothing to do with the modifiers new and override. It simply calls the function
in the base class without bothering about new or override to its existing
function. It simply does not care at all. Thus, using base, we can call a
function from the base class irrespective of the modifiers on it. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We will get an error if base is
used in an abstract function. Base, similar to this, is valid only in a
constructor, instance method or accessor. All the methods from the viewpoint of
base, are non virtual. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Writing base.abc will caste the
this pointer of the current class to its lower class, i.e. the base class.
Internally base.abc in class aaa derived from class xxx becomes ((xxx)this).abc
and ditto for an indexer access. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thus, base and this are
conceptually similar, except that one acts on a base class, the other on a
derived class.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>xxx a = new xxx();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;xxx abc&quot;);<o:p></o:p></p>

<p class=Cprg>((yyy)this).abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Do not run the above program as
it will take you to a trip to the moon. Just does not stop at all. All that we
said earlier was only conceptually true. You cannot replace a base with a this.
The programming language contains both of them and cannot be used
interchangeably. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A struct variable has a free
default constructor always available. Thus unlike a class initialization, which
explicitly initializes the instance variables to zero, the constructor in the
case of the struct does the same.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Name
Hiding<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Name hiding occurs when we
inherit from a class or struct and erroneously or otherwise, we introduce a
similar name as that in the base class. A constant, field, property, event, or
type hides the base class members with the same name.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=Cprg>a.i = 100;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy : xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int i = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public const int i = 10;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,12): warning CS0108: The keyword new is required on
'yyy.i' because it hides inherited member 'xxx.i'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>3<o:p></o:p></p>

<p class=Coutput>100<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A million years ago, someone
somewhere in the world created a class called xxx. That gentleman, then, added
one const member called i. For some reason, we decided to derive from class
xxx. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are allowed to create our own
variable i notwithstanding the fact that it was declared to be a const in class
xxx. Other than a warning issued by the compiler, we are allowed complete
freedom in using whatever names we like in our derived classes, thus oblivious
to what the base class has given.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.i();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy : xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void i()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public const int i = 10;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As stated earlier, we have total
freedom in doing what we like within the derived class. In the above example,
the function i has nothing to do with the const i in class xxx. The compiler
does send you a feeble protest in the form of a simple warning but that can be
ignored with no loss of life or limb. The same rules apply to indexers also. As
repeated earlier, operators can never hide each other ever.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Concealing an inherited member
does not issue any error as it would then prevent evolving any base classes
independently. Lets us explain why a warning and not an error. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Let us assume that we are
deriving from a base class that has a function called pqr. We now decided to
create an abc function in the derived class. After a while, the next version of
the base class, for some reason, introduces a new function called abc. At that
moment, all derived classes from the base class should not break or give an
error. In the scheme of things followed by C#, they are different functions and
making changes to a base class does not invalidate existing derived classes at
all.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Functions<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are five places in the C#
language where we can place executable code. These places are constructors,
methods, properties, indexers and user-defined operators. Anywhere else, and
you permission from the silicon god that is not very forthcoming. Function
members are not members of a namespace and thus we can only place the above in
a type. You cannot have global functions that are not associated with a type.
We cannot use ref and out parameters for indexers, properties or operators.
These have to be value parameters only. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>int i = 0;<o:p></o:p></p>

<p class=Cprg>a.abc(i++,i++,i++);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc( int x, int y, int z)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(x + &quot; &quot; + y + &quot; &quot; +
z);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>0 1 2<o:p></o:p></p>

<p class=Coutput>3<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The parameters to a function are
read in the order they are written, from left to right. Thus even though we are
using a postfix notation, i++, the compiler uses the current value of i to
initialize parameter x in function abc, and then increase i by one. Thus, i now
has a value of one, that is what the parameter y is initialized to and then it
is increased by one. This z becomes two and at the end of the function
invocation variable i has a value of three.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Object
Elements<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>byte [] b = new byte[2];<o:p></o:p></p>

<p class=Cprg>b[1] = 10;<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(b[a]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static implicit operator int(yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>10<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If we remove the overloaded
operator int, we get the following error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,28): error CS0029: Cannot implicitly convert type 'yyy'
to 'int'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The variable we use in the []
brackets is called the element access and must be one of the following data
types namely int, uint, long, ulong or any type that can be implicitly
converted to the above type. Thus, without the operator int which was
responsible for converting the yyy to an int, we got the above error. On
returning 1 in the operator, the array variable becomes b[1].<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>byte [] b = new byte[2];<o:p></o:p></p>

<p class=Cprg>b[1] = 10;<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(b[a]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static implicit operator uint(yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;uint&quot;);<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static implicit operator long(yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;long&quot;);<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>uint<o:p></o:p></p>

<p class=Coutput>10<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Rules, rules everywhere, but not
a drop to drink. The element access of an array as stated earlier must either
be an int, uint, long or a ulong. The above order must be followed. The
compiler checks for the operators in the above order and on finding the very
first match, it uses that operator. It stops short in its tracks and does not
complain that it could use both the above operators. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It is one of the few cases where
although both the operators were applicable, it does not give us an error. In
the above types, a short is not mentioned. Recall that sometime back, we spoke
of a short being converted into a int. Operators are allowed to throw an
exception. If one takes place then the processing stops. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>byte [] b = null;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(b[1]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Unhandled Exception: System.NullReferenceException: Value null
was found where an instance of an object was required.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Like a delegate, if we try and
access any null object, an exception is thrown. No compile time checks are
performed for null as the value. Maybe the next version of the compiler will
check for a null and it is on our wish list for Santa Claus. Ditto if we try
and exceed the bounds of an array. The exception thrown is<span
style="mso-spacerun: yes">  </span>IndexOutOfRangeException instead. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void pqr(ref object x)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr &quot; + x);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void abc(object x)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc &quot; + x);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>object[] a = new object[2];<o:p></o:p></p>

<p class=Cprg>object[] b = new string[2];<o:p></o:p></p>

<p class=Cprg>abc(a[0]);<o:p></o:p></p>

<p class=Cprg>abc(b[1]);<o:p></o:p></p>

<p class=Cprg>pqr(ref a[0]);<o:p></o:p></p>

<p class=Cprg>pqr(ref b[1]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc <o:p></o:p></p>

<p class=Coutput>abc <o:p></o:p></p>

<p class=Coutput>pqr <o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>Unhandled Exception: System.ArrayTypeMismatchException:
Exception of type System.ArrayTypeMismatchException was thrown.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The rules of array co-variance
allow an array to be populated by any data type provided there exist an
implicit conversion between them. Array b is an array of objects and there
exists an implicit conversion from a string to an object. Hence, we can initialize
an array of objects to an array of strings. The array object b is not an array
of objects but one that comprises of an array of strings. The compile time data
type may be that of an object but the run time data type must be that of a
string. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we have a ref parameter
being passed a reference, we use an array instead. The compiler is smart enough
to perform a run time check on the data type being passed as an array now can
hold dual data types. In the last call to function pqr, we are passing b[0]
which at compile time is an object but at run time is a string. Thus, an
exception is thrown. Remember exceptions can only be thrown at run time. This
holds true only for ref parameters and not value parameters.<span
style="mso-spacerun: yes">    </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int x;<o:p></o:p></p>

<p class=Cprg>void abc( int a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>x = 1;<o:p></o:p></p>

<p class=Cprg>if (a &gt; 10)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>float x = 1.0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,7): error CS0136: A local variable named 'x' cannot be
declared in this scope because it would give a different meaning to 'x', which
is already used in a 'parent or current' scope to denote something else<o:p></o:p></p>

<p class=Coutput>a.cs(10,11): error CS0029: Cannot implicitly convert type
'double' to 'int'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A block is represented by a {}
braces. Any variable or identifier created within a block must primarily be
unique within that block. Then it must also be unique within the immediate
enclosing block. Thus in both blocks, the name must be unique and therefore
refer to the same entity. The meaning of the identifier must remain the same
within the block. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We get an error in the above
program as in the outer block we have an int x and in the inner block, within
the if statement we have another variable called x again. The second error
comes in handy as it very clearly states that it assumes the variable x to be
an int within the if statement. The golden rule again. We cannot have a
variable with the same name in the inner and outer block. If we remove the
statement x = 1 from the above program we will get a slightly different error
as follows.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,11): error CS0664: Literal of type double cannot be
implicitly converted to type 'float'; use an 'F' suffix to create a literal of
this type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int x;<o:p></o:p></p>

<p class=Cprg>void abc( int a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (a &gt; 10)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>x = 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>else<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>double x = 1.0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(15,8): warning CS0219: The variable 'x' is assigned but
its value is never used<o:p></o:p></p>

<p class=Coutput>a.cs(6,5): warning CS0169: The private field 'zzz.x' is never
used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler gives us no errors
as the variable x created outside of a function in the outer block is not used
in the main function block. It is only used in the if statement. Since the else
block of the if statement, which is at the same level is not executed, the
compiler adjourns after giving a few warnings. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int x;<o:p></o:p></p>

<p class=Cprg>void abc( int a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>x = 3;<o:p></o:p></p>

<p class=Cprg>if (a &gt; 10)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>x = 1; <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>else<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>double x = 1.0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(16,8): error CS0136: A local variable named 'x' cannot be
declared in this scope because it would give a different meaning to 'x', which
is already used in a 'parent or current' scope to denote something else<o:p></o:p></p>

<p class=Coutput>a.cs(16,12): error CS0029: Cannot implicitly convert type
'double' to 'int'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If we knowingly initialize the
instance variable x in the function abc, we are using the one created in the
outer block. So, we are not allowed to recreate the same variable x the inner
block under any circumstance. If you comment the line with x=1 or double x=1.0,
the compiler will give you warnings. This proves that the compiler is confused
on the variable it should work with while initializing x to 1 as there are two
variables available by the same name. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc( bool a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int i = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(12,5): error CS0136: A local variable named 'i' cannot be
declared in this scope because it would give a different meaning to 'i', which
is already used in a 'child' scope to denote something else<o:p></o:p></p>

<p class=Coutput>a.cs(12,5): error CS0103: The name 'i' does not exist in the
class or namespace 'zzz'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>What we forgot to inform you
earlier is that the reverse is not true. That is, a variable created in an
inner block or scope cannot be defined outside the parent or outer scope. This
is in contrast to the above explanation.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc( bool a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>if ( a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We get no error above as the two
if statements are at the same level and the variables created within the blocks
are independent of each other. They do not interfere with each other.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The above explanation, called the
rules of invariant, apply only to simple names. It is not applicable to member
access, an example of this is seen below.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int x;<o:p></o:p></p>

<p class=Cprg>void abc( int x)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>this.x = x;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have two variables called x in
the above program. One is an instance variable and the other is a parameter to
a function. Within the function abc, the parameter variable x hides the
instance variable. If we want to access the instance variable, however, we have
to preface the variable name with this. It is therefore, a good idea to preface
all instance variables with the reserved word this.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Indexers<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>xxx b = new xxx();<o:p></o:p></p>

<p class=Cprg>a[1] = b;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a[1]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public xxx this[int i]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return new xxx();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>set<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>xxx<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An indexer can store any value
provided it is a class, struct or interface. However, the return value of an
indexer is not part of its signature. We can have only one return type but
multiple types of parameters. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Throw<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>throw null;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Unhandled Exception: System.NullReferenceException: Exception
of type System.NullReferenceException was thrown.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The keyword null is like a rubber
man. Fits everywhere. If we throw a null, the actual exception thrown is
NullReferenceException.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>throw ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0156: A throw statement with no arguments
is not allowed outside of a catch clause<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A throw can be used without the
name of an expression only in a catch. This is one of the few error messages
that actually sound English-like. Hope, he is not sacked for committing
blasphemy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>throw null;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>catch ( System.Exception e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;catch&quot;);<o:p></o:p></p>

<p class=Cprg>throw;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>catch<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>Unhandled Exception: System.NullReferenceException: Exception
of type System.NullReferenceException was thrown.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In this program, a throw is used
without any parameters in a catch statement. It is actually a short form of the
throw and it throws the same exception that the catch invokes. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In this case, the earlier throw
showed a NullReferenceException Exception and the inner throw throws the same
exception. Also, remember the end point of a throw can never be reached even by
a miracle. Exception propagation is the process of transferring control from a
throw to one of the exception handlers that may exist.<o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>catch (Exception e) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Console.WriteLine(&quot;abc: &quot; + e.Message);<o:p></o:p></p>

<p class=Cprg>e = new Exception(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>Console.WriteLine(&quot;abc: &quot; + e.Message);<o:p></o:p></p>

<p class=Cprg>throw;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void pqr() {<o:p></o:p></p>

<p class=Cprg>throw new Exception(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>try {<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>catch (Exception e) {<o:p></o:p></p>

<p class=Cprg>Console.WriteLine(&quot;Main: &quot; + e.Message);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc: pqr<o:p></o:p></p>

<p class=Coutput>abc: abc<o:p></o:p></p>

<p class=Coutput>Main: pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The throw by itself re-throws the
same exception. The exception parameter is like a value variable and even
though we are re initializing it, the original remains the same. Thus the
message displayed by e.Message does not change from pqr to abc ever. The change
is only affected within the catch block as shown by the WriteLine function. The
behaviour is the same as that of a value variable. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,1): error CS1524: Expected catch or finally<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Man cannot live on love alone. So
also, a try needs either a catch or a finally or both to live. The variable
offered to a catch is just like a parameter to a function and it can be
definitely assigned like a value parameter. It also unfortunately dies at the
end of the catch. Life-time and visibility do not exceed the catch block!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try {}<o:p></o:p></p>

<p class=Cprg>catch ( System.Exception ) {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We do not have to supply the
exception name in a catch. If we do not, as in the above program, there is no
known way of figuring out what exception took place. Common sense dictates that
we give the exception a name and try and use it in the code written in the
catch.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try {}<o:p></o:p></p>

<p class=Cprg>catch () {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,8): error CS1015: An object, string, or class type
expected<o:p></o:p></p>

<p class=Coutput>a.cs(6,10): error CS1026: ) expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>What is mandatory however, is the
name of the exception class. The documentation says it is possible to have no
parameters and the catch is then called a general catch. Does not work as
advertised for us. The documentation also claims that it has to be the last. No
such luck.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try {}<o:p></o:p></p>

<p class=Cprg>catch (System.NullReferenceException e) {}<o:p></o:p></p>

<p class=Cprg>catch (System.NullReferenceException e) {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,8): error CS0160: A previous catch clause already
catches all exceptions of this or a super type
('System.NullReferenceException')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You cannot have two catch
statements of the same type as the compiler examines them in textual order,
first come first serve. The first match is the chosen exception handler, thus
the second catch would never be called making it unreachable. This is a no-no
as the compiler will have to execute a catch that is unreachable. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>try {}<o:p></o:p></p>

<p class=Cprg>finally<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa ; <o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;aa&quot;);<o:p></o:p></p>

<p class=Cprg>aa:<o:p></o:p></p>

<p class=Cprg>goto bb ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>bb:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;bb&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,1): warning CS0162: Unreachable code detected<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(12,1): error CS0157: Control cannot leave the body of a
finally clause<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can use a goto statement to
jump around within a finally. It would be an act of God to jump out of a
finally. The same rules hold for a break or continue. No leaving a finally
under any circumstance including a natural calamity. If we have forgotten to tell
you this earlier, no returns help either. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>try <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>finally<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;aa&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>aa:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;bb&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>aa<o:p></o:p></p>

<p class=Coutput>bb<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>No such restrictions apply to a try block. Everything that
we taught you earlier can also be used in a try block. The only proviso is that
we have to first execute code in the finally block before leaving the try
block.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap9.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:41:11 GMT -->
</html>
