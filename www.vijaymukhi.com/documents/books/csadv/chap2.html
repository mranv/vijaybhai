<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap2.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:40:39 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="Chap2_files/filelist.html">
<link rel=Edit-Time-Data href="Chap2_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Statements - C# Nuts and Bolt - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T11:55:00Z</o:Created>
  <o:LastSaved>2001-09-27T11:56:00Z</o:LastSaved>
  <o:Pages>19</o:Pages>
  <o:Words>4185</o:Words>
  <o:Characters>23859</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>198</o:Lines>
  <o:Paragraphs>47</o:Paragraphs>
  <o:CharactersWithSpaces>29300</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:Garamond;
	panose-1:2 2 4 4 3 3 1 1 8 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:15.0pt;font-family:Garamond;
color:black'>Chapter 2</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:26.0pt;font-family:Garamond;
color:black'>Statements</span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# provides us with a countless
number of statements. Let us now understand each one of them in detail.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>bool i = false;<o:p></o:p></p>

<p class=Cprg>if ( i)<o:p></o:p></p>

<p class=Cprg>int j = 40;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Errors</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,1): error CS1023: Embedded statement cannot be a
declaration or labeled statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It is not mandatory for the if
statement to have the {} if we want to limit its scope to only one line.
However, we cannot have a variable declaration as the only line following it.
This is because if the condition results to false, the variable will never be
created. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The value of the variable i can
only be determined at run time and thus C# flags an error. The line following
the if condition, int j = 40;<span style="mso-spacerun: yes">  </span>is called
an embedded statement.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Every C# statement has an
end-point. The end-point is intuitively the end of the statement. If a
statement can be executed, we call it a reachable statement else it is
unreachable. Unreachable statements for some reason flag a warning and not an
error. To figure out whether a statement is reachable or not, C# does flow
analysis. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 30;<o:p></o:p></p>

<p class=Cprg>const int j = 30;<o:p></o:p></p>

<p class=Cprg>if ( i == 3)<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>if ( j == 3)<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,1): warning CS0162: Unreachable code detected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Two identical if statements. One
produces unreachable code whereas the second does not. In the case of variable
j, the compiler sees it as a const and therefore knows that its value will
never change. The if will always end in false, therefore, a warning. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the case of the first if, even
though the value of variable i is 30 and C# knows that it results in false, it
still believes that an act of God can change the value of variable i.
Consequently, no error but a mere warning is generated<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As for the value of a const
variable, even God possesses no privilege to change it, hence the compiler pops
up a warning. The above rule is part of what goes under the moniker of flow
analysis. An end point should not be reached for a switch and a return
statement.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The if statement falls under the
set of selection statement. It executes statements depending upon the value of
a controlling expression.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg>if (x) if (y) F(); else G();<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg>if (x) {<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>if (y) {<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:2'>                        </span>F();<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>else {<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:2'>                        </span>G();<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This block of if statements is
copied straight from the documentation to denote an idea. The above two ifs are
the same. What we want to highlight here is that the brackets are optional; the
visual look and feel can get misleading at times.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Switch
Statement</span></b><span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.abc(1);<o:p></o:p></p>

<p class=Cprg>a.abc(10);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;zero&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;one&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>default:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;end&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>one<o:p></o:p></p>

<p class=Coutput>end<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A switch statement is a
substitute to multiple ifs as both work in the same fashion. It is a matter of
style in deciding on the use of them. We use the time of day to decide which
statement to use when and where. In other words, alike if, the switch also
brings intelligence to our programs. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The switch statement checks the
value of the variable i against the values given with the case statement. If
any one value matches, all the statements within the case upto the break
statement are executed. If none of the case statements match, the default
statement is executed. Remember it is not mandatory to have a default statement
with a break. The value of the variable in question decides on the code to be
executed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u> <o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;zero&quot;);<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;one&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,1): error CS0163: Control cannot fall through from one
case label ('case 0:') to another<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The case statement has its own
set of complex rules. The first one says that every case must end with a break
statement; thereupon preventing it from encroaching into the next case. Don't
we have railing to prevent us from falling over our balcony? Thus, there is no
natural way invented to execute code within two case statements at the same
time. Most people consider it to be an unnecessary restriction C# has placed on
the usage of the case statement. Like everything in life, there is a
workaround. But we will elaborate on that later.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>z.abc(0);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>goto case 1;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>second<o:p></o:p></p>

<p class=Coutput>first<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We explained that one case could
not fall through another case but if it is imperative then you can use the goto
statement. This statement accepts a case statement as a parameter and then
simply jumps to it. Thus, after executing the code of one case, we can jump to
another case and execute its code.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>z.abc(0);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>goto case 1;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(15,1): warning CS0162: Unreachable code detected<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>second<o:p></o:p></p>

<p class=Coutput>first<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Here we have confused the
compiler to no end and we advise you not to write such code. At first, the
compiler informs you that no lines of code after a goto will ever be called and
thus generates an unreachable code warning. </span><span style='color:red'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>But then the control seeps to the
case statement directed by goto and forgets that it was falling through a case
statement from another. We are not trying to belittle the compiler but can it
not please remember goto statements that we write and stop looking stupid in
front of our eyes.</span><span style='color:red'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>z.abc(0);<o:p></o:p></p>

<p class=Cprg>z.abc(3);<o:p></o:p></p>

<p class=Cprg>z.abc(1);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;zero&quot;);<o:p></o:p></p>

<p class=Cprg>goto case 3;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;one&quot;);<o:p></o:p></p>

<p class=Cprg>goto default;<o:p></o:p></p>

<p class=Cprg>case 3:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;two&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>default:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;last&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>zero<o:p></o:p></p>

<p class=Coutput>two<o:p></o:p></p>

<p class=Coutput>two<o:p></o:p></p>

<p class=Coutput>one<o:p></o:p></p>

<p class=Coutput>last<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To prevent a fall through, every
case has to end either with a goto or a break. With a<span style="mso-spacerun:
yes">  </span>break statement, no other code gets called but with a goto, the
code to be executed depends entirely on the case it jumps to. The above code is
the ideal way to write code. However<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>while ( true) ;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>return ;<o:p></o:p></p>

<p class=Cprg>case 3:<o:p></o:p></p>

<p class=Cprg>throw new System.Exception();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The documentation very clearly
states that the end point of the case statement must not be reached. Thus, any
lines of code that prevent the last line of the case being executed is legal
tender. A while (true) goes on forever, This make sure that you do not leave
the while forever and thus the endpoint of the case never gets reached. Though
it does not make any sense at all as i being zero will enter the while and
never leave the case. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A return is more logical at this
point as it can exit the function altogether and not just the case. It may be
what you had in mind, however. A throw statement also breaks the case, the try
catch is not mandatory here. Just because the compiler does not complain with a
warning or an error it does not mean that you are home scott free.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;zero&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;one&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,6): error CS0152: The label 'case 0:' already occurs
in this switch statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Somebody somewhere did some
research and found out that people fell asleep while writing code. When they
woke up, they rewrote the same code again. Thus, we had two copies of the same
case in the program. C# peeks into human mind and is aware that you'd fall
asleep at the wheel. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thus, it checks whether you are
writing the same code all over again. If it catches you in the act, you will
see an error like the one above. It makes no logical sense having two case
statements with the same value. If the value of i happens to be zero then there
is confusion as in which case should C# execute. The first, the second, or
both, or, even better, none. Decisions, decisions, they are so difficult to
make, so the C# compiler drops by an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int j = 10;<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case j:<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case j &gt; 4:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;zero&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,6): error CS0150: A constant value is expected<o:p></o:p></p>

<p class=Coutput>a.cs(13,6): error CS0029: Cannot implicitly convert type
'bool' to 'int'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Here we want to convince you that
an if statement in our humble/esteem opinion is better than a switch statement.
In a case statement, we have to check the variable with a constant value. We
are not permitted to use a variable or a logical condition. They have to be
constant predefined values only. This limits our flexibility in writing complex
conditions thereby preventing us from writing more abstract more intelligent
code.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>z.abc(7);<o:p></o:p></p>

<p class=Cprg>z.abc(70);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i &gt; 8)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 4 &gt; 5:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 4 &lt; 5:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>first<o:p></o:p></p>

<p class=Coutput>second<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We could not for the life of us
figure out, why the above program works. So we added the following lines at the
end of the second case statement ergo producing an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg>case 40 &gt; 5:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;third&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>and we got the following error<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(19,6): error CS0152: The label 'case 1:' already occurs
in this switch statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>z.abc(7) initializes i to 7,
hence<span style="mso-spacerun: yes">  </span>the switch condition becomes
false. The case may show logical operations but finally has either 1 or 0
standing for true or false. As the switch results in false, the first case is
executed where case has a value of 0. In the second case, z.abc(70), the switch
is true and thus the second case that evaluates to true gets called. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In one of the earlier examples,
we demonstrated that a duplicate case value was not admissible. The error
delivers the same message. In the above case, the compiler should take up the
Hitlerian attitude and erase all our code; to punish us for writing such
gibberish. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>z.abc(a);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(yyy i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,9): error CS0151: A value of an integral type expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The C# compiler informs us that a
switch statement can only take certain integral types. To be more specific, it
can take an sbyte, byte, short, ushort, int, uint, long, ulong, char, string,
or an enum-type. C# realizes that the switch has received a yyy object and
since it cannot convert a yyy into the above integral types, it reports an
error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>z.abc(a);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(yyy i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static implicit operator int ( yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;operator&quot;);<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>} }<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>operator<o:p></o:p></p>

<p class=Coutput>first<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The only way to eliminate the
error is by overloading an int operator with class yyy. This will convert the
yyy object into an int. As the function returns the resultant int as 1, the
second case will be called. In a real life scenario, the return value depends
upon some instance variable. Thus each time the switch statement will call the
int operator to convert the yyy object into an int and then call the case
statements depending on the resultant value.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>z.abc(a);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(yyy i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static implicit operator int ( yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;operator&quot;);<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static implicit operator byte ( yyy a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;operator&quot;);<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,9): error CS0151: A value of an integral type expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We really got off the wrong side
of our bed today. We therefore added two operators, one that converts a yyy to
an int and the other that converts a yyy to a byte. As the case has no
preferences of a byte over a int, it gets confused and does not know which
operator to call. Since both are equally probable, it flags an error. The
switch expression decides on the governing type of the statement. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are many more rules to
switch that sensibly state that there can be no two defaults in a switch. The
end-point, that is, the end of the switch must never be reachable or else it
will result in a compile time error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>z.abc(2);<o:p></o:p></p>

<p class=Cprg>z.abc(3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;first&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 3:<o:p></o:p></p>

<p class=Cprg>case 2:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;second&quot;);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>second<o:p></o:p></p>

<p class=Coutput>second<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can have many case statements
bunched up together. There will be no errors if you do so. In the above switch,
for the values 2 and 3, the same code is executed. Thus multiple labels are
permitted in the switch. case 2: can be replaced by a default: and it would
still result in the same answer. Though it is not a good programming style as
removing the case 2: would not change the answer and default means none of the
above. The order of the case statements is irrelevant to the final answer so
changing the order doesn't change anything. For that matter, the default came
first for all that C# cares.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The governing type of a switch
can also be a string. The case statement values are however case sensitive. We
can also use null as we are talking real objects here. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Within a case statement we can
use declaration statements i.e. create variables etc. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.abc(0);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>int j= 7;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(j);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>7<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.abc(0);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>switch (i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int j= 7;<o:p></o:p></p>

<p class=Cprg>case 0:<o:p></o:p></p>

<p class=Cprg>int k= 7;<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>case 1:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(k);<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(12,1): error CS1523: The keyword case or default must
precede code in switch block<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>For some reason, we are not
allowed to create variables in the switch statement. Had we been allowed, then
the variable would have scope in the entire switch. As we are allowed to create
them only in a case, their scope is restricted to that case only. In the above
program, remove the line int j = 7 and relish the error as seen below.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(16,26): error CS0165: Use of unassigned local variable
'k'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Empty
<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A lot of life goes by without
doing anything. As shown in one of the earlier examples, the while loop did
absolutely nothing. Whenever a statement does nothing we call it an empty
statement. Perfectly valid in C#. Execution of an empty statement simply
transfers control to the statement's end point.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa;<o:p></o:p></p>

<p class=Cprg>aa: <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,1): error CS1525: Invalid expression term '}'<o:p></o:p></p>

<p class=Coutput>a.cs(11,1): error CS1002: ; expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We normally create labels at the
end of a function so that all code can jump to the end if they so choose to.
Here we have created a label aa on the last line of function abc. We get an
error as C# demands at least one statement following the label. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# demands a statement so we have
no choice but to give it an empty statement. The best way to cut short an
argument is by doing what C# wants and give it a statement, albeit, an empty
one, one that does nothing.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<span style="mso-spacerun: yes">  </span>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa;<o:p></o:p></p>

<p class=Cprg>aa: ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Just by placing a semicolon, we
bring a big smile on the C# virtual face. ;)<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Loops
<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In all, we have four iterative
statements, the for, foreach, while and the last kid on the block, the do
while.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>int i = 1;<o:p></o:p></p>

<p class=Cprg>do<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot; &quot;);<o:p></o:p></p>

<p class=Cprg>i++;<o:p></o:p></p>

<p class=Cprg>} while ( i &lt;= 3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1 2 3<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Earlier we learnt about the
differences between the for and the while and the scientific reasons behind
choosing one of them. Now we add a twist and introduce the do while. This is
identical to the while. There is just one and only one difference between them.
Minor but could be life-threatening at times. In a while, the condition is
evaluated at the beginning of the loop whereas in the case of the do while it
is at the end.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>int i = 1;<o:p></o:p></p>

<p class=Cprg>do<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot; &quot;);<o:p></o:p></p>

<p class=Cprg>i++;<o:p></o:p></p>

<p class=Cprg>} while ( i &lt;= 0);<o:p></o:p></p>

<p class=Cprg>i = 1;<o:p></o:p></p>

<p class=Cprg>while ( i &lt;= 0 ) {<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot;...&quot;);<o:p></o:p></p>

<p class=Cprg>i++;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>In the do statement, the loop
condition is checked at the end of the first iteration. Thus, the loop is
executed at least once. In the above case, the condition i &lt;= 0 is false at
the outset as the variable i is given a value of 1. In spite of this, the do
executes once, the condition is patently false and we quit out. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>For the while, the condition is
checked at the very beginning and thus as the condition is false, the code in
the while is never called.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>for ( int i = 1; i &lt;= 10 ; i++)<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot;...&quot;);<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,22): error CS0103: The name 'i' does not exist in the
class or namespace 'zzz'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Any variable created in the for
has a lifetime or scope within the embedded statements only. The variable i
does not exist beyond the for statements.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>for ( int i = 1; ; i++)<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot;...&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Please, please do not run the
above program as it will never ever stop unless you Ctrl-C it. The for
condition if present must result in a boolean. Having a numeric data type in
between the two semi colons would raise the red flag for the compiler and
result in an error. If the boolean expression is omitted, then C# assumes the
value to be true by default. Hence the above code never ever stops.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int [] a = new int[3]{1,2,3};<o:p></o:p></p>

<p class=Cprg>foreach ( int i in a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(i + &quot; &quot;);<o:p></o:p></p>

<p class=Cprg>i = 10;<o:p></o:p></p>

<p class=Cprg>zzz.abc(ref i);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void abc(ref int j)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.Write(&quot;abc &quot; + j + &quot; &quot;);<o:p></o:p></p>

<p class=Cprg>j = 100;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<span style='color:red'><o:p></o:p></span></p>

<p class=Cbase><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u><span style='color:black'>Compiler Error</span></u><o:p></o:p></p>

<p class=Coutput>a.cs(9,1): error CS1604: Cannot assign to 'i' because it is
read-only<o:p></o:p></p>

<p class=Coutput>a.cs(10,13): error CS1605: Cannot pass 'i' as a ref or out
argument because it is read-only<o:p></o:p></p>

<p class=Cbase><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase>We are not allowed to change the iteration variable nor pass it
as a ref or out parameter. We are doing both in the above program, hence the
error. <span style='color:blue'><o:p></o:p></span></p>

<p class=Cbase><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma'>Jump
Statements</span></b><span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Jump statements transfer control
to another part of our program. This transfer takes place come hell, hath or
fury. In other words, the transfer is unconditional. We have exactly five
conditional statements namely break, continue, goto, return and throw. The
statements that a jump takes you to, is called the target of the jump.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The break statement was touched
upon in the switch statement where it exits out of the case. It works in a
similar fashion for a while, for, foreach and do while. It simply exits out of
the looping construct it is befitted in. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0139: No enclosing loop out of which to
break or continue<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You cannot have a break statement
by itself. It has to be placed within a case or a loop construct.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>int i = 1, j = 1;<o:p></o:p></p>

<p class=Cprg>for ( i = 1; i&lt;= 10 ; i++) {<o:p></o:p></p>

<p class=Cprg>if ( i == 3)<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>for ( j = 1; j &lt;= 10; j++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i + &quot;.&quot; + j);<o:p></o:p></p>

<p class=Cprg>if ( j == 1)<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i + &quot; &quot; + j);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1.1<o:p></o:p></p>

<p class=Coutput>2.1<o:p></o:p></p>

<p class=Coutput>3 1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The number of breaks introduced
in the program must be equal to the loops statements. As all of us are very
particular about money and will never forget who we lent it to, similarly C# is
very finicky about breaks and hates it hanging around in the program code. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The inner break makes sure that
the inner for executes only once and not 10 times. It ends the loop each time
the value of j reaches 1. The outer break lets us prematurely exit the outer
for loop when the value of i is 3. As we love pairing up people, C# pairs up
breaks with loops.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 1, j = 1;<o:p></o:p></p>

<p class=Cprg>for ( i = 1; i&lt;= 10 ; i++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if ( i == 3)<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>for ( j = 1; j &lt;= 10; j++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i + &quot;.&quot; + j);<o:p></o:p></p>

<p class=Cprg>if ( j == 1)<o:p></o:p></p>

<p class=Cprg>goto aa ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>aa:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i + &quot; &quot; + j);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1.1<o:p></o:p></p>

<p class=Coutput>1 1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>There is no known way to quit out
of nested breaks in this version of C#. You may have to wait till the next
version and even then, no guarantees. The only alternative here is a goto
statement; this we have shown in the above program. These days the goto statement
has fallen in disrepute. No programmer worth his/her salt will admit in public
that they have ever used the goto statement. Most respectable programming
schools will refuse to teach it. Your programming mother will wash your mouth
with soap if she finds out that you have been reading all about goto. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>int i = 1;<o:p></o:p></p>

<p class=Cprg>for ( i = 1; i&lt;= 10 ; i++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;1 try&quot;);<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>try<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>{<span
style='mso-tab-count:1'>           </span><o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(&quot;2
try&quot;);<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>break;<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>finally<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(&quot;2
finally&quot;);<o:p></o:p></p>

<p class=Cprg><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>finally<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;1 finally&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>1 try<o:p></o:p></p>

<p class=Coutput>2 try<o:p></o:p></p>

<p class=Coutput>2 finally<o:p></o:p></p>

<p class=Coutput>1 finally<o:p></o:p></p>

<p class=Coutput>1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The for loop starts and enters
the first try, Here it comes across another try and then when least expected
encounters a break. It would love to get out of the for statement but it stops
to think for a while. The try statement has a finally clause. Hence before it
exits the try, it executes the code in the finally. Now it remembers that there
is one more try statement in the outstanding. This try also has a finally
clause. Once the code in finally gets executed, C# exits from the for loop. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thus, if the break is nested
among 20 finally clauses, all of them will first get executed and only then
will the break perform its task. Replace the break with a goto aa: statement
and the above explanation will still hold true.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 1;<o:p></o:p></p>

<p class=Cprg>for ( i = 1; i&lt;= 10 ; i++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa:<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,1): error CS0159: No such label 'aa' within the scope
of the goto statement<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,1): warning CS0164: This label has not been referenced<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can never transfer control
from one block to another block. The goto will allow you to leave a block but
never let you enter another block. This results in the error shown above. The
warning like every warning is at times best ignored.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto aa;<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa:;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0159: No such label 'aa' within the scope
of the goto statement<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,1): warning CS0162: Unreachable code detected<o:p></o:p></p>

<p class=Coutput>a.cs(7,1): warning CS0164: This label has not been referenced<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler is very picky about
you not entering a block. For those who came in late, a block is nothing but
valid C# code in open and close brackets { }. Remember, come heaven or earth,
you cannot enter a block. Add the above to one more mysteries in life that has
no rational answer.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>for ( int i = 1; i&lt;= 10 ; i++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try<o:p></o:p></p>

<p class=Cprg>{<span style='mso-tab-count:1'>           </span><o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>finally<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>break;<o:p></o:p></p>

<p class=Cprg>return ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(12,1): error CS0157: Control cannot leave the body of a
finally clause<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,1): warning CS0162: Unreachable code detected<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,1): error CS0157: Control cannot leave the body of a
finally clause<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You cannot quit out of a finally
block with a break or return statement. If you have a short-lived memory, we
will repeat and tell you that the finally clause of a try is always called. You
cannot leave a finally abruptly. All code in finally must be executed. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We also heed to the warning that
no code after a break ever is executed. In other words, the end point of a
break will never be reached. If it does so, some people tell us that it signals
the end of the world.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>for ( int i = 1; i&lt;= 3; i++)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;C&quot; + i);<o:p></o:p></p>

<p class=Cprg>continue;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;A&quot; + i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>C1<o:p></o:p></p>

<p class=Coutput>C2<o:p></o:p></p>

<p class=Coutput>C3<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The continue statement stops
executing the balance statements and restarts a new iteration of the loop. It
can be used in a while, do, foreach and obviously the for. The rules applied to
break, like having a trillion of them, hold true here also. You can try the
earlier programs of try and finally with continue in place of break. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Similar to break, you cannot
place continue in a finally block. A break says bye-bye to a loop whereas a
continue restarts from the first line of the for loop. Continue is used when
for some unknown reason, the programmer doesn't want to quit the loop but wants
to skip the remaining code in the loop.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It is then assumed that the code
does not exist from the continue keyword to the end point of the loop and the
control moves to the beginning of the loop. Identical to a break, if you ever
write any code after continue, C# will not execute it for a million years.
After that if the sun is yet left standing, it will then execute your code.
Most of what has been repeated earlier also applies to the return keyword.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A goto abides by all rules of
break and continue.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int aa = 10;<o:p></o:p></p>

<p class=Cprg>goto aa ;<o:p></o:p></p>

<p class=Cprg>aa: ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# stores the name of a label and
the name of a variable in different sections of the program. As they belong to
different namespaces, the above program does not generate any errors. Had C#
stored the name of a function and name of a variable in a different namespaces,
we could use the same name for both of them too. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A good programming language
design looks at different namespaces it requires and the contents within them.
The teeming millions like us then abide by their decision and pontificate on
its merits and demerits. We however are powerless to change any of their
decisions. The idea here is that you understand a little in English and then
apply that knowledge to a large number of C# statements.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The checked and unchecked
statements are similar to the corresponding operators except that these
statements act on blocks. The lock statement applies to Threads.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>The
Other Odds and Ends<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa: ;<o:p></o:p></p>

<p class=Cprg>aa: ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Errors</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,1): error CS0140: The label 'aa' is a duplicate<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Nothing, read my lips, Nothing
can ever be a duplicate. Not even a label.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>goto case 5 ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Errors</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0153: A goto case is only valid inside a
switch statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A goto case statement only fits
in a case statement. It cannot be used outside a case.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>la:<o:p></o:p></p>

<p class=Cprg>;<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>la:<o:p></o:p></p>

<p class=Cprg>;<o:p></o:p></p>

<p class=Cprg>goto la;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,1): error CS0158: The label 'la' shadows another label
by the same name in a contained scope<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Like variables, we cannot have
two labels with the same name shadowing each other. If we use common sense then
the goto would jump to the inner label. What makes sense to us is not what
makes sense to the compiler. If we remove the goto statement, then the error
too disappears.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if ( true) ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,12): warning CS0642: Possible mistaken null statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler does not like
nothingness. A semi colon by itself stands for a valid statement but at the
same time is an empty statement. If we use a semi colon only where a statement
is due, the compiler gently prods us with a warning.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 6;<o:p></o:p></p>

<p class=Cprg>switch(i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,1): warning CS1522: Empty switch block<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>Empty vessels make the most noise. The compiler does not
understand anything empty including a switch statement. Relax, it is only a
warning and can be ignored!</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap2.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:40:43 GMT -->
</html>
