<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap10.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:41:11 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="Chap10_files/filelist.html">
<link rel=Edit-Time-Data href="Chap10_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Compiler Error Messages - C# Nuts and Bolt - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T12:21:00Z</o:Created>
  <o:LastSaved>2001-09-27T12:22:00Z</o:LastSaved>
  <o:Pages>56</o:Pages>
  <o:Words>14074</o:Words>
  <o:Characters>80226</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>668</o:Lines>
  <o:Paragraphs>160</o:Paragraphs>
  <o:CharactersWithSpaces>98523</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:Garamond;
	panose-1:2 2 4 4 3 3 1 1 8 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:15.0pt;font-family:Garamond;
color:black'>Chapter 10</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:26.0pt;font-family:Garamond;
color:black'>Compiler Error Messages</span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We will come across a large number
of errors that state Internal Compiler Error. These errors are extremely
dangerous as the compiler itself cannot figure them out. They fall under two
broad categories. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>One, we may have made some dumb
mistake which the developers at Microsoft may have not even thought off, thus
confusing the compiler thoroughly. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Secondly, there could be a
genuine bug in the compiler. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Take your pick. The first error
number CS0001 is an internal compiler error. A catch all phrase for 'I do not
know what went wrong'. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thus, the very first compiler
error number is thrown when the compiler is totally confused and doesn't know
how to react to the error. The compiler will resort to this error as the last
error before breaking down. Please understand the irony. The guys who wrote the
compiler could have made it the last error number but symbolically made it the
first. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After studying the different
programming languages developed so far over a period, we figured out that the
best way to understand more about any programming language is by placing
ourselves in the shoes of the sole person who wrote the language. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This person did not write the
language per se but a compiler through which he expressed his philosophy of the
language. Thus, the only way out is to understand the million error messages we
receive. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This process gets us into the
minds of a compiler, thus unearthing what it perceives is right and wrong with
our program. Thus, we have endeavored to sprinkle throughout our books every
error message the compiler can ever throw at us. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After CS0001, we realized that
there was no error message CS0002. Since the numerical part of the error number
is the only one that changes, we concluded that there can be a maximum of only
9999 errors that we can ever make.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In today's world you will rarely
come across error number CS0003 as it signifies an out of memory condition.
With RAM so cheap today, we will never ever run out of memory. If we do, then
the compiler will use our hard disk as memory. This is called virtual memory, and
if you come across a CS0003 then consider yourself blessed. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,5): warning CS0168: The variable 'i' is declared but
never used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A variable when not used in the
program gives us a benign warning. Some software companies hate compilers
producing even a single warning. So, to convert warnings into errors, they
implement the /warnaserror option as in<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /warnaserror a.cs <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This produces the same warning in
the form of an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,5): error CS0168: The variable 'i' is declared but
never used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As an error is reported, the
compiler does not generate an exe file. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The documentation says that the
message number should be CS0004 in the above case. But we fail to understand it
as our error number is reported as CS0168.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class
zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS0645: Identifier too long<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are limits to everything in
life. In C#, a user defined type cannot exceed 512 characters. These are the
limits that the designers imposed on us lowly programmers. Why on earth would
anyone create a type or class name larger than 32 characters is beyond our
imagination. The above information is useful in game shows to test one's
knowledge of unnecessary trivia!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>string s = -&quot;hell&quot;;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,12): error CS0023: Operator '-' cannot be applied to
operand of type 'string'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Not all operators can be applied
to operands of any data type. So, the unary minus operator cannot be applied to
strings. The designers of the string class decided not to have an overload for
the minus operator for reasons known only to them. Thus, operator overloading
lets you teach an old dog new tricks. You can associate an operator to work
with operands of different data types.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS0025: Standard library file
'C:\WINDOWS\MICROSOFT.NET\FRAMEWORK\V1.0.2204\mscorlib.dll' could not be found<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We received the above error when
we renamed mscorlib.dll in the above subdirectory to xxx.dll. The compiler,
csc, expects certain files in certain directories. If those files are not
present we get a CS0025 error. The best alternative here is to reinstall the
.NET framework.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(aaa a) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.abc(5); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,13): error CS0051: Inconsistent accessibility:
parameter type 'aaa' is less accessible than method 'zzz.abc(aaa)'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thou shall not spend beyond your
means is what has been always taught but we never practiced the adage. Never
keep friends that spend more money than you have. Commonsense? In the above
example, the class zzz is public and we are calling a function abc in it. This
function accepts a parameter that looks like aaa. Unfortunately, as the class
aaa has no access modifiers the default is internal. The class zzz as mentioned
earlier is public, so it is higher in accessibility than internal. They need to
have the same or higher accessibility. The only way out is to remove public
from zzz or add a public to class aaa. Also, the class aaa can be public and
class zzz may be internal and all yet work fine. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>So, as we said before, equalize
to higher accessibility not lower.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public aaa p1<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return new aaa();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,12): error CS0053: Inconsistent accessibility: property
type 'aaa' is less accessible than property 'zzz.p1'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The same rules apply everywhere.
We cannot return an object aaa from a property p1 as it is less accessible than
the class zzz. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public aaa this[int i]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return new aaa();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,12): error CS0054: Inconsistent accessibility: indexer
return type 'aaa' is less accessible than indexer 'zzz.this[int]'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Ditto for indexers. They have a
separate error message for each concept even though a common one would suffice.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int this[aaa i]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,12): error CS0055: Inconsistent accessibility:
parameter type 'aaa' is less accessible than indexer 'zzz.this[aaa]'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The same rules that hold good for
return values also stand true for parameter types as an indexer can have any
type as a parameter.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To stop further repetition, if an
operator returns an aaa in the above case we would get CS0056 and a CS0057 if
the parameter is inaccessible. CS0058 deals with delegates and CS0059 for
parameters to delegates. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz : aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,14): error CS0060: Inconsistent accessibility: base
class 'aaa' is less accessible than class 'zzz'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We should never ever enter into a
marriage with someone far better than us. It simply does not work! In the same
way, we cannot derive from a class that is less accessible than we are. In this
case, aaa is internal and we are public. Lest you have forgotten, public has no
rules associated with it whereas internal applies to the current source file
only.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface zzz : aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,18): error CS0061: Inconsistent accessibility: base
interface 'aaa' is less accessible than interface 'zzz'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The same rules apply to an
interface as to a class. We only have a separate error message.<o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,7): warning CS0105: The using directive for 'System'
appeared previously in this namespace<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>For various reasons we are not
allowed to use the same using directive more than once in our program. There
are many things in life that one just does not understand. It does not cause
anyone any harm if we include the same using twice. Many people don't do things
unless told twice. But, who are we to argue with a compiler?!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>new int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,9): warning CS0109: The member 'zzz.i' does not hide an
inherited member. The new keyword is not required.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The keyword new is used for
versioning. It lets you create a new member altogether and has nothing to do
with the ones having the same name in the base class. In this case, i is not
present in the base class but yet we have used the keyword new with i in zzz.
Here the new keyword is redundant but the compiler gives us only a warning and
not an error. A warning is something that is not at all serious.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,30): error CS0113: A member 'zzz.abc()' marked as
override cannot be marked as new or virtual<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Fire and water do not mix with
each other. In the same way there are certain modifiers which cannot be used in
conjunction with each other. When we override a function, it replaces a
function with the same name in a base class. Also, if we add the new modifier,
then we are saying that it overrides the base class function. A contradiction
of the first order!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A function can only be overridden
if it is marked virtual in the base class. No point in saying it again.
Override means replace the function in the base class. At the same time if we
use the modifier abstract, then we are saying the function has no code. How on
earth can we override a function in the base class with one that has no code at
all? Two wrongs do not make a right!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy {<o:p></o:p></p>

<p class=Cprg>public override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,22): error CS0115: 'zzz.abc()': no suitable method
found to override<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A function is not known by its
name but by its signature. In this case we have two functions carrying the same
name but with different signatures. Thus in class zzz there is no suitable
function abc in class yyy to override and hence the error. We are asking the
compiler to override a function but there is no such function in the base class
to override. In the case of new, we only received a slap on our wrists, a
warning. Here we get an error instead.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>static zzz(int o)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,8): error CS0132: 'zzz.zzz(int)': a static constructor
must be parameterless<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Static constructors are a new
concept in programming languages. They are called at the time of loading the
class and hence we can never call them, only the system calls them. The system
never calls them with parameters and hence the above error indicates that a
static constructor cannot accept parameters.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static int i = 2;<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 6;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>i++;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(9,1): error CS0135: 'i' conflicts with the declaration
'zzz.i'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The problem here is a logical one
and not one of syntax. The variable i created in function Main dies at the end
of the brace. Then the static i created outside Main is incremented. What the
compiler is upset about is the fact that in the Main function it encounters two
variables with the same name i. Being uncomfortable with this situation, it
drops an error. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The meaning of a variable must
not be changed within a function, thus name hiding generates the above error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>try {}<o:p></o:p></p>

<p class=Cprg>catch ( yyy a) {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(9,9): error CS0155: The type caught or thrown must be
derived from System.Exception<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The catch clause takes a
parameter which is either an instance of a class System.Exception or a class
derived from System.Exception. Here yyy is not derived from System.Exception
and hence the error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>public int j;<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,5): warning CS0169: The private field 'zzz.i' is never
used<o:p></o:p></p>

<p class=Coutput>a.cs(3,12): warning CS0649: Field 'zzz.j' is never assigned
to, and will always have its default value 0<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>a private member and a public
member when not used gives two different warnings. The second warning very
clearly informs us that the public variable has been initialized to zero, which
does not happen in the case of private variables.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>public int j;<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a.i+&quot; &quot; + a.j);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,5): warning CS0649: Field 'zzz.i' is never assigned to,
and will always have its default value 0<o:p></o:p></p>

<p class=Coutput>a.cs(4,12): warning CS0649: Field 'zzz.j' is never assigned
to, and will always have its default value 0<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>0 0<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>However, if we create an object
that looks like zzz, then the compiler does not distinguish between public and
private and gives the same warning. Contrast it with the situation earlier. You
can figure out these different warnings yourselves.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>struct yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,26): error CS0170: Use of possibly unassigned field
'i'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The designers of the C# language
investigated as to why programs fail very often. They came about with the
conclusion that programmers hate initializing variables. These variables, thus,
have a random value when they are being used. To eliminate such errors, the
designers forbade us from using a variable without giving it an initial value.
A structure is also a collection of variables and what applies to one variable
also applies to a collection. Thus, the compiler makes sure that each and every
variable is given a value before we can use them.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>base = 10;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(base);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0175: Use of keyword base is not valid in
this context<o:p></o:p></p>

<p class=Coutput>a.cs(6,26): error CS0175: Use of keyword base is not valid in
this context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Like it or not, all objects are
derived from a base class called Object. If we happen to be in a derived class
and we want to access a base class member irrespective of whether it is hidden
or not, the base keyword is to be used. This keyword is to be used to access
base class members only.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(out int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,13): error CS0177: The out parameter 'i' must be
assigned to before control leaves the current method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An out parameter must be
initialized before the function ends. This is because an out parameter does not
have to be initialized at the time of calling the function. The compiler
guarantees this and ensures that the out variable has been given a value. The
reverse applies to ref also. We have to give ref parameters a value before
calling a function.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public extern void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,20): error CS0179: 'zzz.abc()' cannot be extern and
declare a body<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we specify a function as
extern, it is our way of telling the compiler that the code of the function is
located in a different file. Hence, we should not be allowed to add code to our
function. If we do break this rule, we will get the above error. Extern
functions cannot have a definition.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public abstract extern void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><span style='font-size:10.0pt;font-family:
"Bookman Old Style"'><o:p></o:p></span></p>

<p class=Coutput>a.cs(3,29): error CS0180: 'zzz.abc()' cannot be both extern
and abstract<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The modifiers extern and abstract
both finally mean the same. No code allowed for the function. In the case of
abstract, the code will be supplied by the derived class and in extern from
some other place, maybe outside the current file. Thus abstract and extern are
mutually exclusive.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>static string s;<o:p></o:p></p>

<p class=Cprg>[System.Diagnostics.ConditionalAttribute(s)]<o:p></o:p></p>

<p class=Cprg>static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,42): error CS0182: An attribute argument must be a
constant expression, typeof expression or array creation expression<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The parameters passed to an
attribute can be one of the types as mentioned in the above error. Thus we
cannot use a variable as a parameter in the above case even though we are
giving it a string data type, which the parameter to the attribute expects it
to be.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (((System.Object) null) is string)<o:p></o:p></p>

<p class=Cprg>;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,7): error CS0186: Use of null is not valid in this
context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A null represents no object at
all. Thus we are not allowed to cast null into any other data type.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>struct yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int j;<o:p></o:p></p>

<p class=Cprg>yyy(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>j = i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,1): error CS0188: The this object cannot be used before
all of its fields are assigned to<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In a structure, we must first
initialize all the members of the structure before calling a function within
it. Remember all references are prefaced by a this. Calling the function abc in
yyy is equivalent to this.abc().<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>struct yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0188: The this object cannot be used before
all of its fields are assigned to<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>So pigheaded is the compiler that
even though we have no variables in the structure it yet gives us an error. The
compiler does not realize that we have no variables at all in the structure.
Maybe the next version of the compiler will not give us such an error. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The only explanation we can
provide is that if we have a constructor with parameters, then we have to
initialize at least one variable. This also means we need at least one variable
in the structure.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public readonly int i = 10;<o:p></o:p></p>

<p class=Cprg>zzz()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>i = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.i = 4;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,1): error CS0191: A readonly field cannot be assigned
to (except in a constructor or a variable initializer)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A readonly variable can only be
initialized in a constructor or at the time of creation. Anywhere else is a
no-no as it would defeat the very concept of being readonly.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static readonly int i = 10;<o:p></o:p></p>

<p class=Cprg>zzz()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>i = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The error reported is the same as
before as the readonly variable i is static and the constructor in which it is
being initialized is not static. Add the static modifier to the constructor and
watch the error fly away. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static readonly int i = 10;<o:p></o:p></p>

<p class=Cprg>public static void abc( ref int j)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz.abc(ref i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(9,13): error CS0199: A static readonly field cannot be
passed ref or out (except in a static constructor)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A static readonly field cannot be
passed as a parameter to a function like a normal readonly variable.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A statement comprises five
entities: an assignment, increment, decrement, call and a new.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void GetEnumerator () <o:p></o:p></p>

<p class=Cprg>{ <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz z = new zzz();<o:p></o:p></p>

<p class=Cprg>foreach (zzz x in z) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(9,1): error CS0202: The call to GetEnumerator must return
a class or a struct, not 'void'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The GetEnumerator function must
return a class or a struct, surely not a void.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>One error that we did not have
the heart to shown you is CS0204. This one pops up when you have more than
65535 local variables in your program. Who on earth has the time to create so
many variables and we doubt whether anyone on earth has ever seen this error
message? Trust is what makes the world go round and we trust the documentation.
<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc(params int[] a, __arglist)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,24): error CS0231: A params or __arglist parameter must
be the last parameter in a formal parameter list<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We cannot use the __arglist and
params together as parameters to a function. Either one of it is used. This is
because both of them are an array and they mop up whatever is left over of the
parameters. The __arglist is used to access parameters passed to a function. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(sizeof(i));<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,26): error CS0233: sizeof can only be used in an unsafe
context (consider using System.Runtime.InteropServices.Marshal.SizeOf)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The sizeof is a remnant of the C
programming language. Hence we can only use it in an unsafe context. In our
opinion, these are unnecessary restrictions placed on us by the compiler. Who
listens to the underdog?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 10;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(System.Runtime.InteropServices.Marshal.SizeOf(i));<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>4<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We took the advise of the error
message and used the SizeOf function in the class Marshal.<span
style="mso-spacerun: yes">  </span>We did receive the same answer that sizeof
would have given us in unsafe conditions. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The only hitch here is that i
must be initialized in advance. Such is not the case with the sizeof keyword.
This is one of the major difference between a function and a keyword. Something
that the language understands is treated differently from a parameter to a
function.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>abstract class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public abstract void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><span style='font-size:10.0pt;font-family:
"Bookman Old Style"'><o:p></o:p></span></p>

<p class=Coutput>a.cs(3,22): error CS0500: 'zzz.abc()' cannot declare a body
because it is marked abstract<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The concept of abstract expects
the derived class to write the code for the abstract functions. Thus, we cannot
write the code ourselves by specifying a body.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>abstract class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual abstract void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,30): error CS0503: The abstract method 'zzz.abc()'
cannot be marked virtual<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler hates repetition. An
abstract function is by default virtual and it gets upset if you specify
virtual again. Maybe the next version should be a lot more considerate when we
state the obvious again. Honestly, this would slim down the number of error
messages.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy {<o:p></o:p></p>

<p class=Cprg>public override void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int abc;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><span style='font-size:10.0pt;font-family:
"Bookman Old Style"'><o:p></o:p></span></p>

<p class=Coutput>a.cs(2,22): error CS0505: 'zzz.abc()' : cannot override;
'yyy.abc' is not a function<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can only override a function
provided a function with the same name is present in the base class. Here abc
is an int in the base class, not a function name and hence the error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>static zzz() : base()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,8): error CS0514: 'zzz.zzz()': static constructor
cannot have an explicit this or base constructor call<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A static constructor is not
allowed to call the static constructor of the base class using the keyword
base. The problem with static is that anything to do with it has to be known at
compile time only whereas the keyword this has a value only at run time. Plus,
static functions are not passed this and base as parameters.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static zzz() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,15): error CS0515: 'zzz.zzz()': access modifiers are
not allowed on static constructors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A static constructor is called
when the object is loaded. Thus, as it is an internal thing, we are not allowed
to use any access modifiers on static constructors.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public zzz() : this()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,8): error CS0516: Constructor 'zzz.zzz()' cannot call
itself<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A constructor can use the keyword
this and base to call any other constructor but itself. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public zzz() : this(10)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;Void&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public zzz(int i) : this()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;One&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;Start&quot;);<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Start<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>In our belief, the compiler does
not try hard enough to detect circular references. Here the constructors are
blindly calling each other and the compiler is blind to their doings. Thus, it
is easy to go into an indefinite loop while writing code. At times, we may
receive a runtime error stating: Unhandled Exception: StackOverflowException.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>struct zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public zzz(int i) : base(i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,8): error CS0522: 'zzz.zzz(int)': structs cannot call
base class constructors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Structures cannot call the base
class constructors as they in their very nature are sealed. Hence, what the
structure derives from cannot be called also. The other reason could be that
they are created on the stack. Thus, structures and classes in a sense are a
lot similar but a lot dissimilar too.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>struct zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>struct yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz b;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,5): error CS0523: Struct member 'yyy.b' of type 'zzz'
causes a cycle in the structure layout<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>You rely on someone to do a job
and he relies on you to do the same job. Chaos is the result. Hence, in the
struct zzz we have a member a that is an instance of a type yyy and struct yyy
in turn has a member called b that is an instance of zzz. This causes a cycle.
The complier thus throws its hands up in the air and gives up. Cyclic
references are like plague<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,14): error CS0524: 'zzz': interfaces cannot declare
types<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can do lots of things in an
interface but you cannot create your own class within them.<span
style="mso-spacerun: yes">  </span>A nested class is not permissible in an
interface. The reason for the restriction is that classes carry code with them
and an interface cannot have any code in it.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,1): error CS0525: Interfaces cannot contain fields<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Interfaces are all fluff. They
cannot have anything concrete. They are only rules that others have to obey.
Thus, a field, which is something finished, something complete cannot reside in
an interface.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii {<o:p></o:p></p>

<p class=Cprg>iii();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,1): error CS0526: Interfaces cannot contain
constructors<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Interfaces cannot have a whiff of
code. So having constructors is out of question. It cannot also have the
definition or a prototype of a constructor as it will then have to be filled
with code. Thus, constructors are not allowed to have a constructor definition.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz : iii,iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,17): error CS0528: 'iii' is already listed in interface
list<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler would hate seeing a
movie with a double role. You cannot derive from a interface twice. A class can
derive from multiple interface but not from the same one twice. Makes sense.
Why would anyone do something so foolhardy?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii : jjj {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>interface jjj : iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,11): error CS0529: Inherited interface 'jjj' causes a
cycle in the interface hierarchy of 'iii'<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Anything cyclic is a problem for
the compiler. Here we will go on and on in a indefinite loop as interface iii
depends upon interface jjj which again depends upon iii.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>abstract public class zzz<span style="mso-spacerun: yes"> 
</span><o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>abstract public void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>abstract public class yyy : zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>new abstract public void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><span style='font-size:10.0pt;font-family:
"Bookman Old Style"'><o:p></o:p></span></p>

<p class=Coutput>a.cs(7,26): error CS0533: 'yyy.abc()' hides inherited abstract
member 'zzz.abc()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Class yyy is derived from zzz and
they both have an abstract function called abc. In the class yyy abc has a new
modifier, thus it has nothing to do with the base class abc. The problem is
that the base class abc has no code at all and thus making the yyy class abc
new makes no sense. New assumes that we are creating a different function over
the base class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>interface yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,14): error CS0536: 'zzz' does not implement interface
member 'yyy.abc()'. 'zzz.abc()' is either static, not public, or has the wrong
return type.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Any mistake on our part gives an
error. Interface yyy contains a function abc which is to be implemented in zzz.
But while implementing it in zzz,<span style="mso-spacerun: yes">  </span>we
made it static. The compiler is very clear on one point. Implement the entire
function including return type and access modifiers as they are in the
interface otherwise conk out. No deviations from the original is allowed under
any circumstances.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void yyy.abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,6): error CS0538: 'yyy' in explicit interface
declaration is not an interface<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are allowed to specify the
interface name before a function with a dot as a separator. This is because we
are allowed to implement a class from multiple interfaces, which may carry the
same function name. However, yyy is the name of a class and not a interface.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void yyy.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>interface yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,6): error CS0541: 'yyy.abc': explicit interface
declaration can only be declared in a class or struct<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are only allowed to use the
explicit interface notation in a class or a structure. Within another
interface, it is not accepted. This speaks of sound common sense as an
interface can never ever carry code and thus cannot carry the definition or
code of the function either. Thus specifying the interface the function dwelled
in does not make any sense.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public override int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,21): error CS0544: 'zzz.i' : cannot override; 'yyy.i'
is not a property<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can have a property called i
in the derived class and a variable called i in the base class. The compiler
can live with it and they can both coexist. The problem starts the moment we
override the property i in the derived class. This is not allowed as we have no
property by the same name in the base class. We have only a lowly variable.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public override int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>get { return 0;}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy {<o:p></o:p></p>

<p class=Cprg>virtual public int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set { }<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,1): error CS0545: 'zzz.i.get': cannot override because
'yyy.i' does not have an overridable get accessor<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>A property does not exist by
itself. It comes along with a get and set accessor. You cannot exceed what the
designers chose to implement in the base class. Only things that are virtual in
the base class can be overridden. So, the only way out of the above quandary is
to define a<span style="mso-spacerun: yes">  </span>get like the set.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>sealed class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public virtual void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,21): error CS0549: 'zzz.abc()' is a new virtual member
in a sealed class 'zzz'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The sole purpose of virtual in
life is to ensure overriding of a function in he base class within the derived
class. A sealed class cannot be used as a base class and hence virtual
functions are a contradiction in terms.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int iii.i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><span style='color:red'><o:p></o:p></span></p>

<p class=Coutput><span style='color:black'>a.cs(3,5): error CS0551: Explicit
interface implementation 'zzz.iii.i' is missing accessor 'iii.i.get'</span><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0550: 'zzz.iii.i.set' adds an accessor not
found in interface member 'iii.i'<o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS0535: 'zzz' does not implement interface
member 'iii.i.get' <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In an interface we have a
property i with a get and no set. In the derived class, we have not added the
same property but instead given a set property. The compiler throws error
messages as it feels we are confused with what we were trying to achieve.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public ~yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,9): error CS0574: Name of destructor must match name of
class<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A destructor is called a
destructor because it is of the same name as the name of the class. You cannot
have any other name starting with a ~ in a class.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz : iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.Diagnostics.ConditionalAttribute(&quot;hi&quot;)]<o:p></o:p></p>

<p class=Cprg>void iii.abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,2): error CS0577: Conditional not valid on
'zzz.iii.abc()' because it is a constructor, destructor, operator, or explicit
interface implementation<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An attribute cannot be used
anywhere and everywhere. Fools rush in where angels fear to tread. Thus, we
cannot use the ConditionalAttribute on a constructor, destructor, operator, or
explicit interface implementation. The error message informs us the same.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.Diagnostics.ConditionalAttribute(&quot;hi&quot;)]<o:p></o:p></p>

<p class=Cprg>int abc() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,2): error CS0578: Conditional not valid on 'zzz.abc()'
because its return type is not void<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When creating an attribute you
can be extremely picky about where it can be used. The ConditionalAttribute can
be used only above functions that return void. One more rule to remember!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.CompilerServices;<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[IndexerName(&quot;abc&quot;, &quot;def&quot;)] <o:p></o:p></p>

<p class=Cprg>public int this [int index] <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,14): error CS0580: Too many unnamed arguments to
attribute 'IndexerName'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Attributes have their own set of
rules and regulations. The designers of the IndexerName attribute allowed only
a single parameter of a string data type. We are passing it two strings and
hence the error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.CompilerServices;<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[IndexerName(&quot;abc&quot;, vijay=2)] <o:p></o:p></p>

<p class=Cprg>public int this [int index] <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,2): error CS0581: Named arguments not allowed on
attribute 'IndexerName'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are also not allowed to use
named arguments, as the attribute does not understand them.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>interface iii <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.Diagnostics.ConditionalAttribute(&quot;DEBUG&quot;)]<span
style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cprg>void zz();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,2): error CS0582: Conditional not valid on interface
members<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are not allowed to use the
ConditionalAttribute on an interface member. We can decide with the precision
of a stealth bomber where an attribute is allowed. This is one more restriction
on an interface member.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>[StructLayout(LayoutKind.Sequential | LayoutKind.Explicit)]<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An attribute cannot have options,
which are contradictory in the definition of the attribute. In the above case,
both of them are valid. <o:p></o:p></span></p>

<p class=Cprg><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void this [int i]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,6): error CS0620: Indexers cannot have void type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Indexers, Properties, Operators
cannot have void return types as they are diligent in the job they perform and
always return values. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>virtual void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,14): error CS0621: 'zzz.abc()' : virtual or abstract
members cannot be private<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>By default, a member in a class
is marked private. This prohibits the derived classes from accessing its
private functions. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A virtual function allows derived
classes to override its function whereas an abstract function is implemented in
a derived class. Hey, wait a minute! A private function cannot be accessed in a
derived class as we mentioned a couple of lines earlier. Thus, a private
function cannot be tagged with the modifiers virtual and abstract.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>[StructLayout(LayoutKind.Explicit)]<o:p></o:p></p>

<p class=Cprg>struct zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[FieldOffset(5)]<o:p></o:p></p>

<p class=Cprg>public int i;<o:p></o:p></p>

<p class=Cprg>public int j;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,12): error CS0625: 'zzz.j' : Instance field types
marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset
attribute.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The StructLayout attribute lets
you decide on the memory layout for the structure. Normally the compiler
decides where in memory the individual fields will start but at certain times,
we would like to decide where in memory the fields should begin. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The parameter to the attribute,
which will give us complete freedom in laying out the fields in memory is
called LayoutKind.Explicit. This freedom comes at a price. We have to
individually specify where each field starts using the FieldOffset Attribute.
This is no partnership where we supply some and the compiler does the rest. The
destiny of the structure is now in our hands. We cannot miss out any field as
we did in the above example with variable j.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>sealed class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>protected void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,16): warning CS0628: 'zzz.abc()' : new protected member
declared in sealed class<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Remember warnings are not
life-threatening at all. A protected member only allows a derived class to use
a function and a sealed class cannot be derived from, hence the compiler thinks
we are confused or lost. May be it thinks we should have used private instead
as in this case the protected gets downgraded to private access. No big deal
and thus a warning.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.Diagnostics.Conditional(&quot;debug&quot;)]<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,13): error CS0629: Conditional member 'zzz.abc()'
cannot implement interface member 'iii.abc()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This particular attribute cannot
be used on an interface function. Ask the guys who designed the attribute what
was on his mind when he placed the above restriction.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int this[ref int i] <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,12): error CS0631: Indexers can't have ref or out
parameters<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It does not make any sense for an
indexer to have parameters that can be ref or out and as the parameter to an
indexer is nothing but an index of an array. Normally the parameter to an
indexer would be a number only which cannot be changed. Also, if we used a
variable, changing its value in an indexer would lead to confusion all around.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[zzz]<o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,2): error CS0616: 'zzz': is not an attribute class<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An attribute must be a class
derived from System.Attribute. This condition must be adhered to at all costs.
This is because the system can call lots of functions from the System.Atribute
class and we can override the functions if we want to change the behavior of
the attribute.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[xxx]<o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>[yyy]<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>abstract class yyy : System.Attribute<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,2): error CS0653: Cannot apply attribute class 'yyy'
because it is abstract<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>An abstract class cannot get a
job anywhere as it cannot be used anywhere. Such a class is incomplete and
unless completed it cannot be of any help to society. Thus, the class yyy, an
abstract class, cannot participate as an attribute but class xxx can as it is
not abstract. xxx must implements all the abstract functions of class yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = abc;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static int abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return 1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,9): error CS0654: Method 'zzz.abc()' referenced without
parentheses<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Function names have no great
significance in the C# programming language. We only use them to execute a
function after specifying the name and () brackets with parameters within them.
<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static public void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><span style='font-size:10.0pt;font-family:
"Bookman Old Style"'><o:p></o:p></span></p>

<p class=Coutput>a.cs(3,15): error CS1004: Duplicate 'public' modifier<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Two of the same is what the
compiler hates. Here we are not allowed to specify the same modifier twice. Hey
we meant no harm but who is listening. They do not have to be physically
together on the line for the error to be flagged.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>object *p;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,8): error CS1005: Indirection to managed type is not
valid<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A * signifies a pointer and the
managed types like object etc cannot be accessed through a pointer. Pointers
were created for being used by the value types.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,5): error CS1007: Property accessor already defined<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You cannot say or do the same
thing twice. As we are creating the same set accessor twice, which one should
the compiler take heed off. It chooses neither and gives you a simple error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>int i<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,1): error CS1014: A get or set accessor expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A property can only contain a get
and a set.. We cannot place any arbitrary function name within a property.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public zzz () :<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>{ <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,1): error CS1018: Keyword this or base expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After the name of the
constructor, we have complete control over which constructors to call though it
is optional. If we specify a :, then we have to use base or this to call the
appropriate constructor. If we leave it blank, all hell breaks loose and we get
an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,1): error CS1022: Type or namespace definition, or
end-of-file expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An extra brace } added by mistake
does not result in a simple English like error. Instead, we get end of file
expected. Where is the neighbourhood going these days?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#vijay<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,2): error CS1024: Preprocessor directive expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Anything after the # or pound
sign can only be the name of a preprocessor symbol and not anything else. As
there are very few preprocessor symbols, we do not have much of a choice here.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#if true /*<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg>*/<o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,10): error CS1025: Single-line comment or end-of-line
expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After a preprocessor directive,
we can only use the single line comments and not the multiple line comments. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#if true 2<o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,10): error CS1025: Single-line comment or end-of-line
expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Any other preprocessor error also
results in a CS1025. May be as the preprocessor has lost its importance in C#
compared to C, they did not have separate error messages for the preprocessor
and used CS1025 as a catch all for all errors.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#if ( a== b <o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,13): error CS1026: ) expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>However, some common errors like
closing a ) bracket are caught by the compiler.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,2): error CS1028: Unexpected preprocessor directive<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When you catch the compiler with
its pants down it gives you error CS1028. Here the compiler saw an #endif with
no matching #if. Instead of sending us to the loony bin, it gave us the above
error. Hey, relax, mistakes always happen!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>/*<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,1): error CS1035: End-of-file found, '*/' expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>All good things in life must come
to an end even though we do not want them to. In this case, we have a start of
a multi-line comment but no end of multi line comment in sight. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>string b = @&quot;hell;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,12): error CS1039: Unterminated string literal<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>All strings have to end with
&quot; as they start off with a &quot;. If the @ sign is not around, you will
receive another error. Like in life end what you start.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>/* */ #define aa<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS1040: Preprocessor directives must appear
as first non-whitespace character on a line<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We all like coming first in life
and it is the same with a preprocessor directive. We cannot place it anywhere
else,<span style="mso-spacerun: yes">  </span>it has to be the first character
of a line. The number of spaces or white spaces are counted as valid characters
and like life ignores you and me, spaces are ignored by the compiler.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public st\u0061tic void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,20): error CS1519: Invalid token 'void' in class,
struct, or interface<span style='color:red'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A Unicode character set begins
with a \u and a number, which the Unicode character is known by. A small a is
known by the number 97 or 61 in hex. We are not allowed to use the Unicode
characters in keywords. Maybe it brings in more work for the compiler. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>abc(ref 10);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void abc(ref int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,9): error CS1510: A ref or out argument must be an
lvalue<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>A ref or an out must be a lvalue.
An lvalue is nothing but a variable that represents some memory. A property is
not an lvalue as it is a function and does not stand for a memory location. A
ref and out parameter require a memory location.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <span style="mso-spacerun: yes"> </span>: yyy<o:p></o:p></p>

<p class=Cprg><span style="mso-spacerun: yes"> </span>{<span
style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>base.j = 3;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static int j;<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS1511: Keyword base is not available in a
static method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Static is like the odd kid on the
block. It cannot perform a lot more than a non-static member. It has, for
example, no access to the keyword base with which it can access members of the
base class. The reason being that static means one and only one and this and
base are used to access multiple instance values.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<span style="mso-spacerun: yes">  </span>: yyy<o:p></o:p></p>

<p class=Cprg>{<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>int k = base.j;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static int j=10;<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,9): error CS1512: Keyword base is not available in the
current context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>We are not allowed to use the
keyword base outside of a function, property or a constructor. You can consider
it as an extra parameter to a function. It represents the class we are derived
from.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes">   </span><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,4): error CS1514: { expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we use keywords like
class, namespace, the compiler checks for an open the brace.<span
style="mso-spacerun: yes">  </span>If this character is omitted, then it stops
in its tracks and immediately before you can say 'halleluiah' it will throw up an
error!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes">   </span><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,1): error CS1520: Class, struct, or interface method
must have a return type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A method can be placed in any of
the following three places, a class, struct or an interface. There are no
assumptions made by the compiler. All functions have to return a value and even
if they do not, we have to explicitly specify that they do not. In the above
case, the function abc does not return any value and the compiler does not
guess or assume a return value for it. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<span style="mso-spacerun: yes">  </span>: yyy[]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,18): error CS1521: Invalid base type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we use an invalid
character in the name of the base class, we are confronted with the above
error. If we use the wrong name of a class, we are given a CS0234 error. Thus,
only an ill-formed base class name causes the above error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS1547: Keyword 'void' cannot be used in this
context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A void data type can only be used
with a function. It denotes absence of a return value. A variable cannot
represent absence or no value. Thus, no data type can represent a void or no
value. For these reasons, the compiler has reserved one error message
explicitly for it.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>5 + [ + throw + void;<span style="mso-spacerun: yes">     </span><o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,5): error CS1525: Invalid expression term '['<o:p></o:p></p>

<p class=Coutput>a.cs(5,9): error CS1525: Invalid expression term 'throw'<o:p></o:p></p>

<p class=Coutput>a.cs(5,17): error CS1525: Invalid expression term 'void'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You are not allowed to write
whatever you want and wherever you want especially in an expression. We are not
allowed to use reserved words indiscriminately anywhere we like. Thus, words
like void are a no-no in expressions. The compiler reserves error number CS1457
for your sloppiness.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,16): error CS1526: A new expression requires () or []
after type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler is extremely
unforgiving. If we forget even the () after new, it screams its head off at us.
Whenever we call new, we are executing a constructor, which may or may not be
passed parameters. That is the rationale behind the () brackets after new. Even
though we have no parameters to be passed to the constructor, we have to use
the new syntax. Ditto for [].<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a(3);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,6): error CS1528: Expected ; or = (cannot specify
constructor arguments in declaration)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In languages like C++, to create
an object that looks like zzz, either new was used or the class itself as in
zzz a(3). This would create an object like zzz and call the constructor with
one int parameter. The parameter would be given he value of three. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# treats value types and objects
in the same manner. As most of us come from the C++ school of writing code, to
prevent any such errors, the above error check has been introduced. If you have
a historical perspective of life, everything gets much clearly. One bone we
pick with the world is that nobody teaches history anymore. Those who do not
learn from history are forced to relive its mistakes, right?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#line &quot;abc&quot;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS1576: The line number specified for #line
directive is missing or invalid<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The #line directive requires by
divine law two parameters, the new line number and the file name. Stating only
one is not a valid option.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#line 10 abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,10): error CS1578: Filename, single-line comment or
end-of-line expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The #line is an extremely
sensitive animal. It needs a number followed by double quotations marks and
maybe a single line comment. Anything else will result in an error. Seen anyone
more stubborn in life?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>sealed override public void abc() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,29): error CS0115: 'zzz.abc()': no suitable method
found to override<span style='color:red'><o:p></o:p></span></p>

<p class=Cbase>The documentation clearly states that sealed can be used with a
function within a class. A sealed function as per the documentation can only be
used with an override method. Remove the override modifier and the error
displayed is as follows:<span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>a.cs(2,20): error CS0238:
'zzz.abc()' cannot be sealed because it is not an override<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The concept of sealed for a
function would prevent change to a single function only and not to an entire
class.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Compiler
Options <o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When we run the C# compiler as <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;Csc a.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>Microsoft (R) Visual C# Compiler Version 7.00.9030 [CLR
version 1.00.2204.21]<o:p></o:p></p>

<p class=Coutput>Copyright (C) Microsoft Corp 2000. All rights reserved.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We will first see the Microsoft
logo displayed. Seeing it all the time hurts the eye. Thus Microsoft gives you
a compiler option /nologo that will suppress the logo which would otherwise get
displayed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;Csc a.cs /nologo<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We always run the compiler with
the /nologo option. Nothing great here!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;Csc a.cs /nostdlib<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS0518: The predefined type 'System.Byte' is not defined
or imported<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The entire System namespace has
to be stored someplace and as of today it is stored in the dll mscorlib.dll.
This dll is searched and loaded always by the compiler thus the net effect is
that the System namespace is always available to us. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>With the option of /nostdlib, the
compiler is told to bypass this dll, mscorlib.dll, As the System namespace is
now unavailable to the compiler, an error is reported. For reasons left unknown
to us, the compiler first requires System.Byte from the System namespace.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace System<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>struct Byte<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS0518: The predefined type 'System.Int16' is not
defined or imported<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Now that we have created a dummy,
System.Byte structure the compiler goes away happy but comes back with another
request. It needs the System.Int16 structure. Can't it demand everything in one
go?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>//public static void Main()<o:p></o:p></p>

<p class=Cprg>//{<o:p></o:p></p>

<p class=Cprg>//}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace System<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>struct Byte<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>struct Int16<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>struct Int32<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>On entering int16, the compiler
asks for Int32.<span style="mso-spacerun: yes">  </span>All this leads to one
conclusion, if you don't load the System namespace, then you have to write code
for all the entities yourself. We tried adding many more structures but
eventually gave up as the list was endless. Rather have the System namespace
loaded from the dll, than key in all the structures ourselves. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int this[]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,17): error CS1551: Indexers must have at least one
parameter<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An indexer is to be used as an
array and hence must have, at the bare minimum, one parameter to do its job.
Else, we get an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,5): warning CS0168: The variable 'i' is declared but
never used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler produces a large
number of warnings. Some feel that they are too old for anyone to preach them.
For them, the compiler can be commanded to stop generating warning messages.
This option is called /nowarn.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /nowarn<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Gives us the following error
message:<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2006: Command-line syntax error:<span
style="mso-spacerun: yes">  </span>Missing ':&lt;text&gt;' for '/nowarn' switch<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>/nowarn is not enough, we need to
specify the error number that is to be suppressed. On giving the option as
/nowarn:168, the compiler will not display warning message 168, the one it
displayed earlier. Multiple warning message numbers are to be separated by a
comma but there is no option available to suppress all of them.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>b.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>} <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc *.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are allowed to use wildcards
with the compiler. The above command inturn gets rewritten as csc a.cs b.cs.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /recurse:zzz\*.cs<span style='color:red'><o:p></o:p></span></p>

<p class=Coutput><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase>The /recurse option lets you compile all .cs files in zzz and
its child directories recursively. <span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /reference:m.dll;m1.dll a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /reference option lets you
look into .dll files for the code of classes. If you have more than one dll
file to look into, then we need to separate them with a semicolon.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,5): error CS0168: The variable 'i' is declared but
never used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Run the command as<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /warnaserror<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /warnaserror does a very
simple thing. It converts all warnings into errors. This is advisable as a
policy because the compiler gives you a warning for a definite purpose. If a
program compiles without any warnings, chances are good that it will not blow
up in your face ever.<o:p></o:p></span></p>

<p class=Coutput>&gt;Csc a1.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2001: Source file 'a1.cs' could not be found<o:p></o:p></p>

<p class=Coutput>fatal error CS2008: No inputs specified<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We get two errors instead of one.
The first error occurs because there is no file called a1.cs in the current
directory. The second error arises as the only source file we gave the compiler
was non-existent and hence the compiler was left with no input source files.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;Csc a.cs a.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>warning CS2002: Source file 'a.cs' specified multiple times<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If we give the same source file
name a.cs multiple times, we only get a warning. The compiler ignores this
repetition.<span style="mso-spacerun: yes">  </span>You can give the same name
as many times as you like and all of them will be ignored<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Create a file z.rep as follows<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>z.rep</u><o:p></o:p></p>

<p class=Coutput>/nologo a.cs b.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Run the compiler as <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc<span style="mso-spacerun: yes">  </span>@z.rep<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Anything after an @ sign in the
command line is called a response file. This file contains compiler options and
source file names. This just relieves you from writing the options and
filenames on the command line.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Run<span style="mso-spacerun:
yes">  </span>the command as<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc @z.rep @z.rep<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2003: Response file 'C:\csharp\z.rep' included
multiple times<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Even response files cannot be
mentioned multiple times.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /r:<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2005: Missing file specification for '/r:'
command-line option<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>With the /r option, the dll name
is to be specified. In case you forget the dll name, you pay for it with an
error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /k:<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2007: Unrecognized command-line option: '/k:'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler does not understand
any option that begins with k:. Thus, the error is reported. Looks like the
command line options are not too many at all.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs @a1.rep<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2011: Unable to open response file
'C:\csharp\a1.rep'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We asked the compiler to open a
response file that does not exist in the csharpbook sub-directory. Hence,
CS2011 error number is reported<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><u>b.cs</u><o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>hell<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /bugreport:a.txt a.cs b.cs<o:p></o:p></p>

<p class=Coutput>Microsoft (R) Visual C# Compiler Version 7.00.9030 [CLR
version 1.00.2204.21]<o:p></o:p></p>

<p class=Coutput>Copyright (C) Microsoft Corp 2000. All rights reserved.<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>b.cs(4,1): error CS1519: Invalid token '}' in class, struct,
or interface member declaration<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>A file is being created with information needed to reproduce
your compiler problem, including the contents of all source code files.<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>Please describe the compiler problem (press Enter twice to
finish):<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>Describe what you think should have happened (press Enter
twice to finish):<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To create a bugreport, the
compiler asks you to describe the problem that you have faced and then press
enter twice.<span style="mso-spacerun: yes">  </span>At this point, we entered
vijay.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The next question that pops up is
for the solution to the problem. Here we key in sonal.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The contents of a.txt are
displayed as follows.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>a.txt</u><o:p></o:p></p>

<p class=Coutput>### C# Compiler Defect Report, created 08/29/01 19:33:19<o:p></o:p></p>

<p class=Coutput>### Compiler version: 7.00.9254<o:p></o:p></p>

<p class=Coutput>### .NET common language runtime version: v1.0.2914<o:p></o:p></p>

<p class=Coutput>### Operating System: Windows NT 5.0.2195<span
style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Coutput>### User Name: Administrator<o:p></o:p></p>

<p class=Coutput>### Compiler command line<o:p></o:p></p>

<p class=Coutput>csc /r:Accessibility.dll /r:Microsoft.Vsa.dll
/r:System.Configuration.Install.dll /r:System.Data.dll /r:System.Design.dll
/r:System.DirectoryServices.dll /r:System.dll /r:System.Drawing.Design.dll
/r:System.Drawing.dll /r:System.EnterpriseServices.dll /r:System.Management.dll
/r:System.Messaging.dll /r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll /r:System.Security.dll
/r:System.ServiceProcess.dll /r:System.Web.dll /r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll /r:System.Windows.Forms.Dll /r:System.XML.dll
/bugreport:a.txt a.cs b.cs<o:p></o:p></p>

<p class=Coutput>### Source file: 'C:\csharpbook\a.cs'<o:p></o:p></p>

<p class=Coutput>public class zzz<o:p></o:p></p>

<p class=Coutput>{<o:p></o:p></p>

<p class=Coutput>public static void Main()<o:p></o:p></p>

<p class=Coutput>{<o:p></o:p></p>

<p class=Coutput>}<o:p></o:p></p>

<p class=Coutput>}<o:p></o:p></p>

<p class=Coutput>### Source file: 'C:\csharpbook\b.cs'<o:p></o:p></p>

<p class=Coutput>class yyy<o:p></o:p></p>

<p class=Coutput>{<o:p></o:p></p>

<p class=Coutput>hell<o:p></o:p></p>

<p class=Coutput>}<o:p></o:p></p>

<p class=Coutput>### Compiler output<o:p></o:p></p>

<p class=Coutput>b.cs(4,1): error CS1519: Invalid token '}' in class, struct,
or interface member<span style="mso-spacerun: yes">        </span>declaration<o:p></o:p></p>

<p class=Coutput>### User description<o:p></o:p></p>

<p class=Coutput>vijay<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>### User suggested correct behavior<o:p></o:p></p>

<p class=Coutput>sonal<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Enter the following commands to
understand the next error message.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;attrib +r a.txt<o:p></o:p></p>

<p class=Coutput>&gt;csc /bugreport:a.txt a.cs b.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2012: Can't open 'a.txt' for writing<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The attrib command with +r option
will make the file a.txt as read-only. As the compiler could not write to it,
it generates the above error. The compiler would rather gives us an error than
change the attribute. The above set of instructions demonstrated the need for
error number CS2012.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /target:library<span style="mso-spacerun: yes"> 
</span>a.cs /baseaddress:ui<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2013: Invalid image base number 'ui'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we build a dll we can
specify where the dll is to be loaded in memory. This is done using the
/baseaddress option which demands a number in hex. As we didn't fulfil its
needs, we are returned an error. The baseaddress is always specified by
default, if we do not specify one.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.exe<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2015: 'C:\csharp\a.exe' is a binary file instead of a
source code file<o:p></o:p></p>

<p class=Coutput>error CS1504: Source file 'C:\csharp\a.exe' could not be
opened ('Unspecified error ')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We need to give the compiler a
source file consisting of a program and not a binary file. The second error is
a natural corollary to the first as it could not open the file. These two
errors go hand and glove with each other.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /codepage:890<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2016: Code page '890' is invalid or not
installed<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A codepage has to do with
different languages and your machine has to have the particular code page
installed on it before you can use it. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /nologo /target:library /main:zzz<span
style="mso-spacerun: yes">   </span>a.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2017: Cannot specify /main if building a module
or library<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Nobody likes contradictions. A
library or a dll is a very different animal than an exe file. You can have
either one or the other never both. We are first ask the compiler to build a
dll and then specify the class that contains the entrypoint function Main. As
main is valid only in an exe file, the error is reported<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The next error message in
sequence CS2018 points to a file called cscmsgs.dll for all the error messages.
This file does not exist on our computer.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /nologo /target:jjj a.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2019: Invalid target type for /target: must specify
'exe', 'winexe', 'library', or 'module'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can only build four types of
output files with this version of the compiler. We asked the compiler to build
the wrong type of target, hence the error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS2021: File name 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<o:p></o:p></p>

<p class=Coutput>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<o:p></o:p></p>

<p class=Coutput>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<o:p></o:p></p>

<p class=Coutput>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<o:p></o:p></p>

<p class=Coutput>aaaaaaaaaaaaaaaaaaaaaaaaaaaa.cs' is too long or invalid<o:p></o:p></p>

<p class=Coutput>fatal error CS2008: No inputs specified<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There is a variable/MACRO called
MAX_PATH which has a value of 260. If our file name exceeds this size we will
get an error CS2021. The compiler was asked to compile a file with a very long
name, since the name was too long, the error gets reported. We have gone to
extents to display every error!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>internal void abc(__arglist) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr(__arglist) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,13): error CS3000: Methods with variable arguments are
not CLS-compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>CLS stands for Common Language
Specification and is the thingy that makes sure that a class created in Cobol
can have a function added in Perl. Also it can be a base class for a class in
Visual Basic and be finally be called in C# or ASP.Net. To make sure that all
our code is CLS compliant, the above attribute shown above is to be applied to
the class. Only those functions that are not private or public can accept a
variable number of arguments. Thus, the abc function being internal does not
give an error whereas pqr does.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>internal void abc(ushort i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr(ushort i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,17): error CS3001: Argument type 'ushort' is not
CLS-compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The ushort data type is not CLS
compliant which means that all languages that are .NET compliant do not have to
support it. Like above, the rule applies only to private or public members.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public ushort<span style="mso-spacerun: yes">  </span>pqr() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,8): error CS3002: Return type of 'zzz.pqr()' is not
CLS-compliant<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The return type cannot be a
ushort in a CLS compliant class. In other words, the ushort data type cannot be
used anywhere.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ushort j;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public ushort i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,8): warning CS0168: The variable 'j' is declared but
never used<o:p></o:p></p>

<p class=Coutput>a.cs(8,15): error CS3003: Type of 'zzz.i' is not CLS-compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We need to slightly modify the
above statement. Variables created on the stack or local variables cannot be
marked with an access modifier. Thus, public instance variables cannot be
declared as ushort whereas local since they are not visible outside the
function.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public int a1;<o:p></o:p></p>

<p class=Cprg>public int A1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,12): error CS3005: Identifier 'zzz.A1' differing only
in case is not CLS-compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The C# programming language may
be case sensitive but CLS languages may not be. Thus when we write code which
is CLS complaint, we make sure we are also case insensitive.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly: System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int _a ;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,12): error CS3008: Identifier 'zzz._a' is not
CLS-compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There may be millions of
programming languages out there, which some day will be .NET compatible. Some
of them may have a special meaning for the underscore character. Thus, the CLS
forbids an underscore in the name of a variable.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public interface iii <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.CLSCompliant(false)]<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,7): error CS3010: 'iii.abc()': CLS-compliant interfaces
must have CLS-compliant members<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It does not make sense for the
entire interface to be CLS compliant other than one function in it. Even if a
single member is not CLS compliant, then the entire interface becomes CLS
non-compliant.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly: System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public abstract class iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.CLSCompliant(false)]<o:p></o:p></p>

<p class=Cprg>public abstract int abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,21): error CS3011: 'iii.abc()': non CLS-compliant
members cannot be abstract<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Programming languages the world
over may not have all the sophistication as in C#. The CLS specification is a
simpler and easier C#. Therefore a large number of features in C# are not
implemented in the CLS. Remember, C# is today arguably one of the world's most
powerful languages. One of the feature supported in C# and not a CLS compliant
is the notion of abstract. Hence, the above error. The CLS is a subset of the
C# language specification.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[module:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,9): warning CS3012: You must specify the CLSCompliant
attribute on the assembly, not the module, to enable CLS compliance checking<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The error message says it all.
You cannot specify the above attribute on a module.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(false)]<o:p></o:p></p>

<p class=Cprg>public class iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.CLSCompliant(true)] <o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,2): error CS3014: 'iii.abc()' cannot be marked as CLS
compliant because the assembly is not marked as compliant<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Just as we had some lines
earlier, we cannot have a class which is CLS compliant and a single member
within it which is non-CLS compliant. One rotten apple spoils the entire lot.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[assembly:System.CLSCompliant(true)]<o:p></o:p></p>

<p class=Cprg>public class zzz : System.Attribute<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public zzz(int[] i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,14): error CS3015: 'zzz' has no accessible constructors
which use only CLS compliant types<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>At the outset, we need one
constructor that is CLS complaint. Here we have only one construct but it is
not CLS complaint as arrays are not part of the allowed data types in a method
call.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Collections.ArrayList a = new
System.Collections.ArrayList();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(a.Item[0]);<o:p></o:p></p>

<p class=Cprg><span style="mso-spacerun: yes">      </span>//
Console.WriteLine(&quot;First Element is {0}&quot;, a.[0]);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,26): error CS0117: 'System.Collections.ArrayList' does
not contain a definition for 'Item'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When using indexed properties
like those in the ArrayList, we do not have to complicate life. The ArrayList
object is called a. To access its member, in place of a.Item[0], a simple<span
style="mso-spacerun: yes">  </span>a.[0] will do. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Nothing complicated here. We do
not have to use the Item specifier at all.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can never ever show you a an
error check for CS0174 as it occurs whenever we recompile System.Object. We do
not have the source code for it and hence we cannot compile it. It is the only
class that does not have any base class at all!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>lock (1) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0185: 'int' is not a reference type as
required by the lock statement<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The lock statement requires a
reference type for it to perform its job. The parameter cannot be an int or a
value type, hence the error. The lock statement works only on reference types.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We hate functions as they are so
boring. They insist that we always pass them the same number of parameters.
There is a way out to make sure that functions are allowed to receive a
variable number of parameters. To accomplish this task, the keyword __arglist
is incorporated. N number of parameters can be given then. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>__arglist used as a parameter
name in the function then contains a reference to the variable number of
arguments. To access the values, we create an object that looks like
ArgIterator with the __arglist as a parameter. The GetRemainingCount function
within this object returns the count of parameters and each parameter is then
retrieved using the GetNextArg member of the ArgIterator. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The values can be converted to an
int using __refvalue. If we do not then we will get a System.TypedReference
instead of the actual value. This is how we can pass a variable number of
parameters to a function.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void abc (int a) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>object o = __arglist;<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,12): error CS0190: The __arglist construct is valid
only within a variable argument method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can only use a __arglist
construct in methods, which will accept a variable number of arguments.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public unsafe static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int *i = null;<o:p></o:p></p>

<p class=Cprg>int j = 0;<o:p></o:p></p>

<p class=Cprg>j = i[1,2];<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /unsafe<u><o:p></o:p></u></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(7,5): error CS0196: A pointer must be indexed by only one
value<o:p></o:p></p>

<p class=MsoNormal style='text-align:justify;mso-layout-grid-align:none;
text-autospace:none'><span style='font-size:11.0pt'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The array brackets are only a
notation. They internally get converted into a pointer. Thus i[2] internally
becomes *(i+2). Thus, we can never have multiple indices for a pointer. Unlike
C, at one level the C# programming language and its faithful agents do not
understand the meaning of an array.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz** a = null;<o:p></o:p></p>

<p class=Cprg>foreach (zzz x in a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,1): error CS1579: foreach statement cannot operate on
variables of type '' because '' does not contain a definition for
'GetEnumerator', or it is inaccessible<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The variable a is a pointer to a
pointer to a zzz. This means that variable a contains the address of another
variable which in turn contains the address of an object that looks like
zzz.<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The foreach statement does not
understand objects completely. It requires certain functions to be present in
the object for it to successfully enumerate all of them.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public int i <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS1609: Modifiers cannot be placed on
property or event accessor declarations<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A property is superior to its get
and set accessors. If the property is made unsafe then it is common knowledge
that the accessors will also be unsafe. We have realized by now that the
compiler does not like us stating the obvious and hence adding the keyword
unsafe on the set accessor will bring about the above error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy<span style="mso-spacerun: yes">  </span>a = new yyy();<o:p></o:p></p>

<p class=Cprg>yyy *b;<o:p></o:p></p>

<p class=Cprg>b = <span style='font-family:"Bookman Old Style"'>&amp;</span>a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<span style="mso-spacerun: yes">            </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,5): error CS0208: Cannot take the address or size of a
variable of a managed type ('yyy')<o:p></o:p></p>

<p class=Coutput>a.cs(7,5): error CS0208: Cannot take the address or size of a
variable of a managed type ('yyy')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A two-in-one error. A combo at
last! The concept of pointers existed in the C programming language, which did
not understand classes let alone managed types. Thus, pointers are best left
alone to deal with values types and not managed types. We cannot figure out
their addresses in memory nor their size. A lot about managed types are best
handled internally by the compiler and are beyond our understanding. Like the
secret services, we cannot know everything.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>fixed (int i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,8): error CS0209: The type of locals declared in a
fixed statement must be a pointer type.<o:p></o:p></p>

<p class=Coutput>a.cs(4,12): error CS0210: You must provide an initializer in a
fixed or using statement declaration<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The garbage collector, if allowed
to move objects in memory, would make the pointer values meaningless. Hence, we
use the fixed statement to pin down a variable in memory while the code is
executing. We mark these objects as special using the statement fixed as we
want to prevent the garbage collector from moving objects holding addresses
around in memory. It is obvious that addresses can only be stored by a pointer
and not by any other variable. A fixed keyword is applicable only on pointers.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>fixed (int* i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,13): error CS0210: You must provide an initializer in a
fixed statement declaration<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Assuming we do use a pointer in a
fixed statement, our problems are not yet over. We have to initialize this
pointer to an object or any other value including null as in int *i = null. We
are not allowed to take the address of a managed object anywhere else except in
a fixed statement. The {} brackets is the range for which the garbage collector
promises not moving around as the objects has been pinned.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int j = 0;<o:p></o:p></p>

<p class=Cprg>int *i = <span style='font-family:"Bookman Old Style"'>&amp;</span>(j
+ 20);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,10): error CS0211: Cannot take the address of the given
expression<o:p></o:p></p>

<p class=Coutput>a.cs(6,10): error CS0212: You can only take the address of
unfixed expression inside of a fixed statement initializer<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Not everything in life has an
address. Only variables have an address. The expression j+20 has no address as
it does not represent a unique memory location. Thus, we can only give i= and
use the &amp; in front of entities that are stored in memory.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy {<o:p></o:p></p>

<p class=Cprg>public int i= 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main()<span style="mso-spacerun: yes"> 
</span>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>int *j = <span style='font-family:"Bookman Old Style"'>&amp;</span>a.i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,10): error CS0212: You can only take the address of
unfixed expression inside of a fixed statement initializer<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are certain rules to be
followed in an unsafe context. The object a is an instance of class yyy and
this makes it a managed object. Its address can only be taken in a fixed
statement and not anywhere else.<o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int i= 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>fixed ( int *j= null)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>j = <span style='font-family:"Bookman Old Style"'>&amp;</span>a.i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(10,14): error CS0213: You do not need to use the fixed
statement to take the address of an already fixed expression<o:p></o:p></p>

<p class=Coutput>a.cs(12,5): error CS0212: You can only take the address of
unfixed expression inside of a fixed statement initializer<o:p></o:p></p>

<p class=Coutput>a.cs(12,1): error CS1604: Cannot assign to 'j' because it is
read-only<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We explicitly said &amp; inside a
fixed statement and not in the range of the fixed. The only way out of a
nagging compiler is as follows.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy {<o:p></o:p></p>

<p class=Cprg>public int i= 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a = new yyy();<o:p></o:p></p>

<p class=Cprg>fixed ( int *j= <span style='font-family:"Bookman Old Style"'>&amp;</span>a.i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>No errors at last. A huge sigh of
relief!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 0;<o:p></o:p></p>

<p class=Cprg>fixed (int *j = <span style='font-family:"Bookman Old Style"'>&amp;</span>i)
<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,17): error CS0213: You do not need to use the fixed
statement to take the address of an already fixed expression<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Value types like an int are
created on the stack. Their positions in memory cannot change for the entire
duration of the function. At the end of the function they die. The garbage
collector cannot move them around in memory at all for optimizing your code to
make it run faster. Thus, if you take the address of a local variable in a
fixed statement, the compiler throws an error at you for doing the obvious.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public void abc(params int[] a, __arglist) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,17): error CS0231: A params or __arglist parameter must
be the last parameter in a formal parameter list<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We cannot have life the way we
want. The params and __arglist allow us to invoke a function with a variable
number of arguments. We have to choose on one of them. We cannot choose both as
the compiler will not know where one starts and the other gets over. This
cannot be called a restriction ever.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>delegate int ddd(__arglist);<span style="mso-spacerun: yes">  
</span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,14): error CS0235: __arglist is not allowed in
delegates<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are allowed to use the params
keyword in a delegate if we want it to accept a multiple number of arguments.
We cannot implement the same concept by using __arglist instead as it has
fallen out of favor with the compiler. It is a simple rule that the compiler
likes, so do we.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[System.Runtime.InteropServices.ComImport] <o:p></o:p></p>

<p class=Cprg>public class a<o:p></o:p></p>

<p class=Cprg>{<span style="mso-spacerun: yes">     </span><span
style="mso-spacerun: yes"> </span><o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,57): error CS0596: The Guid attribute must be specified
with the ComImport attribute<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The attribute called ComImport
lets you specify a class as an ActiveX object. Every ActiveX object is known by
a 16 byte or a 128 bit number called its GUID or Globally Unique Identifier. We
forget to specify this 16 byte number and hence our ActiveX object was only
known by its name and not its number, which is an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>[ComImport, Guid(&quot;vijay&quot;)]public class a<o:p></o:p></p>

<p class=Cprg>{<span style="mso-spacerun: yes">      </span><o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,13): error CS0647: Error emitting<o:p></o:p></p>

<p class=Coutput>'System.Runtime.InteropServices.GuidAttribute' attribute --
'Incorrect uuid format.'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>No programming language as of now
can represent a 16 byte number directly. We have a structure called GUID which
represents this 16 byte number. We have to represent this 16 byte number is a
certain way which looks like: Guid(&quot;1234abcd-a234-abcd-1111-678987654678&quot;).<span
style="mso-spacerun: yes">  </span>Since the program does not follow the rules,
an error is reported<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[System.Runtime.InteropServices.DllImport(&quot;USER32.DLL&quot;)]<o:p></o:p></p>

<p class=Cprg>extern int MessageBox(int a);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,2): error CS0601: The DllImport attribute must be
specified on a method marked 'static' and 'extern'.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The DllImport attribute informs
the compiler that the code of the function MessageBox is in a dll file called
user32.dll. As we have not created this function and the code too is not
present in the file, we have to signify that it is static and extern. We need
both modifiers, one alone will not suffice.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[DllImport(&quot;kernel32.dll&quot;)]<o:p></o:p></p>

<p class=Cprg>public static extern int abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes">    </span></span><span style='color:red'><o:p></o:p></span></p>

<p class=Cbase>The attributes DllImport applies to static and extern functions
only. <span style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>using System.Runtime.CompilerServices;<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[IndexerName(&quot;vijay&quot;)]<o:p></o:p></p>

<p class=Cprg>public int this[int i]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set { }<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[IndexerName(&quot;vijay&quot;)]<o:p></o:p></p>

<p class=Cprg>public override int this[int i] {<o:p></o:p></p>

<p class=Cprg>set { }<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(12,2): error CS0609: Cannot set the IndexerName attribute
on an indexer marked override<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can be extremely selective
the code that should access the attributes. The attribute called IndexerName
cannot be used on an indexer, which is override but can be used on the indexer
in class yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>public class yyy : Attribute {<o:p></o:p></p>

<p class=Cprg>int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>[yyy(i=0)] <o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,6): error CS0617: 'i' is not a valid named attribute
argument. Named attribute arguments must be fields which are not readonly,
static or const, or properties with a set accessor which are not static.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There is no way that we can use
the private members of an attribute class. The member i is private in class yyy
and hence can only be used if we use the access modifier public in front of it.
The error also tells us about the named arguments that can be used. At times,
these error messages are not bad guys and can be helpful at times.<o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>public class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[Obsolete(&quot;vijay mukhi&quot;, false)]<span
style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>public static void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,1): warning CS0618: 'yyy.abc()' is obsolete: 'vijay
mukhi'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have placed the Obsolete tag
in front of the function abc. The warning message vijay mukhi is only displayed
if we access function abc. Remember it is not an error but an aid to inform the
user not to use a certain function as they maybe discontinued in the future
versions.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Change the false in the attribute
to true as follows<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg>[Obsolete(&quot;vijay mukhi&quot;, true)]<span
style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(13,1): error CS0619: 'yyy.abc()' is obsolete: 'vijay
mukhi'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>All that happens is that the
warning message gets converted to an error. You decide on how serious it is if
we use a certain function which may get obsolete very soon. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>System.TypedReference i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,1): error CS0610: Field or property cannot be of type<o:p></o:p></p>

<p class=Coutput>'System.TypedReference'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The class TypedReference is
special and cannot be used to create a field but can be used as parameters to a
method.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.TypedReference[] i = new System.TypedReference[1];<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,23): error CS0611: Array elements cannot be of type
System.TypedReference<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An array type cannot also be a
TypedReference.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>static extern public void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,27): warning CS0626: Method, operator, or accessor
'zzz.abc()' is marked external and has no attributes on it. Consider adding a
DllImport attribute to specify the external implementation<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An extern method should have an
attribute of DllImport. This specifies the dll file containing the
implementation of the function. We expected an error and got a warning instead.
The world was never a predictable place to stay in!<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>[Obsolete(&quot;Vijay&quot;,IsError=false)]<span
style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main () <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>object[] a = typeof(I1).GetCustomAttributes();<o:p></o:p></p>

<p class=Cprg>Console.WriteLine (((ObsoleteAttribute)a[0]).IsError);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,19): error CS0632: 'IsError' : Named attribute argument
can't be a read only property<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An attribute can have read only
properties and they cannot be use as named arguments. The above error takes
place as IsError is a readonly property in the attribute obsolete and we are
trying to fetch its value in the WriteLine function.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>using System.Runtime.CompilerServices;<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[IndexerName(&quot;vijay mukhi&quot;)]<span style="mso-spacerun:
yes">   </span><o:p></o:p></p>

<p class=Cprg>public int this[int j]<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>} <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun: yes"> 
</span><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,7): error CS0633: argument to IndexerName attribute
must be a valid identifier<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The name attribute names the
indexer. We gave an invalid name of vijay mukhi, it has a space in it. Remove
the space and the error goes away. The name must follow all the rules of a
valid identifier.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>[StructLayout(LayoutKind.Sequential)]<o:p></o:p></p>

<p class=Cprg>struct zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[FieldOffset(40)]<o:p></o:p></p>

<p class=Cprg>public int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,2): error CS0636: FieldOffset attribute can only be
placed on members of type marked with the StructLayout(LayoutKind.Explicit)<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The FieldOffset attribute
specifies where each field will appear in memory. We have a complete control
over the layout of the structure. The only condition is that we need to use the
LayoutKind as Explicit and not as Sequential.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=Cprg>[StructLayout(LayoutKind.Explicit)]<o:p></o:p></p>

<p class=Cprg>struct zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>[FieldOffset(40)]<o:p></o:p></p>

<p class=Cprg>public static int i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,2): error CS0637: The FieldOffset attribute not allowed
on static or const fields<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>One more restriction on the
attribute FieldOffset is that we cannot use it on static or const fields as the
compiler would like to decide where to place them in memory.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[abc:vijay]<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,6): error CS0658: 'abc' is not a valid attribute
location<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Here, abc is any arbitrary name
that we have chosen, hence the error is reported. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>[AttributeUsage(AttributeTargets.All)]<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,2): error CS0641: 'AttributeUsage' : attribute is only
valid on classes derived from System.Attribute<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The class AttributeUsage is used
to inform the compiler where the attribute class can be used. Thus the class
following must be derived from System.Attribute to qualify as an attribute
class. If you do not follow the above rules, you will get saddled with the
above error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>[System.Reflection.DefaultMemberAttribute(&quot;viajy&quot;)] <o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public int this[int i] <o:p></o:p></p>

<p class=Cprg>{<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cprg>set {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,2): error CS0646: Cannot specify the DefaultMember
attribute on type containing an indexer<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Any class that is tagged with a
DefaultMemberAttribute cannot be used with a class that contains an indexer.
Strange are the ways of the world at first sight.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Note: Xml warnings are only
generated if you use the /doc: option along with the compiler i.e. csc a.cs
/doc:a.xml<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static zzz operator / (zzz<span style="mso-spacerun:
yes">  </span>a1, zzz a2) <o:p></o:p></p>

<p class=Cprg>{ <o:p></o:p></p>

<p class=Cprg>return null;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>/// &lt;seealso cref=&quot;zzz.operator@&quot;/&gt;<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,14): warning CS1591: Missing XML comment for publicly
visible type or member 'zzz'<o:p></o:p></p>

<p class=Coutput>a.cs(3,19): warning CS1591: Missing XML comment for publicly
visible type or member 'zzz.operator /(zzz, zzz)'<o:p></o:p></p>

<p class=Coutput>a.cs(7,33): warning CS1003: Syntax error, '&quot;' expected<o:p></o:p></p>

<p class=Coutput>a.cs(7,32): warning CS1039: Unterminated string literal<o:p></o:p></p>

<p class=Coutput>a.cs(7,32): warning CS1037: Overloadable operator expected<o:p></o:p></p>

<p class=Coutput>a.cs(7,20): warning CS1584: XML comment on 'zzz.Main()' has
syntactically incorrect cref attribute 'zzz.operator@'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler found an invalid
link with ///. The operator statement was wrong as it did not specify the
correct operator.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /nologo /resource:a.bmp<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1566: Error reading resource file 'C:\csharp\a.bmp' --
'The system cannot find the file specified. '<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This error takes place when the
compiler cannot find the specified filename.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /nologo /resource:a.bmp,aa /resource:b.bmp,aa<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1508: Resource identifier 'aa' has already been used
in this assembly<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We copied two files a.bmp and
b.bmp in our current subdirectory. Using the /resource option, we can specify a
name for the resource. We gave the same name and hence we received an error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#if aa<o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if !aa<o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if (aa) <o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if true<span style="mso-spacerun: yes">     </span><o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if false<span style="mso-spacerun: yes">    </span><o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if 1<span style="mso-spacerun: yes">        </span><o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if ~aa<o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cprg>#if *<span style="mso-spacerun: yes">        </span><o:p></o:p></p>

<p class=Cprg>#endif<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(11,5): error CS1517: Invalid preprocessor expression<o:p></o:p></p>

<p class=Coutput>a.cs(13,5): error CS1517: Invalid preprocessor expression<o:p></o:p></p>

<p class=Coutput>a.cs(15,5): error CS1517: Invalid preprocessor expression<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The last three preprocessors
directives gave us an error as we cannot use a number,<span
style="mso-spacerun: yes">  </span>the ~ sign or a * to the #if. True and false
are ok and so are () etc.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /warn:100<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1900: Warning level must be in the range 0-4<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There are only five warning
levels, starting from zero. Depending upon the warning number used, we will see
certain types of warnings. The rest will be suppressed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs<span style="mso-spacerun: yes">  </span>/warn:0
/warnaserror<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1901: Conflicting options specified:<span
style="mso-spacerun: yes">  </span>Warning level 0; Treat warnings as errors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>/warn:0 turns the warnings off
and /warnaserror treats warnings as errors. The compiler thinks we are drunk,
hence it tries to clarify things about these two mutually exclusive options.<o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /reference:\charpbook<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS0006: Metadata file '\charp' could not be found<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have to specify the name of a
file not a subdirectory.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /reference:\<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1541: Invalid include option: '\' -- cannot include
directories<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have to give some compiler
options an actual file name. Names of sub-directories are not allowed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>&gt;csc a.cs /main:zzz<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS1558: 'zzz' does not have a suitable Main
method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /main option specifies which
class contains the method main. If we had two .cs files and each contained the
Main function, the /main option informs the compiler about the file it should
consider having the entry point.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /main:zzzz<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1555: Could not find 'zzzz' specified for Main method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /main option has to be
supplied with the name of a class that exists in the .cs files. Common sense.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>class zzz {<o:p></o:p></p>

<p class=Coutput>}<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,7): error CS1558: 'zzz' does not have a suitable Main
method<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /main compiler option
specifies the class containing the function Main. We we so absent-minded that
we forget to write one in the class zzz,<span style="mso-spacerun: yes"> 
</span>hence the compiler comes back with the relevant error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>#line 12
&quot;abccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc<o:p></o:p></p>

<p class=Cprg>ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc<o:p></o:p></p>

<p class=Cprg>cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc<o:p></o:p></p>

<p class=Cprg>ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc&quot;<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,11): error CS1560: Filename specified for #line is too
long<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The name of the file in the #line
directive cannot exceed 256 characters. We exceeded the limit.<o:p></o:p></span></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /nologo /win32res:a.res /win32icon:a.ico<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1565: Conflicting options specified:<span
style="mso-spacerun: yes">  </span>Win32 resource file; Win32 icon<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A res file stores various
resources like images, sound files, menus, icons etc. in a compiled form. An
.ico file can be used to store an icon exclusively too. The above two options
hate each other and thus cannot be given together. <o:p></o:p></span></p>

<p class=Coutput>&gt;attrib +r a.xml<o:p></o:p></p>

<p class=Coutput>&gt;csc /nologo /doc:a.xml a.cs <o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1569: Error generating XML documentation file 'a.xml'
('Access is denied. ')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We made the file a.xml read only
and as the /doc option could not write to the file we receive the above error.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>// the following line generates CS1570<o:p></o:p></p>

<p class=Cprg>/// &lt;summary&gt; returns true if &lt; 5 &lt;/summary&gt;<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,32): warning CS1570: XML comment on 'zzz' has badly
formed XML -- 'Whitespace is not allowed at this location.<span
style='color:red'><o:p></o:p></span></p>

<p class=Coutput><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase>XML has its own set of rules. We are not allowed to use the &lt;
sign in the /// tags. We have to use &amp;lt; instead. There are a large number
of ways to create ill formed XML and any badly formed XML will generate the
above error. Thus, even in the comments someone is checking what you are doing.<span
style='color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>/// &lt;param name='aa'&gt;Used to indicate status.&lt;/param&gt;<o:p></o:p></p>

<p class=Cprg>/// &lt;param name='aa'&gt;Used to indicate status.&lt;/param&gt;
<o:p></o:p></p>

<p class=Cprg>public static void Main (string [] aa) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,18): warning CS1571: XML comment on
'zzz.Main(string[])' has a duplicate param tag for 'aa'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Nobody likes being told to do
something twice. Even in a /// tag! The param denotes a parameter to a
function, so, we cannot have two parameters with the same name in a method.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>/// &lt;param name='aaa'&gt;Used to indicate
status.&lt;/param&gt;<o:p></o:p></p>

<p class=Cprg>public static void Main (string [] aa) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,18): warning CS1572: XML comment on
'zzz.Main(string[])' has a param tag for 'aaa', but there is no parameter by
that name<o:p></o:p></p>

<p class=Coutput>a.cs(4,20): warning CS1573: Parameter 'aa' has no matching
param tag in XML comment (but other parameters do)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The first warning is very clear.
Our function Main accepts a parameter called aa and in the XML tag we have
given the name as aaa. The second warning is that the function name has a
parameter called aa and we do not have a param tag it.<o:p></o:p></span></p>

<p class=Cprg><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>/// &lt;exception cref=&quot;System.Console.WriteLin&quot;&gt;An
exception class.&lt;/exception&gt;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=Cprg>class zzz : System.Exception <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,22): warning CS1574: XML comment on 'zzz' has cref
attribute 'System.Console.WriteLin' that could not be found<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler checks every move of
yours. The cref attribute needs a valid method name WriteLine is not spelt
right as the last e is missing, hence the error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>/// &lt;seealso cref=&quot;abc(i)&quot;/&gt;<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(int i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc(char i) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,20): warning CS1580: Invalid type for parameter '1' in
XML comment cref attribute<o:p></o:p></p>

<p class=Coutput>a.cs(1,20): warning CS1574: XML comment on 'zzz' has cref
attribute 'abc(i)' that could not be found<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The cref also takes a data type
for the parameters to a function, not the name of the parameter. Here, we could
specify a int or a char but not the name of the parameter i.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static explicit operator int(zzz f)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return 0; <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>/// &lt;seealso cref=&quot;zzz.explicit operator intt(zzz)&quot;/&gt;
<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(1,14): warning CS1591: Missing XML comment for publicly
visible type or member 'zzz'<o:p></o:p></p>

<p class=Coutput>a.cs(3,15): warning CS1591: Missing XML comment for publicly
visible type or member 'zzz.explicit operator int(zzz)'<o:p></o:p></p>

<p class=Coutput>a.cs(8,20): warning CS1581: Invalid return type in XML comment
cref attribute<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The name of the operator is int
and not intt. Be careful while typing the name.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>/// &lt;remarks&gt;<span style="mso-spacerun: yes"> 
</span>Called in &lt;see cref=&quot;zzz::Main&quot;/&gt;<span
style="mso-spacerun: yes">  </span>&lt;/remarks&gt;<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,40): warning CS1036: ( or . expected<o:p></o:p></p>

<p class=Coutput>a.cs(3,37): warning CS1584: XML comment on 'zzz.Main()' has
syntactically incorrect cref attribute 'zzz::Main'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The XML tag must have everything
prim and proper. The separator between the class name and function name is a .
and not a ::. Have to be careful what we do in front of a computer!<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>Csc /nologo a.cs /win32res:a.xml<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1583: 'C:\csharp\a.xml' is not a valid Win32 resource
file<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A res file has a certain file
format that is documented on the Microsoft web site. We gave a text file
instead. The compiler checks the validity of a res file before reading it.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>unsafe public static void Main() {<o:p></o:p></p>

<p class=Cprg>int *p = stackalloc int (30);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,25): error CS1575: A stackalloc expression requires []
after type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The stackalloc keyword is used to
allocate memory for us. It has the array syntax and not the function syntax.
The [] brackets are mandatory for this function and not the ().<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /nologo a.cs /R:a.ico<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS0009: Metadata file 'C:\csharp\a.ico' could not
be opened -- 'File is corrupt'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An .dll file has a predefined
file format called the PE or Portable Executable file format. A .ico file
format is very different from the PE format. We can not mix up file formats in
compiler options.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a2.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy : zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>csc a2.cs /r:a.exe<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a3.cs</u><o:p></o:p></p>

<p class=Cprg>class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>csc a3.cs /r:a2.exe gives the error<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a2.exe: error CS0011: Referenced class 'yyy' has base class or
interface 'zzz' defined in an assembly that is not referenced.<span
style="mso-spacerun: yes">  </span>You must add a reference to assembly 'a'.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We come across a slight
roadblock. The file a.exe contains a class zzz and a2.exe contains class yyy.
When we compile a3.cs with the /r: option alongwith a2.exe as it contains class
yyy, we get an error. A.exe should have also been stated as it contains the
code for zzz which yyy is derived from. Thus to remove the error we should
restate the command as<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a3.cs /r:a2.exe;a.exe<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy y;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,12): error CS0052: Inconsistent accessibility: field
type 'yyy' is less accessible than field 'zzz.y'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As a re-revision, we are not
allowed to use the class yyy in class zzz as a public variable because the
class is declared internal by default. The member y cannot be more accessible
than the class yyy that is internal. As<span style="mso-spacerun: yes"> 
</span>y is declared public, the error pops up. Change it to a less accessible
modifier like private or internal and the error simply vanishes. If the class
yyy is made public then none of the above problems would arise. You can easily
become less important than you really are but cannot aspire to greater heights.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;attrib +r a.exe<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>&gt;csc a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS0016: Could not write to output file 'a.exe' --
'Access is denied. '<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As the file a.exe is marked as
read only, when the compiler tries to write the new output file it came back
with the above operating system error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler command given as<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc<span style="mso-spacerun: yes">  </span>/out:a.exe
a.cs /incremental<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>creates a file called a.exe.incr
in the same sub-directory. This file contains information to speed up the
compilation process. So far we have been using only one or two files that carry
our code. In a real-life situation we will have over a thousand files. Each
time we run the compiler we do not need all the files to be recompiled but only
those functions that have changed since the last time we compiled. This speeds
up the entire process as most files will not be recompiled again. This
information on the new changes in a function must be stored at someplace. That
file is a .incr file. We will display the first line of this file.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>a.exe.incr</u><o:p></o:p></p>

<p class=Coutput>Incremental Build Data for C# Compiler -- this file stores
data to enable fast rebuilds.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;attrib +r a.exe.incr<o:p></o:p></p>

<p class=Coutput>&gt;csc<span style="mso-spacerun: yes">  </span>/out:a.exe
a.cs /incremental<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>Like before we made the file
cool.incr read only.<o:p></o:p></span></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>error CS0032: Could not open incremental build file
'C:\csharp\a.exe.incr' for writing<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc a.cs /debug<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This creates a file called a.pdb,
which is approx 12K large. This file contains debugging information. Whenever
programs do not work, a debugger is used to point out the exact location of the
error and the reasons behind it. A computer detectives first tool is debugger
and no self respecting computer professional travels without one always.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;attrib +r a.pdb<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>fatal error CS0042: Unexpected error creating debug
information file 'a.PDB' -- 'a.pdb: Access is denied.<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>&gt;csc /target:module /out:a.dll a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /target option builds a dll
file named a.dll and not an executable. A dll traditionally contains code and
cannot be executed at all.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc b.cs /R:a.dll<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Produces<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1509: Referenced file 'C:\csharp\a.dll' is not an
assembly; use '/addmodule' option instead<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The error goes away when the
command is written<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;Csc b.cs /addmodule:a.dll<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Any file specified in a dll has
to internally carry an assembly manifest. Using /addmodule, we want to add only
the metadata information for a.dll to the assembly of the current program. It
does not add the assembly of a.dll to the assembly of the current program.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /target:library a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Produces a.dll<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>Csc /addmodule:a.dll b.cs <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Produces the following error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS1542: 'C:\csharp\a.dll' cannot be added to this
assembly because it already is an assembly; use '/R' option instead<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Anything produced by /target can
only be used with a /reference and not by /addmodule.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have an extremely versatile
compiler with us. If we run as<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /target:exe a.cs /target:module b.cs<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>It will create only one file,
i.e. an exe file<o:p></o:p></span></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>&gt;csc /target:exe a.cs /target:exe b.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Produces<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>error CS2020: Only the first set of input files can build a
target other than 'module'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>The first /target can be either an exe or a winexe or a
library. The remaining files can only have only a /target:module. This is more
for a multi-output compilation.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap10.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:41:13 GMT -->
</html>
