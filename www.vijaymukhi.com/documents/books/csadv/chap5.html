<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:40:51 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="Chap5_files/filelist.html">
<link rel=Edit-Time-Data href="Chap5_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Delegates and Events - C# Nuts and Bolt - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T12:14:00Z</o:Created>
  <o:LastSaved>2001-09-27T12:15:00Z</o:LastSaved>
  <o:Pages>22</o:Pages>
  <o:Words>4556</o:Words>
  <o:Characters>25974</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>216</o:Lines>
  <o:Paragraphs>51</o:Paragraphs>
  <o:CharactersWithSpaces>31897</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:Garamond;
	panose-1:2 2 4 4 3 3 1 1 8 3;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:15.0pt;font-family:Garamond;
color:black'>Chapter 5</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:26.0pt;font-family:Garamond;
color:black'>Delegates and Events</span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A delegate is extremely important
for C# as it is one of the four entities that can be placed in a namespace.
This makes it shareable among classes. Delegates are fully object oriented as
they entirely enclose or encapsulate an object instance and a method. A
delegate defines a class and extends System.Delegate. It can call any function
as long as the methods signature matches the delegates. This makes delegates
ideal for anonymous invocation. The methods signature only includes the return
type and the parameter list. If two delegates have the same parameter and
return type, that is, they share the same signature, we consider them as
different delegates. This chapter will feature these issues using simple
programs. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>a is an object that looks like
aa. a.abc will call the abc function from this class. Earlier on, we specified
that new must be followed by the class. We stand corrected as usual here.
Likewise, we can also use a delegate name after new. A delegate is like a
property or an indexer. It is a first class member of a class. It looks like a
function, but has the keyword delegate in front of it along with the return
type of void.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When we use new to instantiate a
delegate, we pass it one parameter. This happens to be the name of a function,
namely, pqr1. This function is created in the same class, that is, aa, it takes
no parameters and returns a void. The keyword new obviously creates an object
that looks like a delegate as it was given a delegate as a datatype. d is now
an object that looks like pqr and stores the delegate object of pqr1. Then we
use the function invocation syntax and write d(). To our utter surprise, we
have actually executed the function pqr1 without writing pqr1(). <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The reasoning here is that d is a
delegate object for function pqr1 as we have passed it as a parameter at the
time of creation. Calling d calls function pqr1 instead. This is one level of
abstraction thus helping us write complicated code.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d(100);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(19,1): error CS1593: Delegate 'pqr' does not take '1'
arguments<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# does not let you do whatever
your heart desires. The delegate object d that looks like a pqr is now passed
one parameter, that is, 100. As d stands for the function pqr1 and pqr1 does
not accept an int as a parameter, an error is shown. This proves that C# does
strict type checking on the code.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 (int d)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(18,18): error CS0123: Method 'aa.pqr1(int)' does not
match delegate 'void aa.pqr()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In our infinite wisdom, we
thought that the above error will vanish if we added an int as a parameter to
our function pqr1. C# however tends to disagree and now gives us different
error message.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate int pqr(int ddd);<o:p></o:p></p>

<p class=Cprg>int pqr1 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 2;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int pqr2 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 10;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>pqr d;<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>int<span style="mso-spacerun: yes">  </span>d1 = d(42);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(d1); <o:p></o:p></p>

<p class=Cprg>d<span style="mso-spacerun: yes">  </span>= new pqr(pqr2);<o:p></o:p></p>

<p class=Cprg>int<span style="mso-spacerun: yes">  </span>d2 = d(42);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(d2); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>84<o:p></o:p></p>

<p class=Coutput>420<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To eliminate the error message,
we added an int parameter to the delegate pqr. This informs the C# compiler
that whoever calls the delegate pqr, will hand it one parameter. The delegate
now returns an int unlike the earlier code where we returned void. Then C#
checks whether the function name given at the time of creation of the delegate
accepts one parameter and returns an int. Finally, when we run the function
through the delegate, a last check is made to see that the right parameters are
given. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have also added a tweeze of
lime to our program. We have created one more delegate type but now it is with
another function name as its parameter. The code remains the same. We keep
executing the delegate as d(42), but the function to be called changes each
time. This offers us greater flexibility in writing dynamic code. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate int pqr();<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(18,18): error CS0123: Method 'aa.pqr1()' does not match
delegate 'int aa.pqr()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>C# is very fussy about a
delegate. The return value of the delegate in the definition says that it will
return an int but the function pqr1 returns a void instead.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate int pqr(int ddd);<o:p></o:p></p>

<p class=Cprg>int pqr1 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 2;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int pqr2 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 10;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void xyz( pqr a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int f = a(10);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(f); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>xyz(d);<o:p></o:p></p>

<p class=Cprg>d<span style="mso-spacerun: yes">  </span>= new pqr(pqr2);<o:p></o:p></p>

<p class=Cprg>xyz(d);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>20<o:p></o:p></p>

<p class=Coutput>100<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This function demonstrates a
simple fact that a delegate is like a class. We can give objects that look like
classes as parameters to functions. Int, long etc are classes in C#. A delegate
being a data type can be passed as a parameter to a function. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the first and second
invocation of function xyz we are passing the same delegate type of d. The
first time it stands for the function pqr and the second time function pqr2.
Using the object a, we are executing a different function each time. The code
of the function xyz remains the same. We are indirectly giving it a different
function each time. The code of function xyz does not know nor care about the
function it is calling. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Writing generic code like the
above, helps isolate the code implementation from its execution. More on these
abstract issues in a short while.<span style="mso-spacerun: yes">   </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate int pqr(int ddd);<o:p></o:p></p>

<p class=Cprg>int pqr1 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 2;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>int pqr2 (int dd)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return dd * 10;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void xyz( pqr a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>for ( int i = 1; i&lt;=3 ; i++)<o:p></o:p></p>

<p class=Cprg>System.Console.Write(a(i) + &quot; &quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>xyz(d);<o:p></o:p></p>

<p class=Cprg>d<span style="mso-spacerun: yes">  </span>= new pqr(pqr2);<o:p></o:p></p>

<p class=Cprg>xyz(d);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>2 4 6 10 20 30<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The above program takes the
abstract behavior of a delegate a step further. Nothing on earth stops you from
executing a delegate through a loop construct. What we are repeating over and
over again is that a delegate passed as a parameter to a function, does not
know the name of the function it is going to execute at the time of
compilation. It will only receive this information at the time of execution
i.e. at run time.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>pqr is a delegate as it defines a
class that extends System.Delegate.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa : pqr<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compilation Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(2,14): error CS0509: 'aa' : cannot inherit from sealed
class 'pqr'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A delegate internally is
represented by a class with the same name. In the above case, the class pqr is
implicitly sealed. A sealed class cannot be used in a derivation. A long time
ago we had explained to you that there were four classes you could not derive
from. If memory serves you well, one of them was System.Delegate and it is an
abstract class. All delegates derive from it automatically. We can access all
the members of System.Delegate in the normal way. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void<span style="mso-spacerun: yes">  </span>pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(d.ToString());<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Coutput>pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>System.Delegate is also derived
from Object and hence using the syntax learnt earlier of member access, we can
call the ToString function of d.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(pqr.ToString());<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,26): error CS0120: An object reference is required for
the nonstatic field, method, or property 'object.ToString()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>We cannot use the name of the
delegate pqr with function ToString as it is not static. d being an instance of
the class can be used and will give no errors.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Delegate types come in two sizes,
combinable and non-combinable. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>using System;<o:p></o:p></p>

<p class=Cprg>delegate void ddd(string s);<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void a1(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Console.WriteLine(s + &quot; a1&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void a2(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Console.WriteLine(s + &quot; a2&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd a, b, c, d;<o:p></o:p></p>

<p class=Cprg>a = new ddd(a1);<o:p></o:p></p>

<p class=Cprg>b = new ddd(a2);<o:p></o:p></p>

<p class=Cprg>c = a + b; <o:p></o:p></p>

<p class=Cprg>d = a - b; <o:p></o:p></p>

<p class=Cprg>a(&quot;A&quot;);<o:p></o:p></p>

<p class=Cprg>b(&quot;B&quot;);<o:p></o:p></p>

<p class=Cprg>c(&quot;C&quot;);<o:p></o:p></p>

<p class=Cprg>d(&quot;D&quot;);<o:p></o:p></p>

<p class=Cprg>d = c - a;<o:p></o:p></p>

<p class=Cprg>d(&quot;E&quot;);<o:p></o:p></p>

<p class=Cprg>d = c - b;<o:p></o:p></p>

<p class=Cprg>d(&quot;F&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>A a1<o:p></o:p></p>

<p class=Coutput>B a2<o:p></o:p></p>

<p class=Coutput>C a1<o:p></o:p></p>

<p class=Coutput>C a2<o:p></o:p></p>

<p class=Coutput>D a1<o:p></o:p></p>

<p class=Coutput>E a2<o:p></o:p></p>

<p class=Coutput>F a1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This example proves the
importance of delegates in C# and they can be made extremely complex if you so
choose to. Objects a, b, c and d are delegate type objects. Object a and b
represent functions a1 and a2 respectively. Thus a(&quot;A&quot;) and
b(&quot;B&quot;) call functions a1 and a2.<span style="mso-spacerun: yes"> 
</span>This is shown above. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Object c represents the summation
of objects a and b. Obviously we cannot add two delegate types as they are not
numbers. The only rational explanation possible is that we want both the delegates
to be executed. First, function a1 gets called and then a2. The object d is
initialized to a - b. This will eliminate functions contained in a2 from a1. As
we have no common function in a2, it makes no difference and function a1 is
called. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The next series of statements
explains the operations better. The object d is made equal to c-a. This will
subtract all the functions that delegate a represents from the object c. The
object c stands for functions a1 and a2, and as a represents function a1, function
a1 gets removed from d. Thus a2 is called. In the last case of c - b, had we
executed the object c, both functions a1 and a2 would get called. But as we are
subtracting b i.e. function a2, only a1 gets called. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You can call as many functions
you want through delegates.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate int pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>return 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr e<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr f = d + e;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Two delegates can be combined
provided the return type of each is not void. As our newly defined delegate,
pqr, returns an int, we get no errors. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate int pqr(out int i);<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int pqr1 (out int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>i = 10;<o:p></o:p></p>

<p class=Cprg>return 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr e<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr f = d + e;<o:p></o:p></p>

<p class=Cprg>int k;<o:p></o:p></p>

<p class=Cprg>f(out k);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Aha! A delegate function can
accept output parameters. Hence we see the output displayed as pqr1.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate int pqr(out int i);<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int pqr1 (out int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>i = 10;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1 &quot; + i); <o:p></o:p></p>

<p class=Cprg>return 0;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr e = null; <o:p></o:p></p>

<p class=Cprg>pqr f = d + e;<o:p></o:p></p>

<p class=Cprg>int k;<o:p></o:p></p>

<p class=Cprg>f(out k);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1 10<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The same program now works. The
only change made is we have initialized one of the delegates to null. Now the
rules of simple delegates come into play. The rules of multi-cast delegates are
more restrictive. This also proves the hypothesis that multi-cast delegates are
not part of the programming language as the compiler did not catch the error.
As the compiler ignored it, it means that it is not part and parcel of the
language definition. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>System.Delegate introduces a lot
of extra code in the delegate. It is this code that actually performs error
checks and if we break any rules it throws an error at run time. The next
version of System.Delegate and not C# may handle these errors gracefully.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Two different delegates can refer
to the same method and target object. The plus operator thus lets you combine
delegates and the subtraction operator lets you remove one delegate from
another. We do have to stop at two delegates only. When we execute a multi-cast
delegate, the effect is similar when invoking an ordered list of non-multicast
delegates. <o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>try<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>catch ( System.Exception e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;in main&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void pqr1()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>throw new System.Exception();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>in main<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the above program, d() calls
function pqr1. This function throws an exception. We could have caught the
exception using try catch in function abc itself but we chose not to do so.
Instead, we catch it in main where abc is called. The exception thrown in the
function called by the delegate moves up the ladder until it finally is caught.
If the catch clause is ignored, it generates a run time error as below.<o:p></o:p></span></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Ouput</u><o:p></o:p></p>

<p class=Coutput>Exception occurred: System.Exception: An exception of type
System.Exception was thrown.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at aa.pqr1()<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><u>a.cs </u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr(ref int i);<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void pqr1 (ref int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>i = i + 2;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1 &quot; + i); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d = new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr e = new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr f = d + e;<o:p></o:p></p>

<p class=Cprg>int k = 3;<o:p></o:p></p>

<p class=Cprg>f(ref k);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1 5<o:p></o:p></p>

<p class=Coutput>pqr1 7<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Earlier, we discussed about the
out parameters and concluded that they are not allowed in a multicast delegate.
Conversely, passing by ref is permissible in multi-cast delegate invocations.
If the called function changes k, the change is transmitted straight through.
Thus every invocation of pqr1 refers to the same variable k each time.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr1()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;);<o:p></o:p></p>

<p class=Cprg>throw new System.Exception();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr2()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr2&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d<span style="mso-spacerun: yes">  </span>= new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>pqr e<span style="mso-spacerun: yes">  </span>= new pqr(pqr2);<o:p></o:p></p>

<p class=Cprg>pqr f<span style="mso-spacerun: yes">  </span>= d+e;<o:p></o:p></p>

<p class=Cprg>f();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>Exception occurred: System.Exception: An exception of type
System.Exception was thrown.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at aa.pqr1()<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at pqr.Invoke()<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at aa.abc()<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If an exception is thrown during
a multi-delegate invocation, no more code gets called, processing simply halts.
Everything comes to a standstill. The function pqr1 gets called first. As it
throws an exception, C# does not call function pqr2, that it was supposed to
after finishing with function pqr1.<o:p></o:p></span></p>

<p class=Cprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa a = new aa();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public delegate void pqr();<o:p></o:p></p>

<p class=Cprg>public class aa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void pqr1 ()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr1&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>pqr d = new pqr(pqr1);<o:p></o:p></p>

<p class=Cprg>bb b = new bb();<o:p></o:p></p>

<p class=Cprg>pqr e = new pqr(b.xyz);<o:p></o:p></p>

<p class=Cprg>pqr f = d + e;<o:p></o:p></p>

<p class=Cprg>f();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class bb<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void xyz()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;xyz&quot;); <o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>pqr1<o:p></o:p></p>

<p class=Coutput>xyz<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A delegate is not confined to
executing code in its own class as its definition can be placed outside a
class. Here the delegate invocation list invokes two functions, one from the
same class pqr1 and the other function xyz from the class bb. Thus, the
delegate not only ignores the function it is calling but also the class from
which the function is called. It believes in equality thereby does not
differentiate code from one class to another.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>Events<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We start with a very simple
program. In function Main we create an object </span><span style='font-family:
"Trebuchet MS";color:windowtext'>l</span><span style='color:windowtext'> that
looks like class yyy. Then we simply call a function abc from it. In this case,
we are calling the function abc directly. There is no entity in between. Lets
see how we can call this function indirectly.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<span style="mso-spacerun: yes">  </span>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<span style="mso-spacerun: yes"> 
</span>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.a1();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void a1() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (c != null)<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are doing exactly the same
thing as we did earlier but now its with a lot more fanfare. We started out by
creating a delegate ddd. We then instantiated an object that looks like the delegate
ddd and passed it one parameter, the name of the function. In our specific case
it is abc. As abc resides in a class yyy and we are operating in function Main
within class zzz, we have no choice but to give the full name, </span><span
style='font-family:"Trebuchet MS";color:windowtext'>l</span><span
style='color:windowtext'>.abc. The object c on the left hand side is not a
delegate but an event. Also the syntax is += and not = as it would give us the
following error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,3): error CS0070: The event 'yyy.c' can only appear on
the left hand side of += or -= (except when used from within the type 'yyy')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The object c has an odd-looking
definition. Earlier we stored the return value of the instantiation of a
delegate in a delegate object, here we have added the keyword event to the
object. Now we call function a1 from Main. In a1, we are checking the value of
the object c before calling abc. If it is not null, then we call the function
abc, otherwise we don't.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If we comment out the line new
ddd, then the object c does not get initialized. It will retain its value of
null and the function abc will not be executed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.a1();<o:p></o:p></p>

<p class=Cprg>l.c -= new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.a1();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void a1() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>if (c != null)<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The first time we execute </span><span
style='font-family:"Trebuchet MS";color:windowtext'>l.</span><span
style='color:windowtext'>a1, the object c has a value, it is not null. On the
next line we have -= where we are subtracting the delegate ddd from the event
c. The delegate stands for the function abc in each case. On subtraction, this
common function is eliminated and the event object c now has a value null. Thus
we added the function abc in the first round and removed it in the second
round.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.c();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,3): error CS0070: The event 'yyy.c' can only appear on
the left hand side of += or -= (except when used from within the type 'yyy')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Unlike a delegate, an event
object cannot be used directly. Earlier, we used to execute a function through
the delegate object. That is not permitted with events. Events are employed for
notification purposes only.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>If you are still ignorant about
the use of an event, you are totally blameless. Whatever we have done so far
could have easily been done without events. In the above case, we have
associated an event c with a function abc in class yyy. We then execute
function pqr by giving c(). This executes the event object c. Earlier, a
similar thing was not possible as we were not in the same class. Now as the
event object c stands for a function abc, it calls that function. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The next program demonstrates
that we can call as many functions we want.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd(); <o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.xyz);<o:p></o:p></p>

<p class=Cprg>l.pqr();<o:p></o:p></p>

<p class=Cprg>l.c -= new ddd(l.xyz);<o:p></o:p></p>

<p class=Cprg>l.pqr();<o:p></o:p></p>

<p class=Cprg>l.c -= new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>l.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void xyz() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;xyz&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>xyz<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>Unhandled Exception: System.NullReferenceException: Value null
was found where an instance of an object was required.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>This example reminds us of
delegates. We are adding two functions to the event c. Thus the first time we
call pqr, we are only executing the event c. The next time we will call the abc
and pqr functions as they are now bound to the event. A += adds a function and
a -= subtracts/removes a function from the event list. Now when we call the
event c, only function abc will be called as xyz has been removed from the
list. Finally we are also removing abc from the list and the event will have a
value null. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we execute an event that
has no functions to notify, a run time exception is generated. Thus always
check if the event has some value and is not null before using it in your code.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new xxx();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(20,1): error CS0070: The event 'yyy.c' can only appear on
the left hand side of += or -= (except when used from within the type 'yyy')<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>An event is used to call a
function in the same class. Here even though xxx is derived from yyy, they do
not belong to the same class. Hence an event created in class yyy cannot be
used in any class other than yyy, even derived classes are exempted. Normally
C# allows derived classes to inherit the workings of the base class. Events are
one of the many exceptions and hence the error is generated at compile time,
not at run time.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy l = new yyy();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(l.abc);<o:p></o:p></p>

<p class=Cprg>xxx x = new xxx();<o:p></o:p></p>

<p class=Cprg>l.c += new ddd(x.xyz);<o:p></o:p></p>

<p class=Cprg>l.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class xxx <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void xyz() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;xyz&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>xyz<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The power of events spreads on
code across classes. We've used the same code as in the earlier porgram and
given the name of a function, xyz. This function does not belong to yyy but is
taken from xxx. The event call does not seem to bother and acts accordingly. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A similar example was shown with
delegates. The same holds true for events too.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd c;<o:p></o:p></p>

<p class=Cprg>//public ddd c;<o:p></o:p></p>

<p class=Cprg>public void add_c( ddd a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c += a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void remove_c( ddd a)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>c -= a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,13): error CS0111: Class 'zzz' already defines a member
called 'add_c' with the same parameter types<o:p></o:p></p>

<p class=Coutput>a.cs(9,13): error CS0111: Class 'zzz' already defines a member
called 'remove_c' with the same parameter types<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Each time we create an event
object, two functions are automatically created in our class. These two
functions are the name of the event preface by add_ and remove_. The compiler
adds the code for these function. This also means that we cannot have functions
with the same names in the class that has an event. It could also mean that the
event code overwrites the function code. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>What we mean is that in the early
days of C++, the compiler would first convert the C++ statements to C code
which, would then be executed by the C compiler. Maybe something similar is
taking place here too. Our book C# to IL<span style="mso-spacerun: yes"> 
</span>handles these issues in great depths.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The functions called by the event
are called event handlers and they provide notifications to our class. The
event like a delegate can be called with a million parameters also. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>delegate void ddd(); <o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd d = null;<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Unhandled Exception: System.NullReferenceException: Value null
was found where an instance of an object was required.<o:p></o:p></p>

<p class=Coutput><span style="mso-spacerun: yes">   </span>at zzz.Main()<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we try and execute a
delegate, the system does not perform a compile time check, but at run time it
checks for validity. As we have not yet initialized the delegate d, its value
is null. Hence, we get a NullReferenceException thrown back at us. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public delegate void eee();<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>ddd d = new ddd(a.abc);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>eee e = new eee(d);<o:p></o:p></p>

<p class=Cprg>e();<o:p></o:p></p>

<p class=Cprg>System.Type t = typeof(eee);<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(t.FullName);<o:p></o:p></p>

<p class=Cprg>if ( e is ddd)<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;true&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>zzz+eee<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A delegate constructor cannot be
only passed the name of a function as a parameter as we've done for delegate d,
but also the name of another delegate. Delegate e is an eee delegate but is
initialized to a ddd delegate, d. This simply makes a copy of the original
delegate. We now have two delegate objects that reference the same function,
abc. Internally eee has nothing to do with ddd. The type of eee does not change
due to the copy as<span style="mso-spacerun: yes">  </span>copy cannot change
the data type of a delegate.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>ddd d = new ddd(a.abc);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The function being passed to the
delegate is from the base class. This is allowed and we get no apparent error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd d = new ddd(base.abc);<o:p></o:p></p>

<p class=Cprg>d();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc zzz&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>abc yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can also use the keyword base
to call the function from the base class. If you remember, base calls code from
the base class and not from the derived class. This is in spite of what the
documentation says and we quote verbatim 'If the method group resulted from a
base-access, an error occurs'. There is no way known to man that can change the
method associated with a delegate once the delegate has been created. It
remains the same for the entire lifetime of the delegate. The parameter to a
delegate creation cannot be a constructor, indexer, property or obviously a
user define operator even though they carry code. We are left with only one
choice as a parameter, a method. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd d = new ddd(zzz);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,17): error CS0119: 'zzz' denotes a 'class' which is not
valid in the given context<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The error message should have
been far more clearly stating in a loud bold voice, 'Thou shall not give a
Constructor as a parameter to a delegate ' instead of a more generic one which
does not hit the nail on the head.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:Tahoma;color:windowtext'>The
Other Odds and Ends<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public event ddd d1{<o:p></o:p></p>

<p class=Cprg>add<span style="mso-spacerun: yes">  </span>{ <o:p></o:p></p>

<p class=Cprg>return null;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,18): error CS0065: 'zzz.d1' : event property must have
both add and remove accessors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we create an event
property, unlike a normal property, an event property must implement both the
add and the remove accessors.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class ddd<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd d1<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>add<span style="mso-spacerun: yes">  </span>{ return null;}<o:p></o:p></p>

<p class=Cprg>remove {}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(6,18): error CS0066: 'zzz.d1': event must be of a
delegate type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An event must be the data type of
a delegate and not of a user defined type. Here ddd must only be a delegate
otherwise error no CS0066 results. That is why we first explained a delegate
and then an event. Events follow delegates and thus the designers of C# first
created delegates and as an afterthought events.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>delegate void ddd();<o:p></o:p></p>

<p class=Cprg>interface iii {<o:p></o:p></p>

<p class=Cprg>event ddd d = new ddd();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(3,11): error CS0068: 'iii.d': event in interface cannot
have initializer<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>For an interface always follow a
simple rule. We cannot place any code in a interface, including initializing a
variable/object. Interfaces can only have definitions, no code please.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public interface iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>event ddd d1 {<o:p></o:p></p>

<p class=Cprg>remove {}<o:p></o:p></p>

<p class=Cprg>add {return null;}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,11): error CS0069: 'iii.d1': event in interface cannot
have add or remove accessors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In an interface, even a whiff of
code is not allowed. In an accessor we would obviously like to place a lot of
code. In an interface, an event or a property cannot have any accessor code and
hence the {} are bad syntax.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public interface iii <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>event ddd d1<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>remove { } <o:p></o:p></p>

<p class=Cprg>add { }<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,11): error CS0069: 'iii.d1': event in interface cannot
have add or remove accessors<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Even accessors are not allowed. A
property in an interface behaves a little differently and would not have given
an error in the above case.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Outside the class an event is
declared in, an event can only add or subtract a reference.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public event ddd e1;<o:p></o:p></p>

<p class=Cprg>public static void Main() {<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Compiler Warning</u><o:p></o:p></p>

<p class=Coutput>a.cs(4,18): warning CS0067: The event 'zzz.e1' is never used<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler considers an event
to be very important so if it is not being used in a program, but declared it
gives you a harmless warning. One more warning number used up. The error and
warning numbers run concurrently. They are no overlaps and share the same
numbers.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>interface iii {<o:p></o:p></p>

<p class=Cprg>event ddd e1;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>class zzz : iii<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>event ddd iii.e1() <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,14): error CS0071: An explicit interface implementation
of an event must use property syntax<o:p></o:p></p>

<p class=Coutput>a.cs(8,15): error CS1520: Class, struct, or interface method
must have a return type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we implement an event
that has been previously declared in an interface, we have to use the property
syntax of a get and set. A normal function syntax will not suffice. Events and
interface work in an odd way together.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>delegate void ddd (int i);<o:p></o:p></p>

<p class=Cprg>class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd d = new ddd(12);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(5,17): error CS0149: Method name expected<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A delegates only job is to call
another function. The name of the function is handed over to the delegate at
the time of creation of the delegate object. We are passing a number and not a
method name. When calling the function through the delegate only, we pass it an
int, as suggested.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public delegate void ddd();<o:p></o:p></p>

<p class=Cprg>class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>ddd d;<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.d.Invoke();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Compiler Error</u><o:p></o:p></p>

<p class=Coutput>a.cs(8,5): error CS1533: Invoke cannot be called directly on a
delegate<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>You cannot use the Invoke method to call a delegate
directly. The delegate can only be used in one standard way as shown earlier.
There is no other way out.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csadv/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:40:55 GMT -->
</html>
