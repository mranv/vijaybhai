<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/vbnet/chap2.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:58:59 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap2_files/filelist.html">
<link rel=Edit-Time-Data href="chap2_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Visual Basic.Net - The Basics - 2. Classes</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>vmukhi</o:Author>
  <o:LastAuthor>vmukhi</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>5</o:TotalTime>
  <o:Created>2002-02-16T19:40:00Z</o:Created>
  <o:LastSaved>2002-02-16T19:45:00Z</o:LastSaved>
  <o:Pages>14</o:Pages>
  <o:Words>4233</o:Words>
  <o:Characters>24133</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>201</o:Lines>
  <o:Paragraphs>48</o:Paragraphs>
  <o:CharactersWithSpaces>29637</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;
	mso-font-charset:0;
	mso-generic-font-family:script;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=101 height=75 id="_x0000_i1025" src=bpb.gif></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:24.0pt;font-family:"Monotype Corsiva";color:black'>2. Classes</span><span
style='font-size:24.0pt;font-family:"Monotype Corsiva"'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Visual Basic has never been
considered to be a clean programming language. This became a Gordian knot for
Microsoft and began brewing trouble. However, in spite of this setback,
amazingly, no other product has sold more copies than Visual Basic in the
history of the computing world. Thus, Microsoft has no choice but to retain the
heart and soul of Visual Basic, and simultaneously, embellish it with the
latest features available in language technology. This forms the genesis of
Visual Basic.Net. Visual Basic .Net is primarily an extension of the Visual
Basic programming language that is shipped with the Visual Basic product.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In Visual Basic.Net, which is
the improved version of Visual Basic, we can replace the word 'module' with the
word 'Class'. Together with this modification, one more change is required,
i.e. the word 'Shared' has to be added to the Sub Main.<span
style="mso-spacerun: yes">  </span>If the main subroutine is not amended to
'shared', the following error crops up:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>vbc : error BC30737: No accessible 'Main' method with an
appropriate signature was found in 'a'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;hi&quot;)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>hi<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, when we compile and run the
program, the code in Main gets called, displaying the word &quot;hi&quot;. A
class is an entity like a module, which carries code and variables.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>Shared sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example has a
subroutine called abc, with the word 'Shared' added to it. If the word 'Shared'
is omitted, the compiler generates the following error:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(3) : error BC30369: Cannot refer to an instance
member of a class from within a shared method or shared member initializer
without an explicit instance of the class.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Let us now delve upon what the
word 'Shared' signifies.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>pqr<o:p></o:p></p>

<p class=ILprg>zzz.pqr<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new()<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>shared sub pqr<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in pqr&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in new<o:p></o:p></p>

<p class=ILoutput>in abc<o:p></o:p></p>

<p class=ILoutput>in pqr<o:p></o:p></p>

<p class=ILoutput>in pqr<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above program has Main and
pqr subroutines marked as 'shared', whereas, the others remain unmarked.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In Sub Main, we first need to
create a variable named 'a' of type 'zzz'. Here, we are not actually creating
an object or variable 'a' of type zzz, but merely stating that the variable 'a'
looks like the class zzz. This is akin to creating variables of a certain type.
Also, we can safely presume that integer, string and long are all classes. The
difference is that the Visual Basic.Net compiler is aware of the fact that
these classes are data types.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>zzz is a user-defined datatype,
which the compiler is oblivious to. Hence, we need to create an actual instance
or occurrence of this datatype. By using the keyword 'new', an instance or an
object of type zzz is created. The line a = new zzz creates a new object zzz in
memory, and returns a handle that is stored in 'a'. To frame it differently,
'a' represents a fresh zzz object in memory.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>An object is an instance of a
class. Thus, the statement 'DIM i as integer' creates an object i, which is an
instance of class integer. For the basic in-built data types such as string,
boolean and integer, there is no need to explicitly mention 'new', which is
otherwise mandatory for the user-defined types.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In Visual Basic.Net, the keyword
'new' first allocates memory for all the class contents, and then, it checks
for a sub called 'New'. If the sub 'new' exists, it executes the code present
in it. In most other languages, the sub new() is equivalent to a constructor of
a class. After the subroutine ends, a zzz object is created and stored in 'a'.
The object 'a' can then be used to call the other members in the class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Initially, the abc procedure is
called and then, the sub pqr is called twice:<o:p></o:p></span></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>At the first instance, without the
use of the prefix 'a'.<o:p></o:p></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>At the second instance, using the
class prefix.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The word 'shared' implies that
the function can be called without creating an object. Since abc is not shared,
we have to create an instance of a zzz object, in order to access it. The pqr
sub is marked as 'shared'. Therefore, it does not require an instance of an
object to access it. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We normally preface a member
with the name of the class, which is the default, if not specified expressly.
The sub of main also is marked as 'shared'. Therefore, it does not require an
instance of the class zzz before it can be used.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Prior to venturing further into
the concept of Shared, let us anatomize the concept of a constructor.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(4) : error BC30455: Argument not specified for
parameter 'i' of 'Public Sub New(i As Integer)'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Earlier, the constructor did not
accept any parameters. Thus, we were able to call it without any parameters. In
the above program, we have a constructor that expects one parameter of type
integer. However, in the process of creating an instance of the object zzz, we
have not furnished any parameters to 'new'. This results in an error. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz(10)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in new 10<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have now redressed the above
error by passing a parameter to the 'new' statement. So, when the constructor
gets called, the value received in the parameter i is 10. This value is
displayed on the Console. A constructor can be equipped to accept as many parameters
as we wish to supply it.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz(10)<o:p></o:p></p>

<p class=ILprg>a.new(10)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(5) : error BC30282: Constructor call is valid only
as the first statement in an instance constructor.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Unlike a subroutine, a new
constructor cannot be called explicitly. An error is generated in the above
program, since we are attempting to call a constructor by itself. Thus, a
constructor gets called automatically only when the object is created, and not
otherwise. Further, it cannot be called manually.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a,b as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz(10)<o:p></o:p></p>

<p class=ILprg>b = new zzz()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>sub new()<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new &quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in new 10<o:p></o:p></p>

<p class=ILoutput>in new<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'>We can have innumerable
constructors or 'new' statements in the program, provided each is assigned
different parameters. The above program has two new subroutines, the first one
accepts a single integer parameter, while the second one does not take any
parameters. This program is perfectly valid.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The concept of using the same
function name with different parameters is called 'function overloading' or
'sub overloading'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, we present another example
on 'function overloading'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>abc()<o:p></o:p></p>

<p class=ILprg>abc(10)<o:p></o:p></p>

<p class=ILprg>abc(&quot;hi&quot;)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>shared sub abc(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>shared sub abc()<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc &quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>shared sub abc(k as string)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc {0}&quot;, k)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in abc <o:p></o:p></p>

<p class=ILoutput>in abc 10<o:p></o:p></p>

<p class=ILoutput>in abc hi<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, we have
three subs with the same name 'abc', but each of them has different parameters.
Out of the three, two subs have the same number of parameters, but their data
types are distinct.<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This is permitted, since the
name of a function in Visual Basic.Net does not consist of the name alone, but
is composed of the name and the data type of each parameter. Thus, the name of
the first sub abc that accepts an integer parameter, could be represented by
'abci', where i is the data type of the parameter. The last sub could be
represented by 'abcs', where s stands for the string type of the parameter.
This naming concept initiates uniqueness in the function names.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This concept is known as 'name
mangling', where the signature of the function depends upon both, the name of
the parameters and their datatypes.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, we present yet another
example on constructors to make the concept of constructors crystal clear. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a,b as zzz<o:p></o:p></p>

<p class=ILprg>b = new zzz()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0}&quot;, i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(4) : error BC30455: Argument not specified for
parameter 'i' of 'Public Sub New(i As Integer)'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Let us comprehend the concept of
constructors by examining the above two examples. The first example compiles
without any errors, despite containing no constructor code. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Visual Basic.Net is not
complaining for the reason that, when the program does not contain any
constructors, the complier introduces one of its own, as follows:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>Sub new<o:p></o:p></p>

<p class=ILprg>End sub<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, when a constructor is not
created explicitly, the compiler creates one for us. This constructor does not
accept any parameters, nor does it do anything. However, if we include even a
single constructor, this complimentary constructor is carted-off or taken away.
Thus, in any situation, there would always be at least one constructor present
in the code.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the second example, a
constructor with one parameter is present. Therefore, the free constructor with
no parameters, which would have otherwise been generated is not present. So,
creating an instance of the zzz object by calling the constructor that accepts
no parameters, generate an error.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To summarize, when no
constructors are present in the class, a constructor that does not accept any
parameters, is automatically generated. However, with the insertion of even a
single constructor, the free constructor is not created. In such a situation,
each and every new variant of the constructor has to be added manually.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>dim i as integer<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz<o:p></o:p></p>

<p class=ILprg>a.i = 10<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>a.pqr<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>Sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(i)<o:p></o:p></p>

<p class=ILprg>i = 20<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>Sub pqr<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(i)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>10<o:p></o:p></p>

<p class=ILoutput>20<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example contains an
instance variable i. It is referred to as an instance variable since unlike
'a', it is not created in a sub, but is created outside the subs and within the
class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The lifetime of an object such
as 'a' endures as long as the sub is active; once the sub concludes executing
its code, all the variables that have been declared in it, lose their values or
are considered non-existent thereafter. The visibility of such variables is
restricted to the function or sub that they are created in. Thus, the object
'a' is visible only within the sub Main and not in the other subs, such as abc.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On the other hand, the lifetime
of the variable i is linked to the life-span of the program. Since it is
declared outside all the subs, it is visible in all the subs within the class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In main, the value of i is set
to 10. It is prefaced with the name of the object, since it is not shared.
Then, the sub abc is summoned, which displays the value of 10 and changes it to
20.<span style="mso-spacerun: yes">  </span>Next, when the subroutine pqr is
called, the value of the instance variable is 20. This is for the reason that,
only a single copy of i is created in memory, when the zzz object is created.
Thus, both the subs, viz. abc and pqr refer to this same instance variable i.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>dim j as integer<o:p></o:p></p>

<p class=ILprg>shared dim k as integer<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a,b as zzz<o:p></o:p></p>

<p class=ILprg>a = new zzz(10)<o:p></o:p></p>

<p class=ILprg>a.abc(100)<o:p></o:p></p>

<p class=ILprg>b = new zzz(20)<o:p></o:p></p>

<p class=ILprg>b.abc(200)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0} {1} {2}&quot;, i , j ,
k)<o:p></o:p></p>

<p class=ILprg>j = i<o:p></o:p></p>

<p class=ILprg>k = i<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in new {0} {1} {2}&quot;, i , j ,
k)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>sub abc(p as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;in abc {0} {1}&quot;,<span
style="mso-spacerun: yes">  </span>j , k)<o:p></o:p></p>

<p class=ILprg>k = p<o:p></o:p></p>

<p class=ILprg>j = p<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>in new 10 0 0<o:p></o:p></p>

<p class=ILoutput>in new 10 10 10<o:p></o:p></p>

<p class=ILoutput>in abc 10 10<o:p></o:p></p>

<p class=ILoutput>in new 20 0 100<o:p></o:p></p>

<p class=ILoutput>in new 20 20 20<o:p></o:p></p>

<p class=ILoutput>in abc 20 20<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example reinforces the
dissimilarities between a shared variable and a non-shared variable. The words
'variable' and 'object' may be used interchangeably. In the manner akin, what
is pertinent to a sub is also applicable to a function, unless otherwise
specified. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above program, the class
zzz has two variables:<o:p></o:p></span></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>j - which is an instance variable.<o:p></o:p></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>k - which is a shared variable.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The basic distinction between
the two is as follows: <o:p></o:p></span></p>

<p class=ILbullets>(a) A shared variable belongs to a class, which implies that
each time a new instance of the class is created, the shared variable does not
get re-created. To access the shared variable, the name of the class is used,
since there is only a single shared variable per class.<o:p></o:p></p>

<p class=ILbullets><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbullets>(b) An instance variable gets created, each time that a new
instance of a class is created. Therefore, if an object is instantiated on 20
counts, it will result in the creation of 20 new copies of the instance
variable in memory.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In Main, two local variables a
and b, of type zzz are created. Since they are local, they have a very short
life span. While creating the object 'a', the constructor for the object zzz is
assigned a value of 10. Therefore, in the constructor, the value of i becomes
10, whereas, both j and k have a value of 0. If the instance variables are not
explicitly initialised, the system initialises them to a value of zero. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The constructor assigns the
value contained in i, i.e. 10, to both the variables j and k. Therefore, in the
second round, the WriteLine function displays the values of all three variables
as 10. The sub abc is then called with a parameter of 100. Here, the values of
variables j and k remain 10, as has been displayed by the WriteLine function.
We now re-initialize both the variables j and k to 100, and then, quit out of
the sub.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The next statement in the Main
function creates a new instance of zzz, wherein the constructor is assigned a
value of 20. The WriteLine function prints the values of i, j and k as 20, 0
and 100, respectively. The instance variable j has a value of 0, as it has been
freshly created. Shared variables are not affected by the 'new' keyword. Thus,
the variable k retains its original value of 100, which was set in the abc
function. The second WriteLine function in the constructor displays the newly
assigned value of j and k, i.e. 20.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The abc function is called once
again using the object b. The variable j now displays the value of 20, since
the constructor of the 'b' object in zzz had initialized it to 20. This
variable is then assigned a value of 200. However, the second copy of j, which
belongs to the object 'b', retains its value of 20, since it has nothing to do
with the variable j from the object 'a'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To summarize what we have been
harping on over and over, an instance variable belongs to an object, whereas, a
shared variable belongs to a class. This is indubitably evident from the manner
in which these variables are accessed. We are taking the trouble of explaining
all the above code and concepts, in order that you can discern even the most
diminutive of the Visual Basic .Net programs, generated by Visual Studio.Net.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The approach that we have
pursued is that we first explain the concepts using the Visual Basic.Net
compiler, and then we implement them in Visual Studio .Net.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><b><span style='color:windowtext'>Namespaces</span></b><span
style='color:windowtext'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example lucidly
establishes that a Visual Basic.Net program can contain innumerable classes, as
long as one of these classes contains the Sub of Main. The above program has
two classes named zzz and yyy. In the class zzz, 'a' is declared to be an
object of type yyy. After having created the object, the function abc is called
from it. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>You may wonder as to what is the
big deal here, since the program runs in a manner akin to any other program.
Although we accede to the fact that the program is no different from the
earlier ones, nonetheless, we would still like to forge ahead with it.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The class Console has a shared
function called WriteLine, which is used to display strings. So, nothing holds
us back from creating a class called Console, in the fashion similar to the one
used to create the class yyy. Then, in the class, we can create our own
function named WriteLine.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This is perfectly within the
realms of possibility, since we now know how to create a class and a function
within the class. However, there is bound to be some confusion because when the
user enters the statement 'Console.WriteLine', the framework would be in a
dilemma whether to call the function created by us or the one supplied by
Microsoft. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Microsoft seems to have already
foreseen this predicament, and therefore, to avert such name clashes from
occurring, the big guys or Visual Basic.Net ordains that every class should be
a part of a name or a namespace. The next example demonstrates the
implementation of namespaces.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb </u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as nnn.yyy<o:p></o:p></p>

<p class=ILprg>a = new nnn.yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Namespace nnn<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>End Namespace<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have effected a minor
amendment to the class yyy. A new word, i.e. Namespace has been introduced
above the class yyy, and the name assigned to it is 'nnn'. As a rule,
everything in Visual Basic.Net must terminate with the word End. Therefore, the
Namespace also ends with the words 'End Namespace'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>With the introduction of a
namespace, the name of the class is no longer just yyy, but is now 'nnn.yyy'.
The syntax for the class name now changes to the following:<span
style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>name of the namespace followed by a
dot, and finally, followed by the class name.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, whenever we need to refer
to the class yyy, the reference to be employed is nnn.yyy. If we omit the
namespace 'nnn' from the DIM statement, the following error is generated: <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(3) : error BC30002: Type 'yyy' is not defined.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as aaa.nnn.yyy<o:p></o:p></p>

<p class=ILprg>a = new aaa.nnn.yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Namespace aaa<o:p></o:p></p>

<p class=ILprg>Namespace nnn<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>End Namespace<o:p></o:p></p>

<p class=ILprg>End Namespace<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, two
namespaces have been added to the class yyy, viz. aaa and nnn. Thus, the name
of the class now becomes aaa.nnn.yyy. The namespace statement can be re-written
as 'Namespace aaa.nnn'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>aaa.nnn.yyy.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Namespace aaa.nnn<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>shared sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>End Namespace<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In this example, the abc
function is marked as 'shared'. Here, no object of type yyy has been created.
Thus, to call the abc function, the name of the class 'yyy.abc' is used. Now,
with the inclusion of the namespace tag above the class, the only way to call
this function is by using its full name, i.e. aaa.nnn.yyy.abc.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This syntax bears a resemblance
to the commonly used System.Console.WriteLine. Thus, a sub or a function has to
be read from right to left as follows:<o:p></o:p></span></p>

<p class=ILbullets>•<span style="mso-spacerun: yes">  </span>The rightmost
entity 'WriteLine' or 'abc' is the name of the method.<o:p></o:p></p>

<p class=ILbullets>•<span style="mso-spacerun: yes">  </span>The next entry on
the left, i.e. 'Console' or 'yyy' is the name of the class.<o:p></o:p></p>

<p class=ILbullets>•<span style="mso-spacerun: yes">  </span>The next entry on
the left, i.e. 'System' or 'nnn' is the name of the namespace entity.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'>The Console class belongs to the
System namespace. The WriteLine function is a shared function in this class. In
the case of methods that are not 'shared', the object name has to be expressly
specified to access the method.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Namespaces influence only the
class names and not the object names. By employing namespaces, both similar as
well as disparate classes can be placed under a single heading. Microsoft has
politely reserved the use of the 'System' namespace. Thus, no developer can
ever create a namespace by that name, thereby avoiding any clashes with
Microsoft's set of entities.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Classes sharing the same names
can be placed under different namespaces without any confusion. However, the
problem with using these namespaces is that they are extremely lengthy. The
next program provides a solution to this poser.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Imports aaa.nnn<o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Namespace aaa.nnn<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>End Namespace<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The program begins with the
newly introduced keyword of 'Imports', followed by the name of the namespace,
i.e. aaa.nnn. This statement does not introduce any new code, as its sole task
is to add the namespace aaa.nnn to every class, thereby circumventing errors. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>For instance, the Visual
Basic.Net compiler would have thrown an error on encountering the class yyy in
the DIM statement, since there is no class called yyy. However, on catching
sight of the 'import' keyword, it adds the namespace to the name of the class,
resulting in the name aaa.nnn.yyy. As there already exists a class by this
name, the Visual Basic.Net compiler does not protest. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In case the error still
persists, it takes the next set of Imports statement, and attempts to seek a
match. Only when all the Imports fail to find a match, a &quot;not found
class&quot; error is thrown. Effectively, the imports statement is like a short
form, which when introduced, eliminates the need for mentioning the namespace
on every occurrence of the class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Bear in mind that it is the
namespace, and not the name of the class, which is permitted after the Imports
keyword.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>a.pqr<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class xxx<o:p></o:p></p>

<p class=ILprg>sub pqr<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;xxx pqr&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(6) : error BC30456: 'pqr' is not a member of
'yyy'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example has three
classes, viz. xxx, yyy and zzz. The class xxx has the sub pqr, the class yyy
has the sub abc, while the class zzz has the sub Main. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In Main, an object 'a' is
created to be an instance of the class yyy. Thus, the sub abc can now be called
off it. However, calling the sub pqr using the object 'a' results in an error,
as the class yyy does not contain pqr. The class xxx contains the sub of pqr.
Thus, a class is a self-contained unit wherein, the entities belonging to one
class cannot be accessed by another class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>a.pqr<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class xxx<o:p></o:p></p>

<p class=ILprg>sub pqr<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;xxx pqr&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>yyy abc<o:p></o:p></p>

<p class=ILoutput>xxx pqr<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above program, we have
merely added the word 'Inherits' to the name of a class xxx, on the line below
the class yyy. With this new induction, all the entities present in the class
xxx, now belong to the class yyy too. Thus, all the code and instance variables
that are present in the class xxx, can now be used by the yyy object 'a'. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This is one of the most salient
concepts in the world of object oriented programming, wherein, a class such as
yyy can derive itself from a base class like xxx. And by virtue of this, it can
reuse code that is present in this base class. Programmers are very often
mentally fine-tuned to write code in this fashion.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The code is never to be written
from a scratch. Instead, it is derived from a class that already has code
present in it. By using 'inherits', the derived class simply inherits
everything from the base class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, insert the following two
lines on a single line as in. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'>to<o:p></o:p></span></p>

<p class=ILprg>Class yyy Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This action generates the
following error:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(9) : error BC30205: End of statement expected.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Even though Visual Basic.Net is
known to be an exceedingly flexible language, it still requires us to adhere to
certain rules. Thus, we have no choice but to place the word 'Inherits' on a
separate line. The indentation is for the sake of neatness, and for good luck
of course!<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class xxx<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new xxx&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>new xxx<o:p></o:p></p>

<p class=ILoutput>new yyy<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, the class
yyy derives from the base class xxx. Therefore, when an instance of class yyy
is created, two constructors are called, one from the class xxx, and the other
from the class yyy, in the prescribed sequence. This occurs because the class
yyy is also made up of the class xxx. Thus, while an instance of a yyy object
is being created, two objects are created in memory: a xxx object, followed by
a yyy object.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>During the creation of these two
objects in memory, the constructors of these classes get called. A constructor,
as you may recall, is called when an object is created. The constructor of the
base class, i.e. xxx is always called first, followed by the constructor of the
derived class yyy.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>mybase.New<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class xxx<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new xxx&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>new xxx<o:p></o:p></p>

<p class=ILoutput>new yyy<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Yet another line has been added
to the constructor of the class yyy, i.e. mybase.New. Despite our not having
created any variable or object called mybase, no error is generated. This is
because, every method or function or sub is provided with a free object called
mybase, which is a handle to the base class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>By specifying mybase.New, the
constructor of the base class gets called. No specific reason can be attributed
to this, but most code written in the Visual Basic.Net world, calls the
constructor of the base class in the above-mentioned manner. The mybase object
is used to access members of the base class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>dim i as integer<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>Me.i = 10<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy {0}&quot; , Me.i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>new yyy 10<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Obtaining a free ride in life
has never been too easy. In the Visual Basic.Net world, not only do we get a
free mybase object, but also acquire another object called Me. The Me object is
used to refer to itself, while the mybase object is used to refer to the base
class. In the above example, whether we write Me.i or i, it would mean the same
thing.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy(100)<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>dim i as integer = 10<o:p></o:p></p>

<p class=ILprg>sub new(i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy {0} {1}&quot; , Me.i , i)<o:p></o:p></p>

<p class=ILprg>Me.i = i<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy {0} {1}&quot; , Me.i , i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>new yyy 10 100<o:p></o:p></p>

<p class=ILoutput>new yyy 100 100<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The utility of the reserved word
Me is evident in the above example, where the class yyy has an instance
variable named i, and the parameter to the constructor is also named i.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the class zzz, 'a' is created
as an object to yyy, by assigning a value of 100 to the constructor. Doing so
would load the yyy object in memory, where the first line is a DIM statement.
The DIM statement utilizes an 'equal to' sign to initialize the variable during
its creation. Thus, the instance variable i is initialized to the value of 10.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thereafter, the constructor of
class yyy is called, where the WriteLine function displays the value of i. The
i being referred to here is the parameter i in the constructor, and not the
instance variable i. This is because the parameters and local variables get
higher preference in a function.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>However, using Me.i in the
constructor would refer to the instance variable and not to the parameter. The
statement Me.i = i, would initialize the instance variable i to the value
stored in the parameter i. In the sub abc, i and Me.i will always refer to the
instance variable, since there is no parameter named i. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, the keyword Me proves to
be of great utility, when there is an instance variable and a local variable,
both having the same name.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main<o:p></o:p></p>

<p class=ILprg>dim a as yyy<o:p></o:p></p>

<p class=ILprg>a = new yyy<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>Class yyy <o:p></o:p></p>

<p class=ILprg>Inherits<span style="mso-spacerun: yes">  </span>xxx<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>mybase.New<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new yyy&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class xxx<o:p></o:p></p>

<p class=ILprg>Inherits ppp<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new xxx&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>Class ppp<o:p></o:p></p>

<p class=ILprg>sub new<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;new ppp&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>new ppp<o:p></o:p></p>

<p class=ILoutput>new xxx<o:p></o:p></p>

<p class=ILoutput>new yyy<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above program, the class
ppp is a self-contained unit, which is not derived from any other class. Then,
the class xxx is derived from class ppp. Hold your horses! There is more to it.
One more class yyy is then derived from the class xxx. As a result, the class
yyy is directly/indirectly derived from the two classes xxx and ppp. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, creating an instance of
class yyy, would lead to the creation of three objects in memory, viz. xxx, yyy
and ppp. The sequence is important, since the base class constructor always
gets called first. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, the ppp constructor gets
called first, the xxx class gets called next, and finally, it is the yyy class
that gets called. The abovementioned rules apply, irrespective of the number of
classes that we derive from.<o:p></o:p></span></p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/vbnet/chap2.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:59:00 GMT -->
</html>
