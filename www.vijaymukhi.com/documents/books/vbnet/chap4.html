<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/vbnet/chap4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:59:08 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap4_files/filelist.html">
<link rel=Edit-Time-Data href="chap4_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Visual Basic.Net - The Basics - 4. Access Modifiers</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>vmukhi</o:Author>
  <o:LastAuthor>vmukhi</o:LastAuthor>
  <o:Revision>4</o:Revision>
  <o:TotalTime>4</o:TotalTime>
  <o:Created>2002-02-16T20:01:00Z</o:Created>
  <o:LastSaved>2002-02-16T20:05:00Z</o:LastSaved>
  <o:Pages>11</o:Pages>
  <o:Words>3708</o:Words>
  <o:Characters>21136</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>176</o:Lines>
  <o:Paragraphs>42</o:Paragraphs>
  <o:CharactersWithSpaces>25956</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;
	mso-font-charset:0;
	mso-generic-font-family:script;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=101 height=75 id="_x0000_i1025" src=bpb.gif></p>

<p class=MsoNormal><span style='font-size:24.0pt;font-family:"Monotype Corsiva";
color:black'>4. Access Modifiers</span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Wherever we may venture these
days, there is an exorbitance of security. Barely a few are allowed access to
the resources that are considered vital. Programming languages like VB also
implement similar curbs. Access is denied to code that is crucial, in order to
evade transgression.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as yyy = new yyy<o:p></o:p></p>

<p class=ILprg>a.i = 10<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>dim i as integer<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(4) : error BC30390: 'yyy.i' is not accessible in
this context because it is 'Private'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In this example, we have a class
yyy with an instance variable i of type integer. In the sub Main within zzz, an
instance variable 'a' of type yyy is declared and instantiated simultaneously.
This act saves us one line of code.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On the next line, we attempt to
initialize the instance variable i to a value of 10. On doing so, we get an
error message informing us about the non-accessibility of the variable, since
it is 'private'. This error does not occur when we initialize the variable 'a'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In VB, every entity that is
created, is marked 'private' by default. Thus, in class yyy, the integer
variable i is private, and therefore, completely inaccessible. However, the
same rules do not apply to members of the same class. So, if there had been
more members of class yyy, they could have accessed the integer i with ease. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This privilege is granted
exclusively to the members of the class. It is not even extended to the derived
classes or the objects of the class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On adding the modifier 'public'
to the variable, as in &quot;Public dim i as integer&quot;, the error vanishes.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class xxx<o:p></o:p></p>

<p class=ILprg>Inherits yyy<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>i = 10<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>protected dim i as integer<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The modifier of 'public' allows
access to all and sundry, whereas, the modifier of 'protected' allows only the
derived classes to access the variables. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The class yyy has a 'protected'
variable i of type integer. The class xxx derives from the class yyy, since it
has the clause of 'inherits' added to it. Due to this, it inherits all the
members contained in the class yyy. If we now initialize the variable, no
errors are generated. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This is because the variable is
marked as 'protected', in the absence of which, the same error as depicted
above, would have been displayed. Also, creating an instance of the class xxx,
does not allow access to the protected variables. The keyword DIM is optional,
when used in consonance with access modifiers.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>b.vb</u><o:p></o:p></p>

<p class=ILprg>public class yyy<o:p></o:p></p>

<p class=ILprg>friend i as integer<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>i = 100<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We start by compiling the above
program b.vb, to create a dll using the following command:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>&gt;vbc /target:library b.vb<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The file b.dll contains a sub
abc, which initializes the instance variable i to 100. Note that the instance
variable is declared as a 'friend'. The program a.vb given below, refers to
this 'friend' variable and amends its value to 10.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as yyy = new yyy<o:p></o:p></p>

<p class=ILprg>a.i = 10<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>&gt;vbc a.vb /r:b.dll<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On compiling, the following
error is reported:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>C:\il\a.vb(4) : error BC30390: 'yyy.i' is not accessible in
this context because it is 'Private'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The 'friend' access modifier
signifies that none other than the entities in the same dll or assembly can
access its variables. Since the instance variable i is being accessed from
another assembly named 'a', an access violation is reported. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The basic rule is being reiterated
wherein, the same class is allowed total access to any member. This behavior is
at one extreme of the security spectrum. At the other extreme lies the 'public'
modifier where no rules are applicable.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The 'protected' modifier rests
in the middle wherein, just as in the case of 'private', the derived classes
are permitted access to the 'protected' members in the class. Members with the
'friend' modifier, are accessible from the same assembly that contains their
declaration.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as yyy = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc(100)<o:p></o:p></p>

<p class=ILprg>a.abc(&quot;hi&quot;)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>Overloads sub abc( i as integer)<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc {0} &quot; , i)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>Overloads sub abc( s as string)<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc {0} &quot; , s)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>yyy abc 100<o:p></o:p></p>

<p class=ILoutput>yyy abc hi<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This program certainly is no
path-breaker. The class yyy has two subs with the same name of 'abc', but with
different parameter types. Moreover, a new keyword of 'Overloads' has been
incorporated within the function. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The main function in the class
zzz first creates an instance variable 'a' of type yyy. Thereafter, it calls
the function abc twice, but each time, it uses distinct parameters.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The keyword 'Overloads' apprizes
VB of the fact that the class contains more than one sub with the same name.
This keyword is optional. So, when it is removed, everything would continue to
work as before. However, if we obliterate one of the 'overloads' from any of
the abc functions, the following error would be generated:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Error</u><o:p></o:p></p>

<p class=ILprg>c:\il\a.vb(12) : error BC31409: sub 'abc' must be declared
'Overloads' because another 'abc' is declared 'Overloads'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The rule is very
straightforward: Either use the keyword 'Overloads' in all subs having the same
name, or simply steer clear of it!<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as xxx = new yyy<o:p></o:p></p>

<p class=ILprg>dim b as yyy = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>b.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>Inherits xxx<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>class xxx<o:p></o:p></p>

<p class=ILprg>sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;xxx abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Warning</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(11) : warning BC40004: sub 'abc' conflicts with
sub 'abc' in the base class 'xxx' and so should be declared 'Shadows'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>xxx abc<o:p></o:p></p>

<p class=ILoutput>yyy abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above example does not
generate any errors, however it displays a warning. A warning is a very benign
complaint. Hence, it allows the compiler to create an executable file. However,
it is in our own interest that we pay heed to these warnings, because if we
snub them now, there is a strong probability of facing embarrassment at a later
stage.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The class xxx is the base class
with one sub abc. The class yyy derives from the class xxx, and it also has one
sub called abc. The warning is generated because the subs have the same name in
both, the base class and the derived class. The compiler expects the sub in the
derived class to be assigned a distinct or a new name. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On adding the keyword 'Shadows'
to the sub abc, as in 'Shadows sub abc' in the class yyy, the warning
disappears. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In one of the earlier chapters,
we had learnt that a derived class can replace a base class. Accordingly, we
create an object 'a' of type xxx, and initialize it to a derived class object
xxx. Then, the sub abc is called off it.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The output shows that the sub
abc from class xxx gets called, even though the object has been initialized to
a yyy object. This is because the data type of the object calling the sub, is
accorded preference over the others. Also, due to the 'shadows' keyword, the
compiler refers to the subroutine abc in the yyy, in a very different manner.<span
style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The second object 'b' of type
yyy calls the sub abc from yyy, since there is no name-clashing in this
respect, and a sub called abc exists in class yyy. If the compile time data
type specified in the DIM statement and the run time data type stipulated in
the 'new' are identical, it does not create any problems. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The object is created as per the
run time data type specified, when the 'new' statement is executed. However, we
have the option of calling the subs either from the base type or from the
derived type. In this example, the abc subroutine is called from the base type.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the next round, we would like
to call the sub off the run time data type, i.e. yyy, rather than off the
compile time data type, which is the default.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as xxx = new yyy<o:p></o:p></p>

<p class=ILprg>dim b as yyy = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>b.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>Inherits xxx<o:p></o:p></p>

<p class=ILprg>Overrides sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>class xxx<o:p></o:p></p>

<p class=ILprg>Overridable sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;xxx abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>yyy abc<o:p></o:p></p>

<p class=ILoutput>yyy abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above output confirms that
the sub abc called off the object 'a', is from the derived class yyy. Thus, the
code has been called from the derived class and not from the base class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This has been achieved by adding
two keywords of 'Overrideable' and &quot;Overrides'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We first aspire that the abc in
the base class xxx should allow the derived classes to override it. To
implement this, the sub abc in class xxx must contain the keyword
'Overridable'. This keyword informs the compiler that the sub abc allows
derived classes to override it.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This is not all! The derived
class must also state expressly that it wants to override the abc sub in the
base class. For this very reason, the Overrides keyword has been employed.
Thus, the object 'a' now calls the sub abc from yyy, which is the run time
type.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The presence of both the
keywords 'Overridable' and 'Overrides', is absolutely imperative. If the
'Overrides' keyword is omitted in the derived class, the default keyword of
'shadows' will be pressed into action. As a consequence, the compile time data
type would then take precedence. Thus, the sub abc will be called from the
class xxx. However, if we specify the 'Overrides' keyword in the derived class
and omit the 'Overridable' keyword from the base class, it will result in the
following error:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(11) : error BC31086: 'abc' overrides a sub in the
base class 'xxx' that is not declared 'Overridable'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This error signifies that the
base class must authorize the derived classes to override its members. The
derived class would then be free to decide whether it wants to override it or
not. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On certain occasions, there
exists specific code that must not be overridden under any circumstances. Under
such situations, the base class can simply ignore the 'Overridable' keyword,
thus eschewing such a eventuality altogether. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>One more combination that is not
permissible with the sub abc in class yyy is 'Overrides Shadows sub abc'.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The error message generated is
self-explanatory: <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(11) : error BC31408: 'Overrides' and 'Shadows'
cannot be combined.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The keyword 'Shadows' conceals
the derived class sub name from the base class, whereas, the 'overrides' does
just the reverse! The 'Overrides' keyword ensures that it is the sub from the
derived class that gets called, and not the one from the base class. Thus,
these two keywords are totally incompatible with each other.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as xxx = new yyy<o:p></o:p></p>

<p class=ILprg>a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>Inherits xxx<o:p></o:p></p>

<p class=ILprg>OverLoads Overrides sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>MyBase.abc<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>class xxx<o:p></o:p></p>

<p class=ILprg>overridable sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;xxx abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>yyy abc<o:p></o:p></p>

<p class=ILoutput>xxx abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have a single object 'a' of
type xxx, which is initialized to a yyy type. Now, when the abc subroutine is
called, it gets called from the class yyy, and not from the base class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Nevertheless, at times, we would
want to explicitly call the base class, instead of the derived class. To do so,
the 'MyBase' keyword is used in the derived class containing the sub. The
'OverLoads' keyword is optional. So, even when there is no recurrence of the
abc subroutine, it brews no trouble.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as xxx = new yyy<o:p></o:p></p>

<p class=ILprg>'a.abc<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>Inherits xxx<o:p></o:p></p>

<p class=ILprg>OverLoads Overrides sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;yyy abc&quot;)<o:p></o:p></p>

<p class=ILprg>MyBase.abc<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILprg>class xxx<o:p></o:p></p>

<p class=ILprg>protected overridable sub abc<o:p></o:p></p>

<p class=ILprg>System.Console.Writeline(&quot;xxx abc&quot;)<o:p></o:p></p>

<p class=ILprg>end sub<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(9) : error BC30266: 'Public Overrides Overloads
Sub abc()' cannot override 'Protected Overridable Sub abc()' because they have
different access levels.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>One minor rule related to
overriding is that, the access modifiers to the functions must remain the same.
In the above example, the sub abc contains the access modifier of 'protected',
which is not present in the derived class, and thereby yields the error. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, the access modifiers to
the function or to the sub, must be the same or else, an error gets generated.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as zzz<o:p></o:p></p>

<p class=ILprg>if a is nothing then<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;First&quot;)<o:p></o:p></p>

<p class=ILprg>end if<o:p></o:p></p>

<p class=ILprg>a = new zzz<o:p></o:p></p>

<p class=ILprg>if a is nothing then<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;Second&quot;)<o:p></o:p></p>

<p class=ILprg>end if<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>First<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In this chapter, the above
program commenced by declaring a zzz object named 'a'. The object is yet to be
initialized, and upto this point, it is devoid of any value.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This can be substantiated by
using the 'is nothing' clause in an 'if' statement. The 'is' operator
ascertains whether the object on the left has the value of the entity specified
on the right or not. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The word 'nothing' is a keyword,
which represents an uninitialized value. Accordingly, the first 'if' statement
returns a true, while the second 'if' statement returns a false, as the object
'a' has now been initialized. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>dim a as integer<o:p></o:p></p>

<p class=ILprg>if a is nothing then<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;First&quot;)<o:p></o:p></p>

<p class=ILprg>end if<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>c:\il\a.vb(4) : error BC30020: 'Is' requires operands that
have reference types, but this operand has the value type 'Integer'.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We start by declaring 'a' as an
integer, and then, deploy the same 'is' operator on it. An error gets reported
because the 'is' operator works only on reference types, and not on value
types.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>There are two basic types in VB:<o:p></o:p></span></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The value types or the inbuilt types
that we encountered earlier, where only the DIM keyword is sufficient to create
variables, without the need of any instance or of 'new'.<o:p></o:p></p>

<p class=ILbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The reference types that include the
user-defined ones, and the other types that do not fall within the purview of
value types.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>&lt;aaa&gt;Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILprg>class aaa<o:p></o:p></p>

<p class=ILprg>Inherits System.Attribute<o:p></o:p></p>

<p class=ILprg>end class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Any entity placed within angle
brackets, is called an 'attribute'. Thus, aaa is an attribute, which is placed
over the class zzz. An attribute signifies a class that has been derived from
the class Attribute, in the System namespace. An attribute has scores of
applications, which we shall delve upon later.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.vb</u><o:p></o:p></p>

<p class=ILprg>' Honey I am home<o:p></o:p></p>

<p class=ILprg>Public Class zzz<o:p></o:p></p>

<p class=ILprg>Shared Sub Main()<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>No errors are generated in spite
of the 'inserted' statement being present on the first line. This is because a
single inverted comma indicates a comment line, which is completely ignored by
the compiler. Programmers insert comments in order to explicate code.<span
style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Also from the comment sign upto
the end of the line, the statement gets ignored by the compiler.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Every programmer is generally
under the delusion that someday, someone would read his/her code and judge
him/her to be the smartest programmer to walk the terra-firma! The explanations
placed within comments serve as a lode star, when the existing program has to
be enhanced or modified, however, this appears to be a real daunting task!<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We commenced this book with a
simple Visual Basic project, where the last task that we undertook, was to
display a button on our screen. Then, we took a diversion to explore the
language. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This was absolutely imperative
since Visual Studio.Net generated a million lines of code during the creation
the form window and the button. It would have been an uphill task to try and
decipher the code in the first chapter itself, since we were very naive about
the language and its working at that time.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now that we are comfortable and
at home with the concepts of the language, let us endeavour to discern this
code, and also to embellish it with some of our code. Start the Visual
Studio.Net program. The screen that will appear, is evident in screen 4.1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=400 height=300 id="_x0000_i1027"
  src="chap4/1.gif"><o:p></o:p></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 4.1<o:p></o:p></p>
  </td>
 </tr>
</table>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Our Start page lists only one
project, i.e. the one that we recently toiled on. Your screen could have a list
of many such projects.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Click on the project called vvv
to arrive at the screen painter, as shown in screen 4.2. Now, double click on
the button.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=400 height=300 id="_x0000_i1028"
  src="chap4/2.gif"><o:p></o:p></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 4.2<o:p></o:p></p>
  </td>
 </tr>
</table>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Doing so, would open up a new
window called the code painter and the cursor would get positioned at the
following function: <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>Private Sub Button1_Click(ByVal sender As System.Object, ByVal e
As System.EventArgs) Handles Button1.Click<o:p></o:p></p>

<p class=ILprg>MessageBox.Show(&quot;Hi&quot;)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We shall be explaining this
function shortly, but prior to that, we want you to append the line
MessageBox.Show with &quot;Hi&quot;, as the string parameter to it. Now, press
the F5 key, which is a short cut for compiling and running the program. Along
the way, we shall introduce you to a number of these short cuts, which shall
step up your pace of working with Visual Studio. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>On clicking the button, a
message box appears, which is similar to what we had encountered in the Events
section. Now, close the application and revert back to Visual Studio. The code
that is displayed in the window, is shown in the screen 4.3.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=400 height=300 id="_x0000_i1029"
  src="chap4/3.gif"><o:p></o:p></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 4.3<o:p></o:p></p>
  </td>
 </tr>
</table>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Select the entire code and paste
it into an editor, such as Notepad. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>You may also click on the 'plus'
sign and view the actual code generated by the framework. We have reproduced
the code below, after stripping away the superfluous portions.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.vb</u><o:p></o:p></p>

<p class=ILprg>Public Class Form1<o:p></o:p></p>

<p class=ILprg>Inherits System.Windows.Forms.Form<o:p></o:p></p>

<p class=ILprg>#Region &quot; Windows Form Designer generated code &quot;<o:p></o:p></p>

<p class=ILprg>Public Sub New()<o:p></o:p></p>

<p class=ILprg>MyBase.New()<o:p></o:p></p>

<p class=ILprg>'This call is required by the Windows Form Designer.<o:p></o:p></p>

<p class=ILprg>InitializeComponent()<o:p></o:p></p>

<p class=ILprg>'Add any initialization after the InitializeComponent() call<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>'Form overrides dispose to clean up the component list.<o:p></o:p></p>

<p class=ILprg>Protected Overloads Overrides Sub Dispose(ByVal disposing As
Boolean)<o:p></o:p></p>

<p class=ILprg>If disposing Then<o:p></o:p></p>

<p class=ILprg>If Not (components Is Nothing) Then<o:p></o:p></p>

<p class=ILprg>components.Dispose()<o:p></o:p></p>

<p class=ILprg>End If<o:p></o:p></p>

<p class=ILprg>End If<o:p></o:p></p>

<p class=ILprg>MyBase.Dispose(disposing)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>Friend WithEvents Button1 As System.Windows.Forms.Button<o:p></o:p></p>

<p class=ILprg>'Required by the Windows Form Designer<o:p></o:p></p>

<p class=ILprg>Private components As System.ComponentModel.IContainer<o:p></o:p></p>

<p class=ILprg>'NOTE: The following procedure is required by the Windows Form
Designer<o:p></o:p></p>

<p class=ILprg>'It can be modified using the Windows Form Designer.<span
style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>'Do not modify it using the code editor.<o:p></o:p></p>

<p class=ILprg>&lt;System.Diagnostics.DebuggerStepThrough()&gt; Private Sub
InitializeComponent()<o:p></o:p></p>

<p class=ILprg>Me.Button1 = New System.Windows.Forms.Button()<o:p></o:p></p>

<p class=ILprg>Me.SuspendLayout()<o:p></o:p></p>

<p class=ILprg>'<o:p></o:p></p>

<p class=ILprg>'Button1<o:p></o:p></p>

<p class=ILprg>'<o:p></o:p></p>

<p class=ILprg>Me.Button1.Location = New System.Drawing.Point(88, 96)<o:p></o:p></p>

<p class=ILprg>Me.Button1.Name = &quot;Button1&quot;<o:p></o:p></p>

<p class=ILprg>Me.Button1.TabIndex = 0<o:p></o:p></p>

<p class=ILprg>Me.Button1.Text = &quot;Button1&quot;<o:p></o:p></p>

<p class=ILprg>'<o:p></o:p></p>

<p class=ILprg>'Form1<o:p></o:p></p>

<p class=ILprg>'<o:p></o:p></p>

<p class=ILprg>Me.AutoScaleBaseSize = New System.Drawing.Size(5, 13)<o:p></o:p></p>

<p class=ILprg>Me.ClientSize = New System.Drawing.Size(292, 273)<o:p></o:p></p>

<p class=ILprg>Me.Controls.AddRange(New System.Windows.Forms.Control()
{Me.Button1})<o:p></o:p></p>

<p class=ILprg>Me.Name = &quot;Form1&quot;<o:p></o:p></p>

<p class=ILprg>Me.Text = &quot;Form1&quot;<o:p></o:p></p>

<p class=ILprg>Me.ResumeLayout(False)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>#End Region<o:p></o:p></p>

<p class=ILprg>Private Sub Button1_Click(ByVal sender As System.Object, ByVal e
As System.EventArgs) Handles Button1.Click<o:p></o:p></p>

<p class=ILprg>MessageBox.Show(&quot;Hi&quot;)<o:p></o:p></p>

<p class=ILprg>End Sub<o:p></o:p></p>

<p class=ILprg>End Class<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The code produced here is
without the redundant blank lines. We believe that unless we have deciphered
the code generated by the framework, we would never be at ease with the
product. Besides, without a thorough understanding, it becomes exceedingly arduous
to augment the existing code.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The code begins with a class
called Form1, which is derived from the class Form. Since the 'imports'
statement is absent, the Form class is prefaced with the namespace.<span
style="mso-spacerun: yes">  </span>Any line beginning with the # character is
called a 'directive'. Thus, #Region is a directive, which as usual, ends with
End Region. Clicking on the plus sign with # Region for Windows Form Designer
in Form1, would result into a display of the code generated by the framework.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, whenever the Region directive
is encountered, all the code following it upto the 'End Region' directive, is
concealed. Furthermore, any string placed after the Region directive within the
code, is displayed as help. This feature facilitates segregation of code of
certain types. Thus, by placing the Region directive in a class, it becomes
much more convenient to expand and contract the code of a class. Also, it
enables the code painter to display a larger number of program lines, since
there is not much space available on the screen. In this case, the Region
directive encapsulates all the code generated by Visual Studio.Net.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>There is no Sub named Main
visible anywhere in this generated code. However, its existence is taken for
granted.<span style="mso-spacerun: yes">  </span>The constructor or the sub
'new', is the first one to be executed. The code embodied in it first calls the
original constructor from the Form class, which is optional. Then, it proceeds
to call the function InitializeComponent. Let us now press on with this
function. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The Sub InitializeComponent is private,
and it is tagged with an attribute of DebuggerStepThrough from the namespace
System.Diagnostics. At this stage, this attribute does not assume much
significance, and even if we delete it, heaven will not fall upon our heads!<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thereafter, a new instance of a
Button object called Button1 is created. Button1 now becomes an instance
variable, defined with the 'friend' access modifier and the 'WithEvents'
keyword, which allows the object to handle events. The software developer who
wrote this program to generate the VB code, was over-cautious and thus, tagged
everything with the word 'Me'; however, this can be safely ignored. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>A large number of controls can
be added to the form, but with the addition of every control, the form has to
be redrawn. This makes the User Interface extremely clumsy and unwieldy. So, in
order to suspend the process of laying out the Controls on the form, the Form
designer is requested to suspend drawing, till all controls have been rested in
place. They can all be designed in one single stroke. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The function SuspendLayout
ensures that the Layout process is suspended for the moment. Once the code for
all controls has been entered, the function ResumeLayout is executed, thus
signaling the Form to display all the controls.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The Code Writer writes the code
in a very systematic manner. First, the mandatory button properties such as
Location, Name, Text and TabIndex are initialized to specific values. The
TabIndex property is used to determine the control that should gain focus,
whenever the tab key is pressed.<span style="mso-spacerun: yes">  </span>For
the moment, the 'name' property is not used. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Then, the Form properties such
as ClientSize and AutoScaleBaseSize are initialized. The ClientSize property
determines the initial window size, whereas, the AutoScaleBaseSize member
decides the minimum size to which the form window can be minimized.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The AddRange function is passed
an array of Controls, which currently has only one member of the Button object,
since the form has only a single control placed on it. The title of the Form is
also set to a value, and like the Button, it is also assigned a name. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Visual Studio.Net is inherently
aware that the Click event is the default event for the button. Therefore, on
double clicking on the button, it writes a sub named Button1_Click. The name
consists of the name of button object, followed by the word 'Click'. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This sub is passed two
parameters with the 'Handles' keyword, having Button1 and Click, and thereby
handling the click event of the button. Thus, each time the button is clicked,
the Button1_Click sub gets called. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The last function that screams
for attention is named Dispose. The language keyword 'new' creates an object.
However, there is no corresponding 'delete' keyword for destroying the
object.<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>As per the latest trends in
programming languages, an object can be created explicitly, but it is the
prerogative of the system to decide when the object should die. In programming
languages, this concept is given the nomenclature of 'garbage collection'. By
convention, the Dispose function is called whenever the objects need to clean
things up.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>There can be multiple dispose
functions in a program. The word OverLoads is optional, which you may recall,
implies that the Form class has a similar function containing the keyword
'overridable'. The 'protected' modifier is applied to the function, because the
original sub also contains it.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Then, we check whether the
instance variable in the form has been instantiated or not. If the parameter
contains some value, it is assumed that the object has been created. So, the
Dispose function is called off this IContainer object. The line demonstrates
good programming style, which demands that the similar function of the base
class be called.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Barring the 'not' keyword that
converts a True to False and vice-versa, we have expounded every single concept
in the above code, by means of small program snippets. Our approach in the
remaining chapters would be to build VB applications, and simultaneously,
attempt at comprehending the VB code that gets generated.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Our programs will be pint-sized,
since only then is it feasible to explicate the concept lucidly. We will go to
the extent of explaining every keystroke that is pressed. So, if you follow our
instructions meticulously to the 'T' and not go astray, you would be able to
build complex windows applications with considerable ease. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>It would be a revelation to you that when we began learning
a product like Visual Studio.Net, we found it slightly complicated. This was
because the diminutive details of the product had to be unraveled, while trying
to learn the approach that Visual Studio.Net expected us to adopt. Therefore,
we have tried to make this voyage as comfortable as possible for you.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/vbnet/chap4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:59:13 GMT -->
</html>
