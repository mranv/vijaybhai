<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/aspnet1/chap4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:42:22 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap4_files/filelist.html">
<link rel=Edit-Time-Data href="chap4_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Classes - ASP.NET - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-26T10:44:00Z</o:Created>
  <o:LastSaved>2001-09-26T10:45:00Z</o:LastSaved>
  <o:Pages>23</o:Pages>
  <o:Words>6364</o:Words>
  <o:Characters>36276</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>302</o:Lines>
  <o:Paragraphs>72</o:Paragraphs>
  <o:CharactersWithSpaces>44549</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:24.0pt;
	font-family:"Trebuchet MS";
	color:black;
	mso-font-kerning:0pt;
	font-weight:normal;}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbullets, li.Cbullets, div.Cbullets
	{mso-style-name:"C\#bullets";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal align=center style='text-align:center'><b>-4-</b></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Classes</h1>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>In the earlier chapters, we had
exploited the existing C# classes like String and int, which were utilized to
display text and values. In this chapter, we shall focus on creating our own
classes. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;%@ Inherits=&quot;zzz&quot; Src=&quot;b1.cs&quot; language=C#
%&gt;<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Parser Error Message: 'zzz' is not a valid base class because
it does not extend class 'System.Web.UI.Page'.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>So far, we have learnt about the
'language' attribute with the ASP directive, which is used to specify the
programming language that we shall be using in the file. The 'language'
attribute was initialized to C#, thereby signifying that the rules of C# will
be applicable on the code inserted with the aspx tags. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We now introduce two more
attributes in addition to the 'language' directive. <o:p></o:p></span></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>inherits - This attribute requires
the name of a class and hence, we have provided the name zzz.<o:p></o:p></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>src - This attribute is initialized
to b1.cs, which is a program file that contains the class. <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A class is a collection of
variables and methods, which have been bunched together. It can therefore be
considered as a container of things.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The file b1.cs is a C# file which
contains the syntax 'public class zzz', followed by a pair of curly braces. The
keyword 'class' results in the creation of a class called zzz. The curly braces
signify the beginning and end of a class. Currently, the class that we have
created does not contain any variables or methods. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thus, we can conclude that the
integer class was created through the syntax 'class int', while the string
class was created through the use of the syntax 'class string'. There is no
other procedure available, to create a class. The rules that apply to one class
are common to the rest of the classes in C#. All the code in the C# language is
contained in classes only. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the above program, an error is
generated, since ASP+ does not expect an empty class. It expects the class to
contain variables and functions that it needs to invoke. However, they are not
currently present in the class. Since there is a paucity of time, and moreover,
due to lack of<span style="mso-spacerun: yes">  </span>perseverance that is
vital for writing all this code ourselves, we shall borrow code from an
existing class that contains the relevant functions and variables. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To inherit or borrow from another
class, we have to make one small amendment to the source code in the file
b1.cs.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>There exists a free class called
System.Web.UI.Page that has been written by the programmers at Microsoft. This
class has all the functions that ASP+ requires. To inherit or borrow from an
existing class, we are required to place a colon : after the name of the class
(as in zzz), and then specify the class that we want to inherit from, i.e.<span
style="mso-spacerun: yes">  </span>System.Web.UI.Page. You may have noticed
that, for the Page class, the name System.Web.UI.Page is an extended one. We
shall look into the reasons for the same, a little later.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Technically, we can say that the
class zzz derives from class Page. This implies that all the methods and
variables of class Page are now available to class zzz also. In a sense, it is
akin to writing all the methods and variables in the zzz class, by ourselves.
When we derive from the class Page, whatever is contained in the class, also
exists in the derived class zzz, making it a rich class.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The word 'public', which precedes
the class name, is an access modifier. Access modifiers are used to restrict
access to a class, since it may not be desirable to allow everyone to access
the class. The access modifier 'public' facilitates anyone and everyone to
access the class. On making these changes to the source code, no errors are
generated when we run our program.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;%@ Inherits=&quot;zzz&quot; Src=&quot;b1.cs&quot; language=C#
%&gt;<o:p></o:p></p>

<p class=Cprg>&lt;form action=&quot;a.aspx&quot; runat=&quot;server&quot;&gt;<o:p></o:p></p>

<p class=Cprg>&lt;asp:button type=submit text=&quot;Click&quot;
OnClick=&quot;abc&quot; runat=&quot;server&quot;/&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/form&gt;<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object a, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Response.Write(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>After every click on the button,
you will see the word 'hi' displayed. Let us now understand how the button
works. Each time we click on a button, the function abc is called, since it is
associated with the attribute OnClick. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You will not notice words such
as, 'script' in the aspx file because the function code is not present in
a.aspx. It is located in the class zzz, which is present within the src file
named b1.cs. As you must have noticed, this function resides within the class
zzz. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The 'inherits' attribute makes
the code, which is present in the class zzz of the file b1.cs, accessible to
the aspx file. Now, the function abc does not generate any error, since it
meets its match and displays 'hi' in the browser window. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This is fascinating because it demonstrates
that all the code within a C# file, can now be used with ASP+. So, let us now
expand our horizons about the basics of C# programming. We shall leave a.aspx
untouched for a long while, and modify the file b1.cs progressively, to explain
certain issues related to the C# programming language.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object o, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Compiler Error Message: CS0246: The type or namespace name
'yyy' could not be found (are you missing a using directive or an assembly
reference?)<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>In b1.cs, we are trying to create
an object 'a', that is an instance of a class yyy. But, the output displays an
error, stating that C# is unaware of the class yyy. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The occurrence of this error is
understandable, because C# may be well informed about, and familiar with
classes such as Page and a vast number of built-in classes, but it definitely
is not familiar with a user-defined class called yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object o, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You may be able to recall what we
had mentioned a little while ago, that, the only way to create a class is by
using the keyword 'class', followed by the class name. It cannot get simpler
than this. Thus, no more errors are generated. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object o, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Response.Write(&quot;hell&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Compiler Error Message: CS0165: Use of unassigned local
variable 'a'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It is not a child's play to learn
a programming language, especially when it also entails deciphering cryptic
errors. What does the error message 'unassigned local variable' signify? If you
may recall, in chapter 2, we had created a variable i of type int, and called
the ToString function off it. In a similar manner, we have now created a
variable a of type yyy and have called the function pqr off it. So, why is it
that an error is generated now, while it was not generated in the earlier
instance?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The answer lies in the manner in
which C# works internally. It divides all the classes it recognizes, into two
types, i.e. value types and reference types. Classes like int, bool and string,
which are called basic classes, are of value type, and all the other classes
are of reference type. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A value type variable is created
when we declare it. This means that i comes into existence and occupies memory
space when we declare it, using the syntax 'int i'. No extra code has to be
added after that, to create this. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the case of a reference type
variable, C# is first informed about the data type of the variable that we want
to create, and also the variable name that we would use to reference it. This
happens when we use the statement yyy a. In the next round, the keyword 'new'
or a function has to be used to formerly bring the variable into existence, and
then it is to be assigned a memory location, to enable it to reference members
of the specified data type. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Note, that unless the second step
is executed, the members in the class remain inaccessible to the object.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object o, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr(){<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>No errors are visible any longer.
It is because we have used the keyword 'new' to create an object 'a', which
looks like yyy. In technical jargon, 'a' is now an instance of class yyy. Thus,
the only way to create an object is, by using the keyword 'new', followed by
the name of the class. Thereafter, we have to use a pair of opening and closing
curly braces to encompass the actual code of the class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The instance 'a' now stores the
return value of 'new', which is a memory location. Henceforth, it can be used
to refer to all the members in the class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : System.Web.UI.Page<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc(System.Object o, System.EventArgs e)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>xxx a;<o:p></o:p></p>

<p class=Cprg>a = new xxx();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class xxx : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In this program, we have gone a
step further. The instance 'a' looks like xxx instead of yyy, and the function
pqr is called from class xxx. The class xxx is derived from class yyy,
following the simple rule of placing a colon first, followed by the name of the
class yyy. Thus, the class xxx inherits all members of class yyy. For the
moment, the class yyy has only one function called pqr, which the class xxx
'inherits'. Therefore, even though the class xxx does not contain the function
pqr, the object 'a' of type xxx can call it, which is because the class xxx
inherits the same from the class yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We need to explore the C#
programming language in greater depth to be able to fully understand what
ASP.NET does with the C# code written in a .cs file. In order to steer clear of
clutter, we have created a sub directory called aaa in the root where we have
written the following program in a file called b1.cs.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>c:\&gt;md aaa<o:p></o:p></p>

<p class=Coutput>c:\aaa&gt;edit b1.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This program is very similar to
the ones we have written earlier. The code written in a .cs file must be
converted into an executable program, as the web server and the web browser are
not involved here. To create an executable file, we use the command csc along
with the file name. In simple terms, the command csc can be called a program
which creates an executable, but in the context of the C# programming language,
it is identified as the C# compiler. Thus, the command is as follows:<span
style="mso-spacerun: yes">  </span>C:\aaa&gt;csc b1.cs<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Microsoft (R) Visual C# Compiler Version 7.00.9254 [CLR
version v1.0.2914]<o:p></o:p></p>

<p class=Coutput>Copyright (C) Microsoft Corp 2000-2001. All rights reserved.<o:p></o:p></p>

<p class=Coutput>error CS5001: Program 'b1.exe' does not have an entry point
defined<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The compiler reports an error,
since there is no 'entry point' defined in the exe file. What is an entry
point? Whenever a C# program begins execution, it starts execution from a base
function. This base function is called an entry point function. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Here, we are getting into the
details of the C# programming language, because all the code written in ASP+ is
first converted into C# code and then executed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Akin to the pqr function in yyy,
we have introduced a function called Main within zzz in the file b1.cs. This
function calls another function named System.Console.WriteLine.
System.Console.WriteLine comprises of a parameter, which is a string called
'hi'. The compiler now successfully generates 'b1.exe' in the same
subdirectory, without displaying any error messages. If you run this program at
the command prompt, using the command<span style="mso-spacerun: yes"> 
</span>'c:\aaa&gt;b1', the output displayed will be the word 'hi'. This proves
that Main is the base function or the entry point in any C# program. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>You may have noticed that the
System.Console.WriteLine function in a.cs program, behaves like the
Response.Write function of ASP+. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(6,1): error CS0120: An object reference is required for
the nonstatic field, method, or property 'zzz.abc()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Despite having reiterated this
concept on numerous occasions, we shall go over it once again, that 'Only an
object i.e. an instance of a class, is allowed access to the members of that
class'. Thus, in the above program, we are not allowed to call the function
abc, since we have still not created an instance of the class zzz. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>However, there is an exception to
this rule, which we shall introduce in the next program.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have added the keyword
'static' to the function abc. The keyword 'static' allows access to functions
or variable, even though, an instance of the class wherein it is contained, has
not been created. Hence, no error is generated. First the word 'hi' is
displayed on the screen, which is followed by the word 'abc'.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We shall employ one more program
to demonstrate the functionality of the keyword 'static'.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>yyy.abc();<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the class yyy, we have two
functions:<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The function abc, which has the
static keyword.<o:p></o:p></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The function pqr, which is
non-static. <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To summon a static function, we
simply use the name of the class, followed by the function name i.e. yyy.abc.
Since the function abc is static, there is no need to create an object that is
an instance of the class yyy. In short, a static function is associated with a
class and not with an object.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the case of the function pqr,
the rules get transformed completely. Since pqr is a non-static function, we
have to first create an object 'a' that is an instance of class yyy, and then
use the object to call the function pqr. The syntax is as follows:<span
style="mso-spacerun: yes">  </span>a.pqr(). <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>yyy.abc();<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Microsoft (R) Visual C# Compiler Version 7.00.9254 [CLR
version v1.0.2914]<o:p></o:p></p>

<p class=Coutput>Copyright (C) Microsoft Corp 2000-2001. All rights reserved.<o:p></o:p></p>

<p class=Coutput>b1.cs(6,1): error CS0246: The type or namespace name 'yyy'
could not be found<span style="mso-spacerun: yes">        </span>(are you
missing a using directive or an assembly reference?)<o:p></o:p></p>

<p class=Coutput>b1.cs(7,1): error CS0246: The type or namespace name 'yyy'
could not be found<span style="mso-spacerun: yes">        </span>(are you
missing a using directive or an assembly reference?)<o:p></o:p></p>

<p class=Coutput>b1.cs(8,1): error CS0103: The name 'a' does not exist in the
class or namespace<span style="mso-spacerun: yes">   </span>'zzz'<o:p></o:p></p>

<p class=Coutput>b1.cs(9,1): error CS0246: The type or namespace name 'a' could
not be found (are you missing a using directive or an assembly reference?)<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>On adding the words 'namespace
aaa' to the program, we obtain four errors. Why does this happen? The answer
reveals itself in the next program.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>aaa.yyy.abc();<o:p></o:p></p>

<p class=Cprg>aaa.yyy a;<o:p></o:p></p>

<p class=Cprg>a = new aaa.yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The errors have disappeared. This
could only be achieved by preceding the class name, i.e. yyy in Main, with the
namespace aaa, and then using the dot as the delimiter. Here, aaa is called a
namespace. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The concept of a namespace is
very simple. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Let us presume that in the .NET
world, there are a million functions. A programmer will go bonkers trying to
recollect the names of all these functions, along with the names of their
respective classes. It surely makes more sense to tidy them up by organizing them
in a systematic and logical fashion? <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>All printing functions can be
placed in one category, while all functions that write to a file can be placed
in another category. Instead of christening this type of classification as
'categories', the C# programming language makes use of the term 'namespace'. To
use a class belonging to a particular namespace, we have to use the format
'namespace.class'. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As our class yyy belongs to the
aaa namespace, the full name of the class becomes aaa.yyy, and not merely yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main(){<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>aaa.bbb.yyy.abc();<o:p></o:p></p>

<p class=Cprg>aaa.bbb.yyy a;<o:p></o:p></p>

<p class=Cprg>a = new aaa.bbb.yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace aaa{<o:p></o:p></p>

<p class=Cprg>namespace bbb{<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We can nest namespaces to as many
levels as desired. Here, we have a primary namespace called aaa containing a
secondary namespace called bbb. The full name of our class yyy therefore
becomes aaa.bbb.yyy, and the static function abc can be called using
aaa.bbb.yyy.abc. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Whenever we read an entity in C#,
we read it backwards, i.e. from right to left. We have the name of the function
at the right most end. This is preceded by the name of the class, and the class
name is preceded by the name of the namespace. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the past, whenever we had
derived from System.Web.UI.Page, Page was the name of the class and
System.Web.UI was the name of the namespace. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Similarly, in the case of
Response.Write, Response is the name of a class, while Write is a static
function contained in it. In the past, we had deliberately tried to shield you
from these complicated and perplexing concepts. This was for the simple reason
that, we believe in divulging such intricate concepts only when the time is
right for them to be appreciated. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>using aaa.bbb;<o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>yyy.abc();<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>namespace aaa<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>namespace bbb<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>pqr<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>It shall prove to be incredibly
cumbersome if we have to write aaa.bbb.yyy, every time we want to refer to the
class yyy. In order to overcome this difficulty, C# offers to us a short cut in
the form of a keyword called 'using'. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The keyword 'using' is followed
by the namespace and terminated by a semicolon. Every time a class name appears
in Main, C#<span style="mso-spacerun: yes">  </span>replaces it with its long
name, by placing the namespace in front of it.<span style="mso-spacerun: yes"> 
</span>In case of any mismatch, the error message 'namespace.class not found'
is generated. The keyword 'using' is similar to shorthand. It gives you the
freedom to write the name of a class without actually mentioning the namespace.
At the same time, the keyword 'using' can occur as many times as you want it
to, in your program.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:"Times New Roman";
color:windowtext'>Constructors<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>hi<o:p></o:p></p>

<p class=Coutput>yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Here, we have performed something
that is unusual and anomalous, that is to say, we have assigned the same name
to the function as to the class, i.e. yyy. Whenever a function has the same
name as that of the class, it is treated like a special function. It is called
a constructor. A constructor is automatically called, whenever an instance of
the class is created.<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>So, the code that is to be
executed when an object is created, is normally placed in the constructor. You
are free to place any code in the constructor. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(12,13): error CS0542: 'yyy': member names cannot be the
same as their enclosing type<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The syntax 'new yyy ()' creates
an instance of the class yyy. This implies that, it internally allocates memory
for the methods and the variables of the class yyy. The constructor is called,
as the last action in this sequence. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>At the time when the constructor
is being executed, the object has not been created. Thus, constructors cannot
return any values, because there is no object available to accept these values.
The void data type signifies that there is no return value. However, in the
case of constructors, there is no possibility of any value being repeated. The
C# compiler assumes that yyy is a normal function because of the return type.
Since a normal function cannot possess the same name as the name of the class,
the above error message is generated. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An object is created only after
the constructor finishes executing its code successfully.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(8,1): error CS0117: 'yyy' does not contain a definition
for 'yyy'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>A constructor is a function with
only two restrictions:<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The first is that it cannot return
any values, as explained above.<o:p></o:p></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The second is that we cannot call a
constructor explicitly.<span style="mso-spacerun: yes">   </span>It gets called
automatically, only during the creation of an instance of a class.<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>a.abc(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>a.abc(10);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc &quot; + s);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc(int i)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc &quot;+ i);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>abc hi<o:p></o:p></p>

<p class=Coutput>abc 10<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In C#, we are allowed to create
different functions having the same name, as long as they accept different
number and types of parameters. We may be acquainted with a function only by
its name, but C# identifies a function by using its name, as well as, through
the number of its parameters along with their data types. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have created three separate
functions in our program using the same function i.e. abc. However, since the
parameter types are different in each case, C# flags them as separate
functions. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(6,5): error CS1501: No overload for method 'yyy' takes
'1' arguments<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>A constructor is basically a
function. So, all the rules of a function also apply to a constructor. Thus, in
the case of yyy, we need a function/constructor that accepts a string as a
parameter. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public yyy(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot; + s);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>yyy hi<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>To eliminate the above error, we
have introduced one more constructor that takes a single string type parameter.
The constructor that has more than one parameter is ignored, and the one with a
single parameter is called. Thus, when we create an object using 'new', only
the constructors that pre-exist in the class are called. If a constructor with
a specific number of parameters, does not exist, we cannot use 'new' to create
an object with those many number of parameters, because it will generate an
error.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot; + s);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(6,5): error CS1501: No overload for method 'yyy' takes
'0' arguments<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Life consists of unexpected
twists and turns, which adds, in no small measure, to its excitement. Earlier,
when we had not used constructors in our code, C# allowed us to use the keyword
'new' with abandon. However unexpectedly, when constructors were introduced, it
raised several objections. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The rationale behind this is,
when we have a class without any constructors, by default, the compiler
introduces a constructor that has no parameters, as in public yyy() { }. This
is provided to us for free. Thus, when we have no constructors in a class, we
are provided with one that has no parameters. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>But, if we explicitly introduce
even a single constructor, the free constructor brought in by the compiler, is
retracted. In class yyy, since we have a constructor with one parameter, the
free constructor that has no parameters, is not added. Hence, the above error
is generated. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public yyy(string s)<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot; + s);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The only way of getting rid of
the error message is by introducing a constructor that has no parameters in the
class yyy.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz {<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;main&quot;);<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;main 1&quot;);<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>static yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy static&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>main<o:p></o:p></p>

<p class=Coutput>main 1<o:p></o:p></p>

<p class=Coutput>yyy static<o:p></o:p></p>

<p class=Coutput>yyy<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Static constructors are always
called before the non-static or instance constructors. Moreover, they get
called before any member of a class can be accessed.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;main&quot;);<o:p></o:p></p>

<p class=Cprg>yyy.abc();<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;main 1&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy &quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>static yyy()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;yyy static&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public static void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>main<o:p></o:p></p>

<p class=Coutput>yyy static<o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Coutput>main 1<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>The above program demonstrates
that the static constructor is called before the static function abc. As we are
not creating an object that is an instance of class yyy, the non-static
constructor of class yyy is never called. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:"Times New Roman";
color:windowtext'>Interfaces <o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An interface is similar to a
class. It is a reserved word in the C# programming language. Since it has been
used correctly from a syntactical point of view, no errors are generated.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are also permitted to declare
an object that looks like an interface, yyy. No errors are generated at all. A
question that vexes us, is- 'Are interfaces and classes similar?'<span
style="mso-spacerun: yes">  </span>Do not lose sleep over this, since they are
as similar to each other, as a fish is to a fowl.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(6,5): error CS0144: Cannot create an instance of the
abstract class or interface 'yyy'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The first difference between an
interface and a class is that, an interface cannot be instantiated by using the
keyword 'new'. We can use 'new' only to instantiate a class and not an
interface. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a;<o:p></o:p></p>

<p class=Cprg>a = new zzz();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(1,14): error CS0535: 'zzz' does not implement interface
member 'yyy.abc()'<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>An interface can only consist of
function prototypes, i.e. the function name with its parameters. Hence, yyy is
an interface that contains only one function called abc, that takes no
parameters and returns a void. You may have noticed that we have not used the
open and close curly braces to enclose the function code. Instead, we have
terminated the function with a semicolon. Class zzz is derived from the
interface yyy in the usual manner, i.e. by using a colon sign. We get an error
message because the code of the function abc, is not present anywhere in the
class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When one class derives from
another class, it inherits all the functions of the base class. But when a
class derives from an interface, i.e. when it implements an interface, the code
for the functions in the interface, has to be explicitly specified in the
class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a;<o:p></o:p></p>

<p class=Cprg>a = new zzz();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>abc<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The error message has vanished,
since we have implemented all the functions in the interface yyy. If the
interface yyy has 10 functions or definitions or prototypes, we have to add the
code for all these functions in the class zzz. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : yyy,xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>zzz a;<o:p></o:p></p>

<p class=Cprg>a = new zzz();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public void pqr()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;pqr&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public interface xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>void pqr();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We are allowed to derive from as
many interfaces as we like. This is not the case with classes. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>In the above program, we are
deriving from two interfaces, viz. yyy and xxx at the same time. All that is
required to be done is, to ensure that we have added the code for functions abc
and pqr, in the class zzz.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b1.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz : yyy,xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class yyy<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>public class xxx<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>b1.cs(1,24): error CS0527: 'xxx' : type in interface list is
not an interface<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>As we have stated earlier, we are
not allowed to derive from two classes. In C#, multiple inheritance from
classes is strictly prohibited.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;%@ language=C# %&gt;<o:p></o:p></p>

<p class=Cprg>hi<o:p></o:p></p>

<p class=Cprg>&lt;%<o:p></o:p></p>

<p class=Cprg>Respone.Write(&quot;hi&quot;);<o:p></o:p></p>

<p class=Cprg>error<o:p></o:p></p>

<p class=Cprg>%&gt;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have created a simple aspx
called a.aspx, and created an error in the C# code. The reason behind doing
this is that, we intend to discover the code that is generated by ASP+. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>When we clicked on the last link
called + Show Complete Compilation Source, we got the following output:<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Line 1:<span style="mso-spacerun: yes">    </span>//--------------------------------------------------------------<o:p></o:p></p>

<p class=Coutput>Line 2:<span style="mso-spacerun: yes">    </span>//
&lt;autogenerated&gt;<o:p></o:p></p>

<p class=Coutput>Line 3:<span style="mso-spacerun: yes">    </span>//<span
style="mso-spacerun: yes">     </span>This code was generated by a tool.<o:p></o:p></p>

<p class=Coutput>Line 4:<span style="mso-spacerun: yes">    </span>//<span
style="mso-spacerun: yes">     </span>Runtime Version: 1.0.2914.16<o:p></o:p></p>

<p class=Coutput>Line 5:<span style="mso-spacerun: yes">    </span>//<o:p></o:p></p>

<p class=Coutput>Line 6:<span style="mso-spacerun: yes">    </span>//<span
style="mso-spacerun: yes">     </span>Changes to this file may cause incorrect
behavior and will be lost if <o:p></o:p></p>

<p class=Coutput>Line 7:<span style="mso-spacerun: yes">    </span>//<span
style="mso-spacerun: yes">     </span>the code is regenerated.<o:p></o:p></p>

<p class=Coutput>Line 8:<span style="mso-spacerun: yes">    </span>//
&lt;/autogenerated&gt;<o:p></o:p></p>

<p class=Coutput>Line 9:<span style="mso-spacerun: yes">   
</span>//--------------------------------------------------------------<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>Line 10:<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Coutput>Line 11:<span style="mso-spacerun: yes">   </span>namespace
ASP {<o:p></o:p></p>

<p class=Coutput>Line 12:<span style="mso-spacerun: yes">       </span>using
System;<o:p></o:p></p>

<p class=Coutput>Line 13:<span style="mso-spacerun: yes">       </span>using
System.Collections;<o:p></o:p></p>

<p class=Coutput>Line 14:<span style="mso-spacerun: yes">       </span>using
System.Collections.Specialized;<o:p></o:p></p>

<p class=Coutput>Line 15:<span style="mso-spacerun: yes">       </span>using
System.Configuration;<o:p></o:p></p>

<p class=Coutput>Line 16:<span style="mso-spacerun: yes">       </span>using
System.Text;<o:p></o:p></p>

<p class=Coutput>Line 17:<span style="mso-spacerun: yes">       </span>using
System.Text.RegularExpressions;<o:p></o:p></p>

<p class=Coutput>Line 18:<span style="mso-spacerun: yes">       </span>using
System.Web;<o:p></o:p></p>

<p class=Coutput>Line 19:<span style="mso-spacerun: yes">       </span>using
System.Web.Caching;<o:p></o:p></p>

<p class=Coutput>Line 20:<span style="mso-spacerun: yes">       </span>using
System.Web.SessionState;<o:p></o:p></p>

<p class=Coutput>Line 21:<span style="mso-spacerun: yes">       </span>using
System.Web.Security;<o:p></o:p></p>

<p class=Coutput>Line 22:<span style="mso-spacerun: yes">       </span>using
System.Web.UI;<o:p></o:p></p>

<p class=Coutput>Line 23:<span style="mso-spacerun: yes">       </span>using
System.Web.UI.WebControls;<o:p></o:p></p>

<p class=Coutput>Line 24:<span style="mso-spacerun: yes">       </span>using
System.Web.UI.HtmlControls;<o:p></o:p></p>

<p class=Coutput>Line 25:<span style="mso-spacerun: yes">       </span><o:p></o:p></p>

<p class=Coutput>Line 26:<span style="mso-spacerun: yes">       </span><o:p></o:p></p>

<p class=Coutput>Line 27:<span style="mso-spacerun: yes">       </span>public
class a_aspx : System.Web.UI.Page,
System.Web.SessionState.IRequiresSessionState {<o:p></o:p></p>

<p class=Coutput>Line 28:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 29:<span style="mso-spacerun: yes">          
</span>private static System.Web.UI.AutomaticHandlerMethodInfos __autoHandlers;<o:p></o:p></p>

<p class=Coutput>Line 30:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 31:<span style="mso-spacerun: yes">          
</span>private static bool __intialized = false;<o:p></o:p></p>

<p class=Coutput>Line 32:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 33:<span style="mso-spacerun: yes">          
</span>private static System.Collections.ArrayList __fileDependencies;<o:p></o:p></p>

<p class=Coutput>Line 34:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 35:<span style="mso-spacerun: yes">          
</span>public a_aspx() {<o:p></o:p></p>

<p class=Coutput>Line 36:<span style="mso-spacerun: yes">       </span><span
style="mso-spacerun: yes">        </span>System.Collections.ArrayList
dependencies;<o:p></o:p></p>

<p class=Coutput>Line 37:<span style="mso-spacerun: yes">              
</span>if ((ASP.a_aspx.__intialized == false)) {<o:p></o:p></p>

<p class=Coutput>Line 38:<span style="mso-spacerun: yes">                  
</span>dependencies = new System.Collections.ArrayList();<o:p></o:p></p>

<p class=Coutput>Line 39:<span style="mso-spacerun: yes">                  
</span>dependencies.Add(&quot;C:\\Inetpub\\wwwroot\\a.aspx&quot;);<o:p></o:p></p>

<p class=Coutput>Line 40:<span style="mso-spacerun: yes">                  
</span>ASP.a_aspx.__fileDependencies = dependencies;<o:p></o:p></p>

<p class=Coutput>Line 41:<span style="mso-spacerun: yes">                  
</span>ASP.a_aspx.__intialized = true;<o:p></o:p></p>

<p class=Coutput>Line 42:<span style="mso-spacerun: yes">              
</span>}<o:p></o:p></p>

<p class=Coutput>Line 43:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 44:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 45:<span style="mso-spacerun: yes">          
</span>protected override System.Web.UI.AutomaticHandlerMethodInfos
AutoHandlers {<o:p></o:p></p>

<p class=Coutput>Line 46:<span style="mso-spacerun: yes">              
</span>get {<o:p></o:p></p>

<p class=Coutput>Line 47:<span style="mso-spacerun: yes">                  
</span>return ASP.a_aspx.__autoHandlers;<o:p></o:p></p>

<p class=Coutput>Line 48:<span style="mso-spacerun: yes">              
</span>}<o:p></o:p></p>

<p class=Coutput>Line 49:<span style="mso-spacerun: yes">              
</span>set {<o:p></o:p></p>

<p class=Coutput>Line 50:<span style="mso-spacerun: yes">                  
</span>ASP.a_aspx.__autoHandlers = value;<o:p></o:p></p>

<p class=Coutput>Line 51:<span style="mso-spacerun: yes">              
</span>}<o:p></o:p></p>

<p class=Coutput>Line 52:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 53:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 54:<span style="mso-spacerun: yes">          
</span>protected System.Web.HttpApplication ApplicationInstance {<o:p></o:p></p>

<p class=Coutput>Line 55:<span style="mso-spacerun: yes">              
</span>get {<o:p></o:p></p>

<p class=Coutput>Line 56:<span style="mso-spacerun: yes">                  
</span>return ((System.Web.HttpApplication)(this.Context.ApplicationInstance));<o:p></o:p></p>

<p class=Coutput>Line 57:<span style="mso-spacerun: yes">              
</span>}<o:p></o:p></p>

<p class=Coutput>Line 58:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 59:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 60:<span style="mso-spacerun: yes">          
</span>public override string TemplateSourceDirectory {<o:p></o:p></p>

<p class=Coutput>Line 61:<span style="mso-spacerun: yes">              
</span>get {<o:p></o:p></p>

<p class=Coutput>Line 62:<span style="mso-spacerun: yes">                  
</span>return &quot;/&quot;;<o:p></o:p></p>

<p class=Coutput>Line 63:<span style="mso-spacerun: yes">              
</span>}<o:p></o:p></p>

<p class=Coutput>Line 64:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 65:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 66:<span style="mso-spacerun: yes">          
</span>public override void InstantiateIn(System.Web.UI.Control control) {<o:p></o:p></p>

<p class=Coutput>Line 67:<span style="mso-spacerun: yes">              
</span>this.__BuildControlTree(control);<o:p></o:p></p>

<p class=Coutput>Line 68:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 69:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 70:<span style="mso-spacerun: yes">          
</span>private void __BuildControlTree(System.Web.UI.Control __ctrl) {<o:p></o:p></p>

<p class=Coutput>Line 71:<span style="mso-spacerun: yes">              
</span>__ctrl.SetRenderMethodDelegate(new
System.Web.UI.RenderMethod(this.__Render__control1));<o:p></o:p></p>

<p class=Coutput>Line 72:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 73:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 74:<span style="mso-spacerun: yes">           </span>private
void __Render__control1(System.Web.UI.HtmlTextWriter __output,
System.Web.UI.Control parameterContainer) {<o:p></o:p></p>

<p class=Coutput>Line 75:<span style="mso-spacerun: yes">              
</span>__output.Write(&quot;\r\nhi\r\n&quot;);<o:p></o:p></p>

<p class=Coutput>Line 76:<span style="mso-spacerun: yes">               </span><o:p></o:p></p>

<p class=Coutput>Line 77:<span style="mso-spacerun: yes">              
</span>#line 3 &quot;C:\Inetpub\wwwroot\a.aspx&quot;<o:p></o:p></p>

<p class=Coutput>Line 78:<span style="mso-spacerun: yes">               </span><o:p></o:p></p>

<p class=Coutput>Line 79:<span style="mso-spacerun: yes">  
</span>Respone.Write(&quot;hi&quot;);<o:p></o:p></p>

<p class=Coutput>Line 80:<span style="mso-spacerun: yes">   </span>error<o:p></o:p></p>

<p class=Coutput>Line 81:<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Coutput>Line 82:<span style="mso-spacerun: yes">               </span><o:p></o:p></p>

<p class=Coutput>Line 83:<span style="mso-spacerun: yes">              
</span>#line default<o:p></o:p></p>

<p class=Coutput>Line 84:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 85:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 86:<span style="mso-spacerun: yes">          
</span>protected override void FrameworkInitialize() {<o:p></o:p></p>

<p class=Coutput>Line 87:<span style="mso-spacerun: yes">              
</span>this.FileDependencies = ASP.a_aspx.__fileDependencies;<o:p></o:p></p>

<p class=Coutput>Line 88:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 89:<span style="mso-spacerun: yes">           </span><o:p></o:p></p>

<p class=Coutput>Line 90:<span style="mso-spacerun: yes">          
</span>public override int GetTypeHashCode() {<o:p></o:p></p>

<p class=Coutput>Line 91:<span style="mso-spacerun: yes">              
</span>return 2141278421;<o:p></o:p></p>

<p class=Coutput>Line 92:<span style="mso-spacerun: yes">           </span>}<o:p></o:p></p>

<p class=Coutput>Line 93:<span style="mso-spacerun: yes">       </span>}<o:p></o:p></p>

<p class=Coutput>Line 94:<span style="mso-spacerun: yes">   </span>}<o:p></o:p></p>

<p class=Coutput>Line 95:<span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The output displayed above is the
C# code generated by ASP+ in respect of our aspx file. Let us try and decipher
this output with the limited knowledge of C# that we have acquired so far. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We begin with a series of 'using'
statements that are followed by the names of the namespaces. These 'using'
statements ensure that we do not have to write the namespace names anymore. The
C# file generated by ASP+ has a class name called a_aspx, since 'a' is the name
of our aspx file. This class is derived from System.Web.UI.Page, which means
that, all the code in the Page class is now available to a_aspx. The class also
implements an interface called IRequiresSessionState, which we shall touch
upon, a little later.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The class consists of a static
constructor a_aspx, which has no parameters. Amongst the other functions
present in the file, the most important function is __Render__control1. We will
ignore all the above code for the moment, and focus only on this function. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This function always gets called
by ASP+. All code other than the aspx code, i.e. the code in HTML or Javascript
etc., get added to this function. This function therefore, happens to be the
most crucial one. It accepts two parameters: <o:p></o:p></span></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The first parameter is output, which
is an instance of the class HtmlTextWriter in the System.Web.UI namespace.
Write is a function in the class HtmlTextWriter. Hence, it can be invoked by
calling<span style="mso-spacerun: yes">  </span>output.Write.<o:p></o:p></p>

<p class=Cbullets><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbullets><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>     </span></span>The second parameter to
__Render__control1 is parameterContainer. It is an instance of the class
Control in the System.Web.UI namespace. This parameter represents a control.
The HTML text 'hi' is converted into a parameter and passed to the function
Write .<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The C# functions get copied word
for word, just as we had entered them. Hasn't ASP+ become more comprehensible
now? We have learnt a lot about ASP+ by making errors, and then analyzing the
code that was generated. We recommend the same for you.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><b><span style='font-size:14.0pt;font-family:"Times New Roman";
color:windowtext'>Writing Components<o:p></o:p></span></b></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>One question that continues to
bother us is &quot;How does C# compile the ASP generated code?&quot;<span
style="mso-spacerun: yes">  </span>To understand this, we go back to our
subdirectory aaa and create two files called a.cs and b.cs.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.cs</u><o:p></o:p></p>

<p class=Cprg>public class zzz <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public static void Main()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>yyy a;<o:p></o:p></p>

<p class=Cprg>a = new yyy();<o:p></o:p></p>

<p class=Cprg>a.abc();<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Coutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Microsoft (R) Visual C# Compiler Version 7.00.9254 [CLR
version v1.0.2914] Copyright (C) Microsoft Corp 2000-2001. All rights reserved.<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>a.cs(5,1): error CS0246: The type or namespace name 'yyy'
could not be found (are you missing a using directive or an assembly
reference?)<o:p></o:p></p>

<p class=Coutput>a.cs(6,1): error CS0103: The name 'a' does not exist in the
class or namespace 'zzz'<o:p></o:p></p>

<p class=Coutput>a.cs(7,1): error CS0246: The type or namespace name 'a' could
not be found (are you missing a using directive or an assembly reference?)<o:p></o:p></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>An error is generated, since C#
cannot locate the class yyy anywhere. So far, all our classes were stored in a
single file called a.cs. In this program, the class yyy is present in the file
b.cs.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>b.cs</u><o:p></o:p></p>

<p class=Cprg>public class yyy <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>public void abc()<o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Using the csc command, not only
can we create an executable file such as a.exe, but also a dll. The acronym dll
stands for Dynamic Link Library. Code that needs to be shared under Windows,
comes packaged in a dll. To create a dll, we use the same csc command, but with
different options. We use the following command<o:p></o:p></span></p>

<p class=Coutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Coutput>c:\aaa&gt;csc /t:library /out:b.dll b.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /t:library option instructs
the compiler to create a library or a dll. By default, the compiler creates an
exe file. Further, the /out: option allows us to assign a name to the file. Had
we not assigned any name, the default name would have been b.dll, since the
source file is named b.cs. Now that we have created our dll file, we simply
need to inform our csc compiler to look into this file, for the code of our
desired classes. Now, all that we do is, run csc as follows:<span
style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>c:\aaa&gt;csc /r:b.dll a.cs<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The /r option asks the compiler
to look into b.dll for the code of those classes, that are not contained in the
file a.cs. The above program will produce a file called a.exe which, when
executed, will call the function abc from the class yyy. This concept is quite
simple and clear-cut, don't you agree ?<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Let us now run the following aspx
file:<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;%@ language=C# %&gt;<o:p></o:p></p>

<p class=Cprg>&lt;%<o:p></o:p></p>

<p class=Cprg>error<o:p></o:p></p>

<p class=Cprg>%&gt;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We get an error message. When we
click on<span style="mso-spacerun: yes">   </span>+ Show Detailed Compiler
Output:, we see the following command:<o:p></o:p></span></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput style='margin-left:.3in'><span style='font-size:9.0pt;
font-family:"Bookman Old Style"'>C:\WINNT\system32&gt;
&quot;c:\winnt\microsoft.net\framework\v1.0.2914\csc.exe&quot; /t:library
/utf8output /R:&quot;c:\winnt\assembly\gac\system\1.0.2411.0__b77a5c561934e089\system.dll&quot;
<o:p></o:p></span></p>

<p class=Coutput style='margin-left:.3in'><span style='font-size:9.0pt;
font-family:"Bookman Old Style"'>/R:&quot;c:\winnt\assembly\gac\system.xml\1.0.2411.0__b77a5c561934e089\system.xml.dll&quot;
<o:p></o:p></span></p>

<p class=Coutput style='margin-left:.3in'><span style='font-size:9.0pt;
font-family:"Bookman Old Style"'>/R:&quot;c:\winnt\assembly\gac\system.drawing\1.0.2411.0__b03f5f7f11d50a3a\system.drawing.dll&quot;
/R:&quot;c:\winnt\assembly\gac\system.data\1.0.2411.0__b77a5c561934e089\system.data.dll&quot;
/R:&quot;c:\winnt\assembly\gac\system.web.services\1.0.2411.0__b03f5f7f11d50a3a\system.web.services.dll&quot;
/R:&quot;c:\winnt\microsoft.net\framework\v1.0.2914\mscorlib.dll&quot;
/R:&quot;c:\winnt\assembly\gac\system.web\1.0.2411.0__b03f5f7f11d50a3a\system.web.dll&quot;
/out:&quot;C:\WINNT\Microsoft.NET\Framework\v1.0.2914\Temporary ASP.NET
Files\root\fa7064c6\2014c0f1\jhbdrf-n.dll&quot; /debug- /optimize+<span
style="mso-spacerun: yes"> 
</span>&quot;C:\WINNT\Microsoft.NET\Framework\v1.0.2914\Temporary ASP.NET
Files\root\fa7064c6\2014c0f1\jhbdrf-n.0.cs&quot;<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This appears quite complicated,
but it is very simple to follow. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>ASP+, by default, runs in the
subdirectory of WINNT\system32. So, the C# compiler csc is invoked from this
directory. Now, since csc is not located in the system32 subdirectory, the
absolute path is given for the command i.e. <o:p></o:p></span></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><span style='font-size:10.0pt;font-family:"Bookman Old Style"'>&quot;c:\winnt\microsoft.net\framework\v1.0.2914\csc.exe&quot;</span><o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'>You will also notice a large
number of /R options, that direct the compiler to look into all the specified
dlls for code of classes. In case we require code from a dll that is not listed
above, then we are surely out of luck. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Thereafter, the C# compiler is
instructed to create a library and not an exe file. This output file is given a
dll name<span style="mso-spacerun: yes">  </span>by using the /out: option, and
it is stored in a particular directory <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput>/out:&quot;C:\WINNT\Microsoft.NET\Framework\v1.0.2914\Temporary
ASP.NET Files\root\fa7064c6\2014c0f1\ehcuumxx.dll&quot; <o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The name assigned to the C#
program is ehcuumxx.0.cs. We can physically verify these files by going to the
specified subdirectories. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>This goes on to prove that all
the HTML text and the C# code that we write in an aspx file, are finally packed
into a dll. When the aspx file called 'a', is loaded for the very first time,
it consumes a considerable amount of time. This is because, ASP+ has to first
write out the C# program, and then compile it to generate a dll. Finally, the
code is executed, which results in the display of the output in the browser
window. All this happens only once, and thus, it takes a very long time. But
subsequently, when the same file is requested off the server, the HTML file is
generated in a much speedier manner, since the dll has already been created.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;html&gt;<o:p></o:p></p>

<p class=Cprg>&lt;script language=&quot;C#&quot; runat=&quot;server&quot;&gt;<o:p></o:p></p>

<p class=Cprg>void Page_Load(Object s, EventArgs E) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 10;<o:p></o:p></p>

<p class=Cprg>short j = 2;<o:p></o:p></p>

<p class=Cprg>j = i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>&lt;/script&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/body&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/html&gt;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output </u><o:p></o:p></p>

<p class=Coutput>Compiler Error Message: CS0029: Cannot implicitly convert type
'int' to 'short'<o:p></o:p></p>

<p class=Coutput>Line 7:<span style="mso-spacerun: yes">  </span>j = i;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>We have created two variables of
two different data types, namely, i as an int and j as a short. We are not
allowed to equate two different data types with each other. Thus, we get an
error 'cannot covert to … line 7 j=i '. C# does not support the concept of
equating different data types.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;html&gt;<o:p></o:p></p>

<p class=Cprg>&lt;script language=&quot;C#&quot; runat=&quot;server&quot;&gt;<o:p></o:p></p>

<p class=Cprg>void Page_Load(Object s, EventArgs E) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>int i = 10;<o:p></o:p></p>

<p class=Cprg>short j = 2;<o:p></o:p></p>

<p class=Cprg>j = (short)i;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>&lt;/script&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/body&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/html&gt;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The same program now shows no
error, which is because we made sure that both sides of the 'equal to' sign are
of the same data type. This is incorporated by means of using the round
brackets, and then by mentioning the data type to which we want the other side
converted. This does not change the value of i, since it is only for a short
time, that we change its data type, from an int to a short. Now, since both
sides of the 'equal to' sign have a short data type, we do no get any error.
The above pair of () brackets, with the data type mentioned within it, is
called a cast operator.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The next program employs user
controls, as by now, we are fairly familiar with the concept of 'new'.<o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cprg><u>a.aspx</u><o:p></o:p></p>

<p class=Cprg>&lt;%@ Register TagPrefix=&quot;vijay&quot;
TagName=&quot;mukhi&quot; Src=&quot;a1.ascx&quot; %&gt;<o:p></o:p></p>

<p class=Cprg>&lt;html&gt;<o:p></o:p></p>

<p class=Cprg>&lt;script language=&quot;C#&quot; runat=&quot;server&quot;&gt;<o:p></o:p></p>

<p class=Cprg>void Page_Load(Object s, EventArgs E) <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>Page.Controls.Add(new HtmlGenericControl(&quot;hr&quot;));<o:p></o:p></p>

<p class=Cprg>UserControl c1 = (UserControl) LoadControl(&quot;a1.ascx&quot;);<o:p></o:p></p>

<p class=Cprg>((a1_ascx)c1).Category = &quot;business&quot;;<o:p></o:p></p>

<p class=Cprg>Page.Controls.Add(c1);<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>&lt;/script&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/body&gt;<o:p></o:p></p>

<p class=Cprg>&lt;/html&gt;<o:p></o:p></p>

<p class=Cprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=Cprg><u>a1.ascx</u><o:p></o:p></p>

<p class=Cprg>&lt;script language=&quot;C#&quot; runat=&quot;server&quot;&gt;<o:p></o:p></p>

<p class=Cprg>public String aa;<o:p></o:p></p>

<p class=Cprg>public String Category <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>get <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>return aa;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>set <o:p></o:p></p>

<p class=Cprg>{<o:p></o:p></p>

<p class=Cprg>aa = value;<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>}<o:p></o:p></p>

<p class=Cprg>&lt;/script&gt;<o:p></o:p></p>

<p class=Cprg>&lt;span &gt;Sonal: &lt;%=aa%&gt;&lt;/span&gt;<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Coutput><u>Output</u><o:p></o:p></p>

<p class=Coutput>Sonal: business<o:p></o:p></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>Let us look at a.aspx. In the
Page_Load function, we first create an HTML tag 'hr', by using 'new'. This
control is then added to the list of controls, using the Add function in
Page.Controls. In this manner, we can dynamically add any control or tag we like,
to a page. The a1.ascx file that contains the control, is then loaded, using
the LoadControl function. The result of this function is a control that is
stored in an object called c1. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'>The control has a property called
Category, which is initialized to business. We need to cast it to a1_ascx,
since we need to convert c1, which looks like class UserControl, into an
a1_ascx class. <o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=MsoNormal>Due to the Register attribute on the control file named
a1.ascx, ASP+ creates a class a1_ascx that represents our control. Hence, we
need to use a cast operator, because the object c1 does not contain any
property called Category. We use the Add function again to add c1 to the page.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/aspnet1/chap4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:42:24 GMT -->
</html>
