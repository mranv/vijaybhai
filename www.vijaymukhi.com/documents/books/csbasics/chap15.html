<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap15.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:42 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap15_files/filelist.html">
<link rel=Edit-Time-Data href="chap15_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Unsafe code - C# The Basics - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>4</o:Revision>
  <o:TotalTime>21</o:TotalTime>
  <o:Created>2001-09-27T11:10:00Z</o:Created>
  <o:LastSaved>2001-09-27T11:31:00Z</o:LastSaved>
  <o:Pages>18</o:Pages>
  <o:Words>3617</o:Words>
  <o:Characters>20621</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>171</o:Lines>
  <o:Paragraphs>41</o:Paragraphs>
  <o:CharactersWithSpaces>25324</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:36.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;
	font-weight:normal;}
p.SubTitle, li.SubTitle, div.SubTitle
	{mso-style-name:SubTitle;
	mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:48.0pt'>15</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Unsafe code</h1>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Today, the programming language C is the most widely used
because of only one reason and that is the use of pointers. In this chapter, we
will explain what pointers are all about and how they can be used in the world
of C#.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,6): error CS0214: Pointers may only be used in an
unsafe context<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>All simple variables like int, byte, short store numbers.
When we create a variable in C#, we are allowed to put a
multiplication/asterisk sign '*' in front of the variable. These variables are
called Pointers. We get an error as C# considers pointers to be unsafe and
hence we need special permission to use pointers.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,20): error CS0227: Unsafe code may only appear if
compiling with /unsafe<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As seen in the previous chapter, the unsafe option must be
tagged while compiling the program.<span style="mso-spacerun: yes"> 
</span>Give the command as csc a.cs /unsafe and the error now disappears.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The C# documentation very clearly states that the modifier
can be used along with the class keyword, By using the modifier unsafe, we are
asking C# to let us use pointers as we are unable to write code without the use
of pointers.<o:p></o:p></p>

<p class=cbasetext><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=programs><u><span style='color:black'>a.cs</span></u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>Console.WriteLine(sizeof(byte *) + &quot; &quot; +
sizeof(short *) + &quot; &quot; + sizeof(int *) + &quot; &quot; + sizeof(long
*));<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs>Console.WriteLine(sizeof(byte **) + &quot; &quot; +
sizeof(short **) + &quot; &quot; + sizeof(int **) + &quot; &quot; + sizeof(long
**));<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>4 4 4 4<o:p></o:p></p>

<p class=DOSPROMPT>4 4 4 4<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Some time back, we had used the sizeof keyword, to determine
how much memory C# allocates for our variables. When we ask for the sizeof an
pointer variable, we always get 4, irrespective of whether the data type is a
short or int or whatever, including another pointer.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz {<o:p></o:p></p>

<p class=programs>public static void Main() {<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy {<o:p></o:p></p>

<p class=programs>unsafe public void abc() {<o:p></o:p></p>

<p class=programs>int<span style="mso-spacerun: yes">  </span>*i;<o:p></o:p></p>

<p class=programs>int j=1;<o:p></o:p></p>

<p class=programs>i = &amp;j;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>*i = 10;<o:p></o:p></p>

<p class=programs>Console.WriteLine(j);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243472<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=345 height=394 id="_x0000_i1026"
src="chap15img/img1.bmp"><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have created a variable j that has been initialized to
one. We have also created a variable i, with a multiplication sign at the time
of creation. By doing this C# allocated four memory locations to store i. What
is most important is that a pointer variable is just like any another variable.
It simply stores numbers. The single big difference is that a pointer variable
value is interpreted as a computer memory location. If both i and j were being
initialized to 1, then j is the number 1 as we know it, whereas i stand for
computer memory location 1. Pointers can only be initialized to a computer
memory location. Whenever we place an ampersand(&amp;) in front of a variable,
we are asking C# to tell us about the memory allocated for the variable. Every
time C# creates a variable, it stores it somewhere in memory. We are at times
interested in knowing where in memory the variable was allocated. A &amp; in
front of j will tell us the memory location where j starts in memory. As it is
a computer memory location or address we can store it in i. C# allocated 4
memory location for j and the start of these 4 are being stored in a pointer.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We would like to display the value of the pointer. The
WriteLine function does not have an overload to display a pointer and we have
to cast it to an int. As we get 1243472 displayed, it could only mean that the
variable j begins here and is spread over memory locations 1243473, 1243474 and
1243475.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We can only place the multiplication sign in front of a
variable defined to be a pointer. If i is not a pointer, *i will return an
error. C# here asks a simple question. What is the value of the variable i? .
The answer is 1243472. C# will now go to memory location 1243472 to 1243475 and
place the value 10 there. As the value of j is determined by what is present
from memory locations 1243472 to 1243475, the value of j changes from 1 to 10.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><span style="mso-spacerun: yes">    </span><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int<span style="mso-spacerun: yes">  </span>*i;<o:p></o:p></p>

<p class=programs>int j=1, k = 1;<o:p></o:p></p>

<p class=programs>i = &amp;j;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>*i = 10;<o:p></o:p></p>

<p class=programs>Console.WriteLine(j);<o:p></o:p></p>

<p class=programs>i = &amp;k;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>*i = 100;<o:p></o:p></p>

<p class=programs>Console.WriteLine(k + &quot; &quot; + j);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=DOSPROMPT>1243464<o:p></o:p></p>

<p class=DOSPROMPT>100 10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=438 height=402 id="_x0000_i1027"
src="chap15img/img2.bmp"><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=440 height=396 id="_x0000_i1028"
src="chap15img/img3.bmp"><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Whenever we create a pointer variable, int *i, we are not
stating explicitly which int i will be pointing to. Thus it can point to one
int today, another int tomorrow. This is what gives pointers their flexibility.
It can point to any int it wants to in memory. We are first initializing i to
point to j, then we are changing the value of j to 10 through the pointer. Then
i points to k in memory, and then k's value is indirectly being changed to 100
through the pointer. The first WriteLine tells us that the variable j begins at
memory location 1243468. From here the next 4 have been reserved for the
variable j. Memory for k has been allocated at 1243464. Thus, physically, k
starts first in memory from 1243464 to 67 and j from 1243468 onwards.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int<span style="mso-spacerun: yes">  </span>*i;<o:p></o:p></p>

<p class=programs>int j=1;<o:p></o:p></p>

<p class=programs>i = &amp;j;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i + &quot; &quot; + (int) &amp;i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243464 1243468<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Lets not forget that pointers are also variables and C#
allocates memory for i. An &amp; in front of any variable tells us where it
starts in memory. Thus i starts from memory location 1243468 onwards.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>long<span style="mso-spacerun: yes">  </span>*i;<o:p></o:p></p>

<p class=programs>long j=1, k = 1;<o:p></o:p></p>

<p class=programs>i = &amp;j;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>i = &amp;k;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460<o:p></o:p></p>

<p class=DOSPROMPT>1243468<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The sizeof a long is 8 bytes and the addresses printed
differ by 8 bytes.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy {<o:p></o:p></p>

<p class=programs>unsafe public void abc(){<o:p></o:p></p>

<p class=programs>byte<span style="mso-spacerun: yes">  </span>*i;<o:p></o:p></p>

<p class=programs>byte j=1, k = 1;<o:p></o:p></p>

<p class=programs>i = &amp;j;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>i = &amp;k;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468<o:p></o:p></p>

<p class=DOSPROMPT>1243472<o:p></o:p></p>

<p class=cbasetext>The only change here is that j and k are not longs but
bytes. Why are we learning all about pointers is a question you should ask
yourself. The C# documentation says very clearly that a byte occupies one
memory location. The sizeof byte will also return one. In the above output,
however, the memory locations differ by 4. The reason being that on the Pentium
Processor, if we want one memory location, we will receive a minimum of 4. That's
why, the Pentium is said to be a 32-bit processor. It will give you memory in
chunks of 4. From this knowledge, using a byte instead of a int does not
conserve memory or speed up your program. The above explanation cannot be
comprehended without the knowledge of pointers.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs </u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>byte *i; <o:p></o:p></p>

<p class=programs>i = 0; <o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(15,5): error CS0029: Cannot implicitly convert type
'int' to 'byte*'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>C# is a strongly typed language and we are not allowed to
convert a zero which is an int to a byte *, the data type of i. The only way
out is to use a cast.<o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>byte *i;char *j;int *k;long *l;<o:p></o:p></p>

<p class=programs>i = (byte *)0; j = (char *)0; k = (int *)0 ; l = (long *)0;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k + &quot; &quot; + (int)l);<o:p></o:p></p>

<p class=programs>i++;j++;k++;l++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k + &quot; &quot; + (int)l);<o:p></o:p></p>

<p class=programs>i++;j++;k++;l++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k + &quot; &quot; + (int)l);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>0 0 0 0<o:p></o:p></p>

<p class=DOSPROMPT>1 2 4 8<o:p></o:p></p>

<p class=DOSPROMPT>2 4 8 16<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A pointer to any data type is allocated four memory
locations at the time of creation. This enables pointers to store values that
range from 0 to 4 billion. The question that comes to your mind, is what is the
difference between a pointer to an int from a pointer to a long. We have
created four variables i, j, k, l. Each is a pointer to a different data type.
We have also initialized each variable to 0 and displayed their values using
the WriteLine function. We have then incremented each of them by 1. To our
surprise the pointer to an int k, increases by 4 and not by 1. The char pointer
increases by 2 and long by 8. To make sure that is not a isolated phenomena, we
increment them again. Same answer once again. They do not increase by one but
by the size of the data type they point to. The sizeof a long is 8 and thus a
pointer to a long increases by 8 and not 1. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>When we initialized l to zero, we were telling C# that a
long begins at memory location 0. This long will occupy the next 8 memory
locations, form 0 to 7. Thus when we write l++, we are telling C# to take us to
the next long in memory, which has to begins now at 8. The first difference
between pointers to different data types is that the amount the pointer value increases
is dependent upon what it is pointing to.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr(int x , int y , int z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>*p1 = 20;<o:p></o:p></p>

<p class=programs>*p2 = 30;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i ; int<span style="mso-spacerun: yes">  </span>*j ; int
*k;<o:p></o:p></p>

<p class=programs>int l=1,m=2,n=3;<o:p></o:p></p>

<p class=programs>i=&amp;l; j=&amp;m; k=&amp;n;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k); <o:p></o:p></p>

<p class=programs>pqr(l,m,n);<o:p></o:p></p>

<p class=programs>Console.WriteLine(l + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>m + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>n); }}<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243456 1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243424 1243436 1243432<o:p></o:p></p>

<p class=DOSPROMPT>1 2 3<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have created a variable i of type int in memory. It
begins at memory location 1243460. Similarly m and n start at 56 and 52
respectively. We are then calling a function pqr and passing three parameters
to it. These are being stored at memory locations 1243424, 36 and 32
respectively. When we write *p1, we are going to memory location 1243424 and
writing 20 there. This will change the value of x from 1 to 20. As variable l
begins at 1243460, its value remains unchanged. The area of memory where x, y
and z start is called the stack. Stack memory is used to pass parameters to
functions.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr(int x , int y , int z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void xyz(int x , int y , int z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i ; int<span style="mso-spacerun: yes">  </span>*j ; int
*k;<o:p></o:p></p>

<p class=programs>int l=1,m=2,n=3;<o:p></o:p></p>

<p class=programs>i=&amp;l; j=&amp;m; k=&amp;n;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k); <o:p></o:p></p>

<p class=programs>pqr(l,m,n);<o:p></o:p></p>

<p class=programs>xyz(l,m,n);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243456 1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243424 1243436 1243432<o:p></o:p></p>

<p class=DOSPROMPT>1243424 1243436 1243432<span style="mso-spacerun:
yes">         </span><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Now you will begin to comprehend the importance of pointers.
Its is an understanding of pointers that will give you a better insight into
understanding the innards of a programming language. The last two WriteLines
display the same answer as the stack memory gets reused for every function
call. The stack is an area of memory that will store parameters and variables
created in a function. Let us assume that the stack begins at memory location
100. The parameters are first pushed onto the stack and then all the local
variables are created later, but below the parameters. Remember that the stack
grows down in memory. When the function is over, the stack is moved back to
100, and the next function that gets called, reuses the same memory from 100.
Thus anything created in a function has a lifetime of the open and close braces
as the next function uses the same memory and the earlier values get
overwritten.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void xyz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int i=0,j=0,k=0;<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;i; p2 = &amp;j<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;k;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void aaa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int x=0,y=0,z=0;<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int i=0,j=0,k=0;<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;i; p2 = &amp;j<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;k;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>pqr();<o:p></o:p></p>

<p class=programs>xyz();<o:p></o:p></p>

<p class=programs>aaa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243464 1243468<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243464 1243468<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243464 1243468<o:p></o:p></p>

<p class=cbasetext><span style="mso-spacerun: yes">   </span><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The above program proves a number of points. C# reuses the
same memory for passing parameters and creating variables in functions. The
variable names are not important as they get created on the stack, at the same
place in memory.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr(int x , int y , int z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>p3++;p3++;p3++;p3++;p3++;p3++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p3); <o:p></o:p></p>

<p class=programs>*p3=20;<o:p></o:p></p>

<p class=programs>p3++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p3); <o:p></o:p></p>

<p class=programs>*p3=200;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i ; int<span style="mso-spacerun: yes">  </span>*j ; int
*k;<o:p></o:p></p>

<p class=programs>int l=1,m=2,n=3;<o:p></o:p></p>

<p class=programs>i=&amp;l; j=&amp;m; k=&amp;n;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k); <o:p></o:p></p>

<p class=programs>pqr(l,m,n);<o:p></o:p></p>

<p class=programs>Console.WriteLine(l + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>m + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>n); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243456 1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243424 1243436 1243432<o:p></o:p></p>

<p class=DOSPROMPT>1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243456<o:p></o:p></p>

<p class=DOSPROMPT>1 200 20<span style='color:red'><o:p></o:p></span></p>

<p class=cbasetext><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=cbasetext><span style='color:black'>Pointers are really unsafe. There
is a simple rule in C# which says that variables created in one function abc,
cannot be changed by another function pqr. The variables m and n begin at
memory locations 1243456 1243452 respectively. If there was some way, I could
write to these memory locations, I would be changing the values of m and n
respectively. The pointer p3 stores, where the parameter z is stored in memory
i.e. 1243432. If we can increment this pointer 6 times, 6 will actually be 24
due to pointer arithmetic, the value of p will now be 1243452 which is the
address of n in memory. Thus from one function, I can change the value of
another variable. In this case we are doing it on purpose but if I called a
function, where a pointer went haywire, my variables change and nobody knows
why the program stops working. Thus pointers are like a sharp knife, it can
save a life in the hands of a doctor but in the wrong hands it can also kill.</span><o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr(int x , int y , int z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *p1; int *p2; int *p3;<o:p></o:p></p>

<p class=programs>p1 = &amp;x; p2 = &amp;y<span style="mso-spacerun: yes"> 
</span>; p3 = &amp;z;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1<span style="mso-spacerun: yes"> 
</span>+ &quot; &quot; + (int) p2<span style="mso-spacerun: yes">  </span>+
&quot; &quot; + (int) p3); <o:p></o:p></p>

<p class=programs>int q = 1;<o:p></o:p></p>

<p class=programs>while ( q &lt;= 12 )<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>p1++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) p1 + &quot; &quot; + *p1); <o:p></o:p></p>

<p class=programs>q++;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int *i ; int<span style="mso-spacerun: yes">  </span>*j ; int
*k;<o:p></o:p></p>

<p class=programs>int l=1,m=2,n=3;<o:p></o:p></p>

<p class=programs>i=&amp;l; j=&amp;m; k=&amp;n;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) i + &quot; &quot; + (int) j + &quot;
&quot; + (int) k); <o:p></o:p></p>

<p class=programs>pqr(l,m,n);<o:p></o:p></p>

<p class=programs>Console.WriteLine(l + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>m + &quot; &quot; +<span
style="mso-spacerun: yes">  </span>n); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<span style='color:red'><o:p></o:p></span></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1243456 1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243424 1243436 1243432<o:p></o:p></p>

<p class=DOSPROMPT>1243428 47645012<o:p></o:p></p>

<p class=DOSPROMPT>1243432 3<o:p></o:p></p>

<p class=DOSPROMPT>1243436 2<o:p></o:p></p>

<p class=DOSPROMPT>1243440 0<o:p></o:p></p>

<p class=DOSPROMPT>1243444 1243508<o:p></o:p></p>

<p class=DOSPROMPT>1243448 1243544<o:p></o:p></p>

<p class=DOSPROMPT>1243452 3<o:p></o:p></p>

<p class=DOSPROMPT>1243456 2<o:p></o:p></p>

<p class=DOSPROMPT>1243460 1<o:p></o:p></p>

<p class=DOSPROMPT>1243464 1243452<o:p></o:p></p>

<p class=DOSPROMPT>1243468 1243460<o:p></o:p></p>

<p class=DOSPROMPT>1243472 1243484<o:p></o:p></p>

<p class=DOSPROMPT>1 2 3<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Would it not be a great idea to be able to display whatever
is there on the stack. Between variables there are some gaps and the above
program is displaying the contents of the stack. The variable q makes the loop
go on 12 times and each time we increment p1 by 4. P1 is pointing to x the
first parameter on the stack. Would it not aid understanding if Microsoft
explained what all it pushes on the stack. One of the most common hacking
exploits on the net is called a stack overflow.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr( int *a)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int [] a = new int[3];<o:p></o:p></p>

<p class=programs>a[0] = 10; a[1] = 2; a[2] = 30;<o:p></o:p></p>

<p class=programs>pqr(a);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(20,1): error CS1502: The best overloaded method match
for 'yyy.pqr(int*)' has some invalid arguments<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(20,5): error CS1503: Argument '1': cannot convert from
'int[]' to 'int*'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We were trying to pass an array as a parameter to a
function. Unfortunately C# has some other views.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr( int *a)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int [] a = new int[3];<o:p></o:p></p>

<p class=programs>a[0] = 10; a[1] = 2; a[2] = 30;<o:p></o:p></p>

<p class=programs>fixed ( int *i = a) pqr(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10 2 30<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The keyword fixed removed the error. An array in memory can
be moved around by C#. We would like C# to keep it fixed in memory. The keyword
fixed guarantees that C# will not move it around in RAM for the duration of the
program. The only reason C# moves objects in memory is to speed up execution of
the program. The keyword fixed as part of syntax wants the () .Within them you
can create a variable in our case i which we initialize to a C# object, an
array a. The scope or lifetime of this array is in the next statement i.e. the
invocation of function pqr. In case you have more lines you can use the {}.
Even though a now is a pointer to an int, the notation a[0] refers to the first
member. The name of an array tells us where the array starts in memory. <o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr( int *a)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>a[0] = 100 ; a[1] = 40; *(a+2) = 33;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int [] a = new int[3];<o:p></o:p></p>

<p class=programs>a[0] = 10; a[1] = 2; a[2] = 30;<o:p></o:p></p>

<p class=programs>fixed ( int *i = a) pqr(i);<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10 2 30<o:p></o:p></p>

<p class=DOSPROMPT>100 40 33<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Changing anything through a pointer changes the original.
Whenever we write a[1]= , we are changing the first member of the original
array. a[1] is only a notation, it actually get converted to *(a+1). Thus we
are changing the original members of the array. Also the array grows upward in
memory.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void pqr( int *a)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>for ( int i = 0 ; i&lt;= 2000; i++)<o:p></o:p></p>

<p class=programs>*(a+i) = i*10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int [] a = new int[3];<o:p></o:p></p>

<p class=programs>a[0] = 10; a[1] = 2; a[2] = 30;<o:p></o:p></p>

<p class=programs>fixed ( int *i = a) pqr(i);<o:p></o:p></p>

<p class=programs>Console.WriteLine(&quot;{0} {1} {2}&quot;,a[0],a[1],a[2]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Please do not run the above program as the error would be
unpredictable. The reason being that we are writing beyond the bounds of the
array. The array a created in the function abc has only 12 memory locations
allocated for it. We are writing the next 2000 * 4, 8000 memory locations. The
error on your machine will be very different form another machine. This
unpredictability is why pointer errors are hard to catch, and your boss would
thus not like you to use a pointer while programming.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i,j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa *a;aaa b;<o:p></o:p></p>

<p class=programs>b = new aaa();<o:p></o:p></p>

<p class=programs>a = (aaa *)b;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(20,10): error CS0030: Cannot convert type 'aaa' to
'aaa*'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>aaa is a structure with two members i and j. new aaa()
allocates memory for i and j. new aaa() and b are of the same data type ie aaa.
When we try to equate a and b, C# canot convert a pointer to a struct/class to
the object itself. Remember new returns not a pointer to an object but the
object itself.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i,j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa *a;aaa b;<o:p></o:p></p>

<p class=programs>b = new aaa();<o:p></o:p></p>

<p class=programs>a = &amp;b;<o:p></o:p></p>

<p class=programs>int *x;<o:p></o:p></p>

<p class=programs>x = &amp;(a-&gt;i);<o:p></o:p></p>

<p class=programs>int *y;<o:p></o:p></p>

<p class=programs>y = &amp;(a-&gt;j);<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) a + &quot; &quot; + (int)x + &quot;
&quot; + (int) y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468 1243468 1243472<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We need to take the address of where b begins in memory by
using the &amp; and equate that to a. The address of an object like aaa is of
the data type aaa *. As a now is a pointer to a structure, we have to use a
different syntax to display the members of the structure. The new way is to use
the -&gt; operator. Thus a-&gt;i refers to the member i of the structure that
looks like aaa. The variable x now stores the address of where the first member
i begins in memory. Obviously the address of the first member i and the address
of the structure will be the same and the second member will be stored 4 later.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i,j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa *a;aaa b;<o:p></o:p></p>

<p class=programs>b = new aaa();<o:p></o:p></p>

<p class=programs>a = &amp;b;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) a);<o:p></o:p></p>

<p class=programs>b = new aaa();<o:p></o:p></p>

<p class=programs>a = &amp;b;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int) a);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468<o:p></o:p></p>

<p class=DOSPROMPT>1243468<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have one object b that we have initialized twice with
new. Each time we get the same memory location as the address of b in memory
will remain the same.<o:p></o:p></p>

<p class=SubTitle><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Unions<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.i = 65536+512+3;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i + &quot; &quot; + a.j + &quot;
&quot; + a.k);<o:p></o:p></p>

<p class=programs>int *i1;short *j1;byte *k1;<o:p></o:p></p>

<p class=programs>i1 = &amp;a.i; j1 = &amp;a.j ; k1 = &amp;a.k;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine((int)i1 + &quot; &quot; + (int) j1 +
&quot; &quot; + (int) k1);<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(sizeof(yyy));<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>[StructLayout(LayoutKind.Explicit)]<o:p></o:p></p>

<p class=programs>struct yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>[FieldOffset(0)] public int i;<o:p></o:p></p>

<p class=programs>[FieldOffset(0)] public short j;<o:p></o:p></p>

<p class=programs>[FieldOffset(0)] public byte k;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>66051 515 3<o:p></o:p></p>

<p class=DOSPROMPT>1243476 1243476 1243476<o:p></o:p></p>

<p class=DOSPROMPT>4<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=214 height=157 id="_x0000_i1029"
src="chap15img/img4.bmp"></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Let us understand what a union is all about. We are printing
the addresses of i, j and k and lo and behold they are all the same. In a union
all the members begin at the same place and that is why their addresses were
similar. If we understand pointers, understanding unions then becomes a piece
of cake as we can visually see the addresses.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System.Runtime.InteropServices;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.i = 65536+512+3;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i + &quot; &quot; + a.j + &quot;
&quot; + a.k);<o:p></o:p></p>

<p class=programs>int *i1;short *j1;byte *k1;<o:p></o:p></p>

<p class=programs>i1 = &amp;a.i; j1 = &amp;a.j ; k1 = &amp;a.k;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine((int)i1 + &quot; &quot; + (int) j1 +
&quot; &quot; + (int) k1);<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(sizeof(yyy));<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>[StructLayout(LayoutKind.Explicit)]<o:p></o:p></p>

<p class=programs>struct yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>[FieldOffset(0)]<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>[FieldOffset(0)]<o:p></o:p></p>

<p class=programs>public short j;<o:p></o:p></p>

<p class=programs>[FieldOffset(10)]<o:p></o:p></p>

<p class=programs>public byte k;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>66051 515 0<o:p></o:p></p>

<p class=DOSPROMPT>1243468 1243468 1243478<o:p></o:p></p>

<p class=DOSPROMPT>11<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>short i = 512+3;<o:p></o:p></p>

<p class=programs>byte *j;<o:p></o:p></p>

<p class=programs>j = (byte *)&amp;i;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j + &quot; &quot; + i );<o:p></o:p></p>

<p class=programs>*j = 1;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>j++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j);<o:p></o:p></p>

<p class=programs>*j=1;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>j++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j);<o:p></o:p></p>

<p class=programs>*j=10;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468 515<o:p></o:p></p>

<p class=DOSPROMPT>513<o:p></o:p></p>

<p class=DOSPROMPT>1243469<o:p></o:p></p>

<p class=DOSPROMPT>257<o:p></o:p></p>

<p class=DOSPROMPT>1243470<o:p></o:p></p>

<p class=DOSPROMPT>257</p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=344 height=195 id="_x0000_i1030"
src="chap15img/img5.bmp"></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=346 height=413 id="_x0000_i1031"
src="chap15img/img6.bmp"></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=344 height=203 id="_x0000_i1032"
src="chap15img/img7.bmp"></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><img width=347 height=201 id="_x0000_i1033"
src="chap15img/img8.bmp"></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>j is a pointer to a byte. From the output, we can see that i
begins at 1243468. i is of data type short which means it takes 2 bytes. j now
contains the the address value of i i.e. 1243468. The first line proves it. The
statement *j=1 will change the bottom byte value to 1.j++ will then increment
the address value by 1, hence *j=1 will now change the top byte to 1. The last
j++ has no effect because the scope of short is only 2 btes. Hence we see no
change in the value of i.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Here, in place of the data type short, we have given an int.
<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>using System;<o:p></o:p></p>

<p class=programs>class zzz {<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy {<o:p></o:p></p>

<p class=programs>unsafe public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int i = 512+3;<o:p></o:p></p>

<p class=programs>byte *j;<o:p></o:p></p>

<p class=programs>j = (byte *)&amp;i;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j + &quot; &quot; + i );<o:p></o:p></p>

<p class=programs>*j = 1;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>j++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j);<o:p></o:p></p>

<p class=programs>*j=1;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>j++;<o:p></o:p></p>

<p class=programs>Console.WriteLine((int)j);<o:p></o:p></p>

<p class=programs>*j=10;<o:p></o:p></p>

<p class=programs>Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs style='margin-left:0in'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT style='margin-left:0in'><span style='font-size:11.0pt;
font-family:"Times New Roman"'><img width=345 height=199 id="_x0000_i1040"
src="chap15img/img9.bmp"><o:p></o:p></span></p>

<p class=DOSPROMPT style='margin-left:0in'><span style='font-size:11.0pt;
font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1243468 515<o:p></o:p></p>

<p class=DOSPROMPT>513<o:p></o:p></p>

<p class=DOSPROMPT>1243469<o:p></o:p></p>

<p class=DOSPROMPT>257<o:p></o:p></p>

<p class=DOSPROMPT>1243470<o:p></o:p></p>

<p class=DOSPROMPT>655617<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The last j++ in the series will touch the third byte, there
by replacing the 1 to 10. Hence the output changes dramatically.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap15.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:40:27 GMT -->
</html>
