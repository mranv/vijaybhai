<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap10.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:32 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap10_files/filelist.html">
<link rel=Edit-Time-Data href="chap10_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Properties and Indexers - C# The Basics - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T11:03:00Z</o:Created>
  <o:LastSaved>2001-09-27T11:04:00Z</o:LastSaved>
  <o:Pages>12</o:Pages>
  <o:Words>2601</o:Words>
  <o:Characters>14829</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>123</o:Lines>
  <o:Paragraphs>29</o:Paragraphs>
  <o:CharactersWithSpaces>18211</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:36.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;
	font-weight:normal;}
p.SubTitle, li.SubTitle, div.SubTitle
	{mso-style-name:SubTitle;
	mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:48.0pt'>10</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Properties and Indexers</h1>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Properties<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Properties are a natural extension to fields. Very few
programming languages support the notion of a property. Unlike a variable, a
property is not stored in a memory location. It is made up of functions. Thus
even though a property and a field share the same syntax a property has the
advantage that code gets called. When we initialize a variable, no code in our
class gets called. We are not able to execute any code for a variable access or
initialization at all. In the case of a property, we can execute tons of code.
This is one singular reason for the popularity of a product like Visual Basic -
the use of properties. One simple example is setting the value of a variable.
If it is through a variable, we have no control over the value used. If the
same access is through a property, the programmer has no inkling of whether it
is a property or a variable, we can build range checks to make sure that the
variable does not cross certain bounds.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Lets start by creating a simple property. A property is a
member of a class. It behaves like a variable for the user.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,12): error CS0548: ‘aa.ff’ : property or indexer must
have at least one accessor<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have tried to create a property called ff which is of
type int. We get an error because a property is used either on the left or the
right of an equal to sign. If we had created a variable ff, we would like to
write<span style="mso-spacerun: yes">  </span>a statement as gg = ff + 9. Here
ff should return some value which is of the data type int.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>int gg = a.ff + 9;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(gg);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>public int
ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
get”);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span><o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>return 12;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in get<o:p></o:p></p>

<p class=DOSPROMPT>21<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A property should have at least one accessor, in our case, a
get as we want to read the value of the property. Thus a.ff calls the get
accessor which returns an int, in this case 12. If we did not have access to
the code of the class aa, we would have assumed ff to have been a variable.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>a.ff = 19;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.ff);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
get”);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>return 12;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(value);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>19<o:p></o:p></p>

<p class=DOSPROMPT>in get<o:p></o:p></p>

<p class=DOSPROMPT>12<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A variable can also be used on the left-hand side of the
equalto sign. In this case we are writing or changing the value of the
variable. We are passing it some value. If it is a property, ff in our case,
a.ff = 19 will call the accessor set. The set accessor<span
style="mso-spacerun: yes">  </span>has a free variable available in it called
value. It gets created automatically, we do not create this variable. In our
case, this has the value 19, which we are displaying in WriteLine. Then to
display the value of the property ff, the get needs to be called again. The get
always returns the same answer as the set does not store the value of the
variable anywhere. To resolve this issue, we do the following.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>a.ff = 19;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.ff);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int f1;<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
get”);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>return f1;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
set “ + value);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>f1 = value;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in set 19<o:p></o:p></p>

<p class=DOSPROMPT>in get<o:p></o:p></p>

<p class=DOSPROMPT>19<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>To implement a property in real life, we create a public
variable which will hold the value of the property. This variable f1 will have
the same data type as the property i.e. an int in our case. In the get, we
return f1 and in the set we initialize f1 to value. This is the simplest case
possible. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The reason we use a property and not a variable is because
if we change the value of a variable/field,<span style="mso-spacerun: yes"> 
</span>then code in our class is not aware of the change. Also we have no control
over what values the variable will contain. The user can change them to
whatever he/she likes and we cannot implement range checks on the variable.
Also the user may want to associate some action with the changes in the value
of the variable. Using a property, reading or writing to the variable also can
be monitored.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>a.ff = 19;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.ff);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int f1;<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
get”);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>return f1;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0200: Property or indexer ‘aa.ff’ cannot
be assigned to — it is read only<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You are allowed to declare a property readonly by omitting
the set accessor. No one is now allowed to change the value of the property. It
now behaves as a const or readonly field.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>a.ff = 19;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int f1;<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>System.Console.WriteLine(“in
set “ + value);<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>f1 = value;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in set 19<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Theoretically, you can have a property which is write only
i.e. only with a set<span style="mso-spacerun: yes">  </span>accessor. With
set, you can change the value of ff but it is of limited use because you can
never access the value of ff. A property differs from a field by ending with
{}.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,12): error CS0102: The class ‘aa’ already contains a
definition for ‘ff’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You cannot create a property in 2 separate bits and pieces.
It has to be in one whole. This is part of the syntax. The above creates two
properties, both called ff, the first one being write only, the second, read only.
The compiler tells you that you cannot create two properties by the same name.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>private int ff;<o:p></o:p></p>

<p class=programs>public int ff {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>get {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(10,12): error CS0102: The class ‘aa’ already contains a
definition for ‘ff’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You obviously cannot have a property and variable with the
same name. The compiler would not know whether to invoke the property or the
field. They both are stored in the same namespace. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy.i = 20;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(yyy.i); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static int i<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get { <o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“get”); <o:p></o:p></p>

<p class=programs>return 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set {<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“set “ + value); <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>} <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>set 20<o:p></o:p></p>

<p class=DOSPROMPT>get<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The rules of static apply to properties also. Like variable
we access them using the class and not the instance. Everything that we have
learned about static in the past applies to properties also.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.i = 100;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>abstract class xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public abstract int i<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get ;<o:p></o:p></p>

<p class=programs>set ;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override int i {<o:p></o:p></p>

<p class=programs>get <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“get”); <o:p></o:p></p>

<p class=programs>return 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“set “ + value); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>set 100<o:p></o:p></p>

<p class=DOSPROMPT>get<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The abstract property i in class xxx carries no code at all.
The get and set accessors are simply represented by a semicolon. In the derived
class, we must implement both the get and the set accessors. If we do not use
the override keyword, it is new. We hope you have finally understood new and
override. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>abstract class xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public abstract int i<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get ;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override int i {<o:p></o:p></p>

<p class=programs>get <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(20,1): error CS0546: ‘yyy.i.set’: cannot override
because ‘xxx.i’ does not have an overridable set accessor<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In class xxx, the abstract property has only a get accessor.
In the derived class we are implementing both the get and the set. The original
never ever had a set. This is unacceptable to the compiler. Thus we have no
choice but to implement only the accessors that are present in the original. A
get accessor can be viewed as a method which returns a value but accepts no
parameters.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void i {<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(3,13): error CS0547: ‘i’ : property or indexer cannot
have void type<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>It makes no sense for an accessor to have a void type as a
variable cannot be of type void. Void literally means ‘I do not know the type’
or no type at all.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{ <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>return 10;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,2): error CS0127: Since ‘yyy.i.set’ returns void, a
return keyword must not be followed by an object expression<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A set accessor can be viewed as function which returns void
but accepts one parameter which stands for the value of the property. Thus a
set cannot return a value. If we remove the 10, we will not get an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int i {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{ <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>value = 20;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The reserved variable value in the set can be changed at
will. Though, understanding why anyone would want to do such dumb stuff is
beyond us. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int i {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>{ <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>int value; <o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,6): error CS0136: A local variable named ‘value’
cannot be declared in this scope because it would give a different meaning to
‘value’, which is already used in a ‘parent or current’ scope to denote
something else<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We cannot however create a variable value as it will clash
with the variable value which is already present by default in the set.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.i = 10;<o:p></o:p></p>

<p class=programs>xxx b = new xxx();<o:p></o:p></p>

<p class=programs>((yyy)b).i = 20;<o:p></o:p></p>

<p class=programs>b.i = 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>set {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span><span
style="mso-spacerun: yes">    </span>get {<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span><span
style="mso-spacerun: yes">     </span>return 10;<o:p></o:p></p>

<p class=programs><span style='mso-tab-count:1'>            </span><span
style="mso-spacerun: yes">     </span>}<o:p></o:p></p>

<p class=programs>} }<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,1): error CS0200: Property or indexer ‘xxx.i’ cannot
be assigned to — it is read only<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In the class yyy, the property i has only the set accessor.
In the class xxx which derives from yyy, we have implemented only the get
accessor. The property i in class xxx hides the i of yyy. They do not add up.
What we are trying to say is that both these properties are independent of each
other. What we had thought C# would have done is, taken the set from one class
and added it to the second. However, that does not make sense. It treats them
independently. If we want to use the property of the class yyy, then we need to
explicitly cast it as we have done for b. Thus the property i of class yyy gets
hidden but can be accessed.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A property is not necessarily slower than a variable. A
variable access normally initializes some memory, whereas a property executes a
method. This is not necessarily slower as at times, C# will rewrite your
property methods to memory accesses. This is called inlining of code. Except
for minor differences, all that we mentioned about virtual, abstract and new
apply also to a property. The difference is, if the original property has a get
and a set, the derived class will only implement a set or a get.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Indexers <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An indexer lets us access members of a class as if it were
an array.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a[1] = 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy {<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0021: Cannot apply indexing with [] to an
expression of type ‘yyy’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have created an object a that looks like yyy. The object
a, in no sense of the word is an array. We are assuming that a is an array and
we’ve used the array syntax a[], hence it gives us an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a[1] = 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int this[int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set { <o:p></o:p></p>

<p class=programs><span style="mso-spacerun: yes">     
</span>System.Console.WriteLine(“in get “ + value + “ “ + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in get 10 1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We’ve added a few lines to have the array notation work with
an object that looks like yyy. To implement indexers, we need to create a
special property called this. This is a reserved word. As of now, we have a
parameter i (an int) in the square brackets. When we did properties earlier,we
learnt that a set gets called whenever we want to initialize or set a<span
style="mso-spacerun: yes">  </span>variable. Within the set accessor we have a
special variable called value which stores the value passed to the set, in this
case 10. The variable i will hold the value 1 as the array parameter is 1. <o:p></o:p></p>

<p class=cbasetext>This is how we implement arrays when there are none.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a[1]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int this[int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“in get “ + value + “ “ + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>get <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“in set “ + i);<o:p></o:p></p>

<p class=programs>return 23;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in set 1<o:p></o:p></p>

<p class=DOSPROMPT>23<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The rules binding properties are applicabe to indexers too.
When you want to read the value of a[1], the get gets called. The major
difference between properties and indexers is that when you implement the code
for indexers you have to understand that the get and set get called with a
variable which is the array parameter value. The code will have to understand
array simulation.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a[“hi”] = 30;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a[“hi”]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int z;<o:p></o:p></p>

<p class=programs>public int this[string i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“in get “ + value + “ “ + i);<o:p></o:p></p>

<p class=programs>z = value;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>get <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“in set “ + i);<o:p></o:p></p>

<p class=programs>return z;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>In get 30 hi<o:p></o:p></p>

<p class=DOSPROMPT>In set hi<o:p></o:p></p>

<p class=DOSPROMPT>30<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The this property has a return value, in this case, an int.
Also the [] brackets can contain data types other than an int. In this case a
string. The string i<span style="mso-spacerun: yes">  </span>has a value hi as
that is what we passed in the array brackets. You can have two this’s in your
class. You have to decide what data type to use in the array brackets. An
indexer is very useful when you have a database object and you want to access
the data in the fields using a notation [“fieldname”] <o:p></o:p></p>

<p class=cbasetext>Indexers follow the same concepts of virtual, new, override
etc.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a[1] = 10;<o:p></o:p></p>

<p class=programs>a[“one”] = 10;<o:p></o:p></p>

<p class=programs>a[“hi”,2] = 30;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int this [ int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“one int “+ i + “ “ + value);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int this [ string i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“one string “+ i + “ “ + value);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int this [ string i, int j]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“one string and int “+ i + “ “ + j +
“ “ + value);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>one int 1 10<o:p></o:p></p>

<p class=DOSPROMPT>one string one 10<o:p></o:p></p>

<p class=DOSPROMPT>one string and int hi 2 30<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The signature of an indexer is the number and types of
formal parameters. The return value and the names of the parameters do not
contribute to the indexers signature. Thus we have overloaded the indexers to
take an int, string or a string int combination. Each time a different function
gets called. The point to understand is that all the indexers have to return
the same data type, in our case int. The same rules that apply to function
overloading apply here also. Functions cannot differ only by return values. We
are sure that for indexers in the next version, C# should/must make an
exception.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A property is identified by its name, an indexer by its
signature. There is no concept of property overloading in C#.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static int this [ int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,19): error CS0106: The modifier ‘static’ is not valid
for this item<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A property can be both an instance member which is the
default or static. An indexer unfortunately can only be an instance member and
not static. God alone knows why this discrimination against indexers. Once
again no rational reason for the above error. Obviously you cannot create a
variable with the same name as that of the parameter passed in the indexer.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx a = new xxx();<o:p></o:p></p>

<p class=programs>a[2] = 20;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a[2]);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public virtual int this [ int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy get “ + i);<o:p></o:p></p>

<p class=programs>return 20;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy set “ + value + “ “ + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override int this [ int i]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int p = base[i];<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“xxx get “ + i + “ “ + p);<o:p></o:p></p>

<p class=programs>return 200;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“xxx set “ + value + “ “ + i);<o:p></o:p></p>

<p class=programs>base[i] = value;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>xxx set 20 2<o:p></o:p></p>

<p class=DOSPROMPT>yyy set 20 2<o:p></o:p></p>

<p class=DOSPROMPT>yyy get 2<o:p></o:p></p>

<p class=DOSPROMPT>xxx get 2 20<o:p></o:p></p>

<p class=DOSPROMPT>200<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The above example deals with calling the indexers of the
base class. At times when we are overriding code in the derived class, we would
like to call the original indexer in the base class first. The first rule that
we have to adhere to is that the indexer in the base class must be declared
virtual. In the derived class, we are now declaring it with the modifier
override. Same rules as above. In the set accessor, we have to call the
original as base[i], where i is the index to the indexer. Also we need to pass
it the value to initialize itself. This is stored in the variable value. This
a[2] in Main gets replaced by base[2] in the set. In get the reverse takes
place. Here we need to place base[i] on the right of the equalto sign, the
original get will return a value, in this case 20, which we are storing in a
variable p. What we do with p as well as the value from the get is our
business.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int this [ byte i , string j]<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>get<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>return 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>int get_Item(byte i,string j)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>return 20<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void set_Item(byte i,string j , int value)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><span style='font-size:11.0pt;font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0111: Class ‘yyy’ already defines a
member called ‘get_Item’ with the same parameter types<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,1): error CS0111: Class ‘yyy’ already defines a
member called ‘set_Item’ with the same parameter types<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Like a property, an indexer also gets a name change. If
people can get their bodies pierced then why cannot a indexer get converted to
a series of functions starting with get? For a get, the parameters are the same
as we pass to an indexer. It has a return value and the type of the indexer.
Also the set has one more added parameter and that is the free variable value.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap10.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:34 GMT -->
</html>
