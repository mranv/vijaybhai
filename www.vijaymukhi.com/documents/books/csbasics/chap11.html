<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap11.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:34 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap11_files/filelist.html">
<link rel=Edit-Time-Data href="chap11_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Interfaces and Structures - C# The Basics - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T11:04:00Z</o:Created>
  <o:LastSaved>2001-09-27T11:05:00Z</o:LastSaved>
  <o:Pages>33</o:Pages>
  <o:Words>7397</o:Words>
  <o:Characters>42164</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>351</o:Lines>
  <o:Paragraphs>84</o:Paragraphs>
  <o:CharactersWithSpaces>51780</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:36.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;
	font-weight:normal;}
p.SubTitle, li.SubTitle, div.SubTitle
	{mso-style-name:SubTitle;
	mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:48.0pt'>11</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Interfaces and Structures</h1>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Constructors Revisited <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A constructor is used to initialize the instance of a class
as explained earlier. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in main&quot;);<o:p></o:p></p>

<p class=programs>bb a = new bb();<o:p></o:p></p>

<p class=programs>bb b = new bb(10);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public aa(int i) <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot; + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class bb : aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public bb() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public bb(int i) <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot; + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in main<o:p></o:p></p>

<p class=DOSPROMPT>in const aa<o:p></o:p></p>

<p class=DOSPROMPT>in const bb<o:p></o:p></p>

<p class=DOSPROMPT>in const aa<o:p></o:p></p>

<p class=DOSPROMPT>in const bb10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Class aa is the base class. It consists of two constructors.
One that takes no parameters and the other that takes an int as a parameter.
Class bb is derived from class aa, i.e. aa is the base class, bb the derived
class. When we create an object like bb, the compiler does not execute the code
for the constructor but instead asks the constructor which constructor of the
base class to execute first. As we haven't stated this, by default, the
constructor with no parameters get executed. Remember<span style="mso-spacerun:
yes">  </span>it is the base class constructor which gets executed first and
the derived class constructor specifies which base class constructor to call
first. In the second case, even though we are calling the constructor with a
parameter, the constructor with no parameters in the base class gets called and
not the one with one int as a parameter.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in main&quot;);<o:p></o:p></p>

<p class=programs>bb a = new bb();<o:p></o:p></p>

<p class=programs>bb b = new bb(10);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public aa(int i) <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot; + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class bb : aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public bb() : base() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public bb(int i) : base(i)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot; + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in main<o:p></o:p></p>

<p class=DOSPROMPT>in const aa<o:p></o:p></p>

<p class=DOSPROMPT>in const bb<o:p></o:p></p>

<p class=DOSPROMPT>in const aa10<o:p></o:p></p>

<p class=DOSPROMPT>in const bb10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>If we do not specify which constructor of the base class to
call, C# by default calls the constructor with no parameters. Which means that
C# rewrites our code . When we write bb(), it gets rewritten as bb() : base().
Base is a reserved word. It means call the constructor of the base class with
no parameters. For the second constructor, bb(int i), the line gets rewritten
to bb(int i) : base(). We now want to call the constructor with one int and
hence we write bb(int i) : base(i). That is why the constructor with one int
gets called. We have the option to decide which constructor of the base class
we would like to call.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in main&quot;);<o:p></o:p></p>

<p class=programs>bb a = new bb();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public aa(int i) <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const aa&quot; + i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class bb : aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public bb() : this(20) <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public bb(int i) : base(i)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in const bb&quot; + i); } }<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>in main<o:p></o:p></p>

<p class=DOSPROMPT>in const aa20<o:p></o:p></p>

<p class=DOSPROMPT>in const bb20<o:p></o:p></p>

<p class=DOSPROMPT>in const bb<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A constructor gets called at the time of creation of the
object. At the line, new bb(), the compiler asks the constructor of bb as to
which constructor of the base class aa to call. Here he was told that the
answer lies with this(20). this, like base, is a reserved word. It means call a
constructor of the same class and not the base class. Therefore the compiler
now asks the one constructor of the derived class bb which constructor of the
base class to call. bb(int i) : base(i) tells the compiler to execute the one
int constructor of aa. This is the first constructor that gets called. Then the
one int constructor of bb gets called and finally the one who started it all,
the no parameter constructor of bb. Thus, two derived class constructors get
called instead of one.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;in main&quot;);<o:p></o:p></p>

<p class=programs>aa a = new aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>private aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,8): error CS0122: 'aa.aa()' is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>When you create a constructor which is private, you cannot
create an object that looks like aa. Thus aa should only contain static
members.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>private aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class bb : aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,14): error CS0122: 'aa.aa()' is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Nor can any class derive from aa. Thus no one can
instantiate an object that looks like aa or derive from it as the constructor
has been made private.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(aa.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>private aa() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>static public int i = 20;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>20<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You can however use all the static variables in aa<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>xxx() : base( this.i)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(16,15): error CS0027: Keyword this is not available in
the current context<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Base is called a constructor initializer. When base gets
called, the instance or the object has not yet been created. Ergo, this is not
available here as this refers to the current object. In the constructor,
however, this can be freely used.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The values of variables in a class are initialized to their
default values as per their<span style="mso-spacerun: yes">  </span>data types
before the constructor gets called.<span style="mso-spacerun: yes"> 
</span>Thus, in the constructor they have their default values as shown below.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public bool j;<o:p></o:p></p>

<p class=programs>public yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i+&quot; &quot; + j);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>0 False<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Here as before, the first line of code in the constructor
gets executed.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx a = new xxx();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i = 10;<o:p></o:p></p>

<p class=programs>public yyy(int j)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>i = j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public xxx() : base(100)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(base.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=DOSPROMPT>100<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Calling the base class constructor is like inserting all the
code of the one int constructor i.e. yyy(int j), in the constructor of class
xxx. We are also allowed to access members of the base class after the
constructor gets called. Also, first the variable i gets initialized to 10 or
the default value of int. Then we change it to 100 and in the constructor of
xxx, we will see a value of 100.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx a = new xxx();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public virtual void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int x = 10;<o:p></o:p></p>

<p class=programs>public xxx()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x);<o:p></o:p></p>

<p class=programs>x = 100;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public override void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=DOSPROMPT>100<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have already confessed a million times in the past that
we have copied ideas from anyone and everyone, specially from the
documentation. In this specific case, we wanted to demonstrate that first the
variables are initialized. Thus in class xxx, the int x is initialized to 10.
Then the base class constructor of yyy gets called. The value of x in class yyy
should be 10. But what guarantee can we give you as we are not able to print
the value of x in an object of a class derived from the base class. Very simple.
We call a virtual function abc from class yyy and override it in class xxx. The
abc of class xxx prints the value of x as they belong to the same class and the
output is 10. Viola and thank you Mr. Documentation for the above thought and
many more such ideas. Once all code in the yyy constructor is executed, the
first line in xxx constructor will get executed which will print the value of x
as 10. x is then initialized to 100, hence we see 100 as the new value of x,
displayed on the screen.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static zzz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;zzz&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;main&quot;);<o:p></o:p></p>

<p class=programs>new aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>static aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>zzz<o:p></o:p></p>

<p class=DOSPROMPT>main<o:p></o:p></p>

<p class=DOSPROMPT>static aa<o:p></o:p></p>

<p class=DOSPROMPT>aa<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>and if we comment new aa() then the resulting output reads
as follows.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>zzz<o:p></o:p></p>

<p class=DOSPROMPT>main<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A static constructor gets called before any other
constructors.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static zzz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;zzz&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;main&quot;);<o:p></o:p></p>

<p class=programs>aa.a();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void a()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>static aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static aa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>zzz<o:p></o:p></p>

<p class=DOSPROMPT>main<o:p></o:p></p>

<p class=DOSPROMPT>static aa<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>If you try to access any static member of a class or
whenever you instantiate an object, the static constructor gets called. A
constructor is not inherited by the derived class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A class is loaded in memory before any instance of the class
is created or its static members accessed. A class can only be loaded once and
that too before its derived class is loaded. The static constructor is called
at the time of loading the class. Like other constructors, a static constructor
cannot be explicitly called. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx.pqr(); <o:p></o:p></p>

<p class=programs>yyy.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy {<o:p></o:p></p>

<p class=programs>static yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;abc yyy&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx {<o:p></o:p></p>

<p class=programs>static xxx()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static xxx&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;pqr xxx&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>static xxx<o:p></o:p></p>

<p class=DOSPROMPT>pqr xxx<o:p></o:p></p>

<p class=DOSPROMPT>static yyy<o:p></o:p></p>

<p class=DOSPROMPT>abc yyy<o:p></o:p></p>

<p class=cbasetext>Do not believe the above results as if you run them on your
machine, your mileage may wary. This is because C# does mandate the order of
loading of classes and thus the order of execution of the static constructors.
On your machine if the yyy constructor gets executed first, do not panic. Blame
it on your destiny.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy.abc();<o:p></o:p></p>

<p class=programs>xxx.pqr(); <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static xxx()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static xxx&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;pqr xxx&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;abc yyy&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>static yyy<o:p></o:p></p>

<p class=DOSPROMPT>abc yyy<o:p></o:p></p>

<p class=DOSPROMPT>static xxx<o:p></o:p></p>

<p class=DOSPROMPT>pqr xxx<o:p></o:p></p>

<p class=DOSPROMPT><span style='color:red'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=cbasetext><span style='color:black'>We have made only one small change
in the above program. We have derived the class yyy from xxx. Since the
functions in each class are marked static, the program behaves in the same
manner as before.The above order of calls remains the same. If an object of the
type is created, then the output will change. The reason being that before the
object of type yyy is created, xxx must be loaded. Hence the constructors will
be called first.</span><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static int x = yyy.y + 2;<o:p></o:p></p>

<p class=programs>static zzz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static zzz &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>x = 500;<o:p></o:p></p>

<p class=programs>yyy.y = 600;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static zzz &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;main &quot;+ zzz.x + &quot;
&quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>y = 10;<o:p></o:p></p>

<p class=programs>zzz.x = 200;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static int y = zzz.x + 3; }<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>static yyy 0 3<o:p></o:p></p>

<p class=DOSPROMPT>static yyy 200 10<o:p></o:p></p>

<p class=DOSPROMPT>static zzz 12 10<o:p></o:p></p>

<p class=DOSPROMPT>static zzz 500 600<o:p></o:p></p>

<p class=DOSPROMPT>main 500 600<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Difficult code to understand and follow. C# first tries to
load class zzz in memory as it contains the function Main. Unfortunately it
realizes that it has to first initialize the variable x before calling the
static constructor of zzz. It first initializes x to 0. Now note that this
initialization of x to zero is extremely significant for our understanding. To
get the new value of x, C# now needs the value of the variable y from the class
yyy. Before it can call the static constructor of yyy it must initialize the
variable y. It makes sure that y's value is first set to zero. It then computes
the value of zzz.x which is zero as stated above. We are yet left hanging in
class zzz at the line x = . As zzz.x is zero, the value of y is 0 + 3 i.e. 3.
This completes the initialization of all the variables in the class. All this
happens first. Thus the static constructor of class yyy shows the value of the
variable x as 0 and that of variable y as 3. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>But hold on, the fun is yet to begin.<span
style="mso-spacerun: yes">  </span>In the static constructor, we now initialize
y to 10 and the x of zzz to 200. The next WriteLine confirms that our
initializations actually were carried out. Then we go back to class zzz. Here
we come back to the initialization of the static variable x. As yyy.y is now
10<span style="mso-spacerun: yes">  </span>since we changed it in the static
constructor of yyy, the value of x is 10 + 2 i.e. 12. This overrides the value
of x which we changed to 200 in the static constructor yyy. Now C# calls the
static constructor of zzz as it has finished all the variable initializations.
Thus the first WriteLine displays 12 and 10. We are now changing both x and y
and they display the same values in the constructor and in Main. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static int x = yyy.y + 2;<o:p></o:p></p>

<p class=programs>static zzz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static zzz &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>x = 500;<o:p></o:p></p>

<p class=programs>yyy.y = 600;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static zzz &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static yyy()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>y = 10;<o:p></o:p></p>

<p class=programs>zzz.x = 200;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;static yyy &quot; + zzz.x +
&quot; &quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static int y = zzz.x + 3;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;main &quot;+ zzz.x + &quot;
&quot; + yyy.y);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>static zzz 2 0<o:p></o:p></p>

<p class=DOSPROMPT>static zzz 500 600<o:p></o:p></p>

<p class=DOSPROMPT>static yyy 500 503<o:p></o:p></p>

<p class=DOSPROMPT>static yyy 200 10<o:p></o:p></p>

<p class=DOSPROMPT>main 200 10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The above program adds a small twist. It bowls what in
cricket parlance is called a googly. We simply bring Main from the class zzz to
the class yyy. Now C# as usual first starts at the class containing Main which
now happens to be yyy and not zzz. Here it has to first initialize all the
variables in class yyy. We have only one. It starts by setting y to zero and
runs to the class zzz to fetch the value of x. x now become 0 + 2 i.e. 2. Then
in the static constructor, we are displaying the relevant values of x and y. In
the static constructor of class zzz, we are changing x and y to 500 and 600
respectively and displaying the values. When we move back to class yyy,
however, y gets<span style="mso-spacerun: yes">  </span>a new value of 503 as x
is 500. y loses its value of 600 that was initialized in zzz, hence you see 500
and 503. The rest remains the same as explained in the earlier example.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Interfaces <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An interface is simply a collection of function prototypes.
Like we derive a class from another, so also we could derive from an interface.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,7): error CS0535: 'yyy' does not implement interface
member 'ddd.a1()'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,7): error CS0535: 'yyy' does not implement interface
member 'ddd.a2()'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have just created an interface called ddd by using a new
keyword interface in place of a class. Our interface ddd has two function
prototypes, a1 and a2. We can derive from our interface ddd like we derived
from a class. The difference is that an interface has no code, only function
prototypes. Whenever we derive from an interface, we have to implement the code
or body of the function. A class gives you lots of free code, an interface does
not. The error is generated as we have not given the code for a1 and a2 in yyy<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>d.a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;yyy a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2() {<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;yyy a2&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>yyy a1<o:p></o:p></p>

<p class=DOSPROMPT>yyy a2<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We get no errors because we have now implemented the code of
a1 and a2. Looks wise we do no know whether ddd is a class or an interface as
the syntax at the time of derivation is the same. d is an object that looks
like an interface which is syntactically correct. d can be equated to a yyy as
a yyy is a yyy + a ddd. We can, by only using d, call members of a ddd.<o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa a ;<o:p></o:p></p>

<p class=programs>a = new aaa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,5): error CS0144: Cannot create an instance of the
abstract class or interface 'aaa'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Even though an interface aaa is empty, we cannot write the
keyword new in front of it. An interface contains no code and thus cannot be
instantiated. However we are allowed to declare objects that look like an
interface. Therefore, in this case, the line aaa a, does not flag an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,6): error CS0531: 'aaa.a1()': interface members
cannot have a definition<o:p></o:p></p>

<p class=cbasetext>Reiterating, an interface can only contain function
prototypes, no code at all. The functions cannot have a definition.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class vvv<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : xxx,vvv<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,17): error CS0527: 'vvv' : type in interface list is
not an interface<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>C# does not support multiple inheritance. We can derive from
a single class only at one point in time.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>d.a1(); d.a2();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>a.a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a2&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(19,13): error CS0106: The modifier 'public' is not
valid for this item<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You are not allowed to use the modifier public for a
function which has qualified its<span style="mso-spacerun: yes">  </span>name
with that of the interface.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,13): error CS0106: The modifier 'public' is not valid
for this item<o:p></o:p></p>

<p class=cbasetext>Interface members are public by default. The access
modifiers are not allowed here. All the other access modifier rules remain the
same as that from classes. The rules in classes stated that the base class must
be at least as accessible as the derived class. Replace the word class with
interface and you will not be sorry.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>d.a1(); d.a2();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>a.a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a2&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(8,1): error CS0117: 'yyy' does not contain a definition
for 'a1'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The reason we get an error is because we created the
function a1 in yyy as ddd.a1 and not a1. By doing this, we were telling C# that
only objects that look like ddd are allowed access to a1. Even an object that
looks like yyy is not allowed to access a1. Comment out line number 8 i.e. a.a1
and all works fine as follows<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>eee e = new yyy();<o:p></o:p></p>

<p class=programs>a.a1(); a.a2();<o:p></o:p></p>

<p class=programs>d.a1();<o:p></o:p></p>

<p class=programs>e.a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd , eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a2&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Here we are doing something that just cannot be done with
classes. We are deriving from two interfaces ddd and eee at the same time. Each
has one function prototype a1 and a2 respectively. Using a which looks like yyy
we can call both a1 and a2 but with d that looks like ddd we can only call a1.
Similarly, with e only a2 can be called.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>eee e = new yyy();<o:p></o:p></p>

<p class=programs>a.a1(); <o:p></o:p></p>

<p class=programs>d.a1();<o:p></o:p></p>

<p class=programs>e.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd , eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The two interfaces share the same function name a1. We do
not get an error but yet things do not seem right. Both<span
style="mso-spacerun: yes">  </span>d and e call the same a1 and there is only
one implementation of the function a1. We would like to have two a1's but we
cannot have the same function defined twice in a class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>ddd d = new yyy();<o:p></o:p></p>

<p class=programs>eee e = new yyy();<o:p></o:p></p>

<p class=programs>d.a1();<o:p></o:p></p>

<p class=programs>e.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd , eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;ddd a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void eee.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;eee a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>ddd a1<o:p></o:p></p>

<p class=DOSPROMPT>eee a1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We did what we had explained earlier. We prefaced<span
style="mso-spacerun: yes">  </span>the name of the function with the name of
the interface. Then we removed the modifier public and the object a which
looked like yyy. Now each interface has its own copy of a1 to be called. ddd.a1
is called the explicit interface member name.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd , eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;ddd a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void eee.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;eee a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0117: 'yyy' does not contain a definition
for 'a1'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The reason we removed a was that once we have an explicit
interface member, we cannot access it through the class, it is done only
through the interface. This make a lot of sense as there are two functions of
the same name, and C# does not know which one it should call. By prefacing the
functions<span style="mso-spacerun: yes">  </span>with the names of the
interface, we are making them part of the interface and not the class. In a
sense they are private to the class. As there is no function by the name of a1
in class yyy, we see the above error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface eee<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void eee.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(21,6): error CS0540: 'yyy.eee.a1()': containing class
does not implement interface 'eee'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We get an error as class yyy is derived only from interface
ddd. Thus we cannot use eee.a1() as interface eee is not a base interface for
class yyy.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy : ddd <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void ddd.a1()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(19,6): error CS0540: 'xxx.ddd.a1()': containing class
does not implement interface 'ddd'<o:p></o:p></p>

<p class=cbasetext>The key concept earlier was that we could only use the name
of an interface explicitly if it was categorically stated as a base class.
Anything indirect would not do. Here class yyy is derived from interface ddd
and thus we can use the form ddd.a1. However even though class xxx is derived
from class yyy and thus also from interface ddd, we are not allowed to write
ddd.a1 as interface ddd is not explicitly stated in the derivation list of
class xxx.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An interface defines a contract and can only contain four entities
viz<span style="mso-spacerun: yes">  </span>methods, properties, events and
indexers. An interface thus cannot contain constants, fields, operators,
constructors, destructors, static constructors, or types. Also an interface
cannot contain static members of any kind. The modifiers abstract, public,
protected, internal, private, virtual, override are disallowed as they make no
sense in this context.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public delegate void d1();<o:p></o:p></p>

<p class=programs>public interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1(string s);<o:p></o:p></p>

<p class=programs>int a2 <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>get; set ; <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>event d1 ddd;<o:p></o:p></p>

<p class=programs>string this[int i] <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>get; set;<o:p></o:p></p>

<p class=programs><span style="mso-spacerun: yes"> </span>} }<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The above example demonstrates the four entities an
interface can contain. Anything else will flag an error.<o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>ccc c = new ccc();<o:p></o:p></p>

<p class=programs>aaa a = c;<o:p></o:p></p>

<p class=programs>bbb b = c;<o:p></o:p></p>

<p class=programs>c.a1();c.a2();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>b.a1();b.a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class ccc : bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;a2&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a1<o:p></o:p></p>

<p class=DOSPROMPT>a2<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An interface can also, like a class, inherit from one or
more interfaces. In this case bbb as an interface, can inherit from aaa. The
class ccc<span style="mso-spacerun: yes">  </span>inherits from interface bbb
and and thus interface aaa has to implement functions a1 and a2. The object c
not only looks like a ccc but also looks like an aaa and bbb. Thus equating
them does not give an error. The reverse, however, is not true. It will
obviously flag an error. However a can only access functions from the interface
it belongs to, in this case a1 and b can access a1 and a2. b cannot access
members from class ccc even though a, b, and c have the same values. Whenever
an interface derives from another it is called an explicit base interface. Like
classes, circular definitions are not permitted. In fact nowhere in the C#
programming language are we permitted to have circular definitions.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An interface also creates a new type and as in classes,
methods must have their own unique signatures. Properties and methods cannot
have similar names.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Warning<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,6): warning CS0108: The keyword new is required on
'bbb.a1()' because it hides inherited member 'aaa.a1()'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Like classes if interfaces derive from each other, there is
a possibility that they may contain the same function signatures. Thus we get a
warning which can be removed by adding the keyword new as follows.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>new void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The point to be stressed here is that the keyword new really
does not do much, other than remove the warning. This is because the
implementation of the interface is done in the class. There, we will have only
one implementation of function a1 and not two, one for aaa and the other for
bbb. At one level, from the point of view of the class which derives from
interface bbb, it will see only one function in it, not two. All that we are
doing is hiding the base interface member.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void abc(ccc c)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>c.aa(1);<o:p></o:p></p>

<p class=programs>((bbb)c).aa(1);<o:p></o:p></p>

<p class=programs>((aaa)c).aa(1);<o:p></o:p></p>

<p class=programs>c.aa = 2;<o:p></o:p></p>

<p class=programs>((aaa)c).aa = 3;<o:p></o:p></p>

<p class=programs>((bbb)c).aa = 3;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int aa <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>get; set;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aa(int i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ccc : aaa , bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(8,1): error CS0229: Ambiguity between 'aaa.aa' and
'bbb.aa(int)'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(10,10): error CS0118: 'aaa.aa' denotes a 'property'
where a 'method' was expected<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,1): error CS0229: Ambiguity between 'aaa.aa' and
'bbb.aa(int)'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,10): error CS0654: Method 'bbb.aa(int)' referenced
without parentheses<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Interface aaa has only one member, a property called aa,
whereas interface bbb has one function called aa. The interface ccc does not
give us an error in spite of the fact that we have a property and a function
with the same name. In the function abc, we are passing c, an object that looks
like ccc. The line c.aa(1) gives us an error as we have a property and a
function called aa. C# gets confused whether it is the property or the function
we are referring to. In our humble opinion, we could only be referring to the
function as per the syntax, but you don't argue with a compiler. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In the second case c.aa = 2 also flags an error due to the
name confusion. In this case also, we could only be referring to a property.
The only way out is to cast. The second cast in each case gives an error as the
syntax for calling a function and property is different. Normally, to cast, we
need to give two sets of brackets.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A cast incurs no run time costs i.e.,<span
style="mso-spacerun: yes">  </span>it does not slow down the program. All that
a cast does in the above case is lowers the pointer from a ccc to aaa or bbb at
compile time. In an earlier example, we spoke of functions from two interfaces
having similar names. The same rules stated there apply here also.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void abc(ccc c)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>c.aa(1);<o:p></o:p></p>

<p class=programs>c.aa((byte)1);<o:p></o:p></p>

<p class=programs>((aaa)c).aa(1);<o:p></o:p></p>

<p class=programs>((bbb)c).aa(1);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aa(byte i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aa(short i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ccc : aaa , bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(8,1): error CS0121: The call is ambiguous between the
following methods or properties: 'bbb.aa(short)' and 'aaa.aa(byte)'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,1): error CS0121: The call is ambiguous between the
following methods or properties: 'bbb.aa(short)' and 'aaa.aa(byte)'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have a similar problem again. c.aa(1) does not know which
function aa to call. C# could convert the 1 an int, either to a short or a
byte. Thus the ambiguity. Even if we cast the 1 to a byte, for some reason, C#
yet gives us an error. The only way out is like what we did earlier, explicitly
cast your way out of trouble. When we cast, we are restricting ourselves to
only one method and thus no ambiguity.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>new void aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ccc : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void cc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd : bbb , ccc<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class eee : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(22,7): error CS0535: 'eee' does not implement interface
member 'bbb.aa()'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(22,7): error CS0535: 'eee' does not implement interface
member 'ccc.cc()'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(22,7): error CS0535: 'eee' does not implement interface
member 'aaa.aa()'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The interface aaa has one function aa. The interface bbb is
derived from aaa and also has one function called aa. The keyword new informs
the C# compiler that, it has hidden or has nothing to do with the function aa
in interface aaa. Remember in interfaces, we cannot write any code. The
interface ccc also derives from aaa but does not have a function called aa.
Then we are creating another interface ddd which derives from both bbb and ccc.
The class eee is then derived from interface ddd.<span style="mso-spacerun:
yes">  </span>We get three errors as we have to implement three functions in
class eee. The interface ccc brings in two functions. One cc and the other aa
from interface aa. The interface bbb has only one function, aa which is
different from the aa which is present in interface aaa, thanks to the keyword
new which is optional.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa a = new eee();<o:p></o:p></p>

<p class=programs>a.aa();<o:p></o:p></p>

<p class=programs>bbb b = new eee();<o:p></o:p></p>

<p class=programs>b.aa();<o:p></o:p></p>

<p class=programs>ccc c = new eee();<o:p></o:p></p>

<p class=programs>c.aa();<o:p></o:p></p>

<p class=programs>ddd d = new eee();<o:p></o:p></p>

<p class=programs>d.aa();<o:p></o:p></p>

<p class=programs>eee e = new eee();<o:p></o:p></p>

<p class=programs>//e.aa();<o:p></o:p></p>

<p class=programs>((aaa)d).aa();<o:p></o:p></p>

<p class=programs>((bbb)d).aa();<o:p></o:p></p>

<p class=programs>((ccc)d).aa();<o:p></o:p></p>

<p class=programs>((ddd)d).aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>new void aa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ccc : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void cc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ddd : bbb , ccc<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class eee : ddd<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aaa.aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa aaa&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void bbb.aa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa bbb&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void cc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;cc&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>aa aaa<o:p></o:p></p>

<p class=DOSPROMPT>aa bbb<o:p></o:p></p>

<p class=DOSPROMPT>aa aaa<o:p></o:p></p>

<p class=DOSPROMPT>aa bbb<o:p></o:p></p>

<p class=DOSPROMPT>aa aaa<o:p></o:p></p>

<p class=DOSPROMPT>aa bbb<o:p></o:p></p>

<p class=DOSPROMPT>aa aaa<o:p></o:p></p>

<p class=DOSPROMPT>aa bbb<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>With or without the keyword new, the output remains the
same. By adding the keyword new, all that we have achieved is removal of the
warning. Lets explain the above program step by step. <o:p></o:p></p>

<p class=cbasetext>We have implemented the three functions that class eee
needed. We could have implemented only one aa, and then in every case that one
aa, would have been called. In this case we need two aa functions. One for the
interface aaa and the other for the interface bbb. As we need a separate
function aa for each interface we will land up having two of them. Thus we need
to preface them with the name of the interface.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We are creating objects that look like all our interfaces
and initializing them to an object that looks like class eee. The object a that
looks like interface aaa,<span style="mso-spacerun: yes">  </span>will
obviously call the aa of interface aaa. The object b that looks like interface
bbb will call the aa of interface aaa implemented in class eee. The object c,
that looks like ccc is derived from interface aaa and thus it will call the
function aa of interface aaa. All of this is obvious. Now d looks like ddd
which is derived from ccc and bbb. The reason it will call the aa of bbb and
not of aaa is because we have asked it to hide the function aa of interface
aaa. Once a function is hidden, it will remain hidden forever in all the access
paths. Thus function aa of interface bbb hides the function aa of interface aaa
even in interface ccc. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The casting gives us the same answer as above. In the first
case, cast d, a ddd looks alike to an aaa. Thus the aa from aaa gets called. In
the second case it calls the aa of bbb. Just like before, when we cast c to a
ccc, it calls the aa form aaa . Now we cast c to a ddd, it can call either the
function aa from bbb or function aa from aaa. In this case it chooses to call
the aa from bbb as its aa hides the aa of interface aaa.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>To sum up, if a function is hidden from one access path, it
is hidden from all.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A little later in this chapter, we will show you that
structures can also implement from an interface.This process of implementing
all the functions is called interface mapping.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>new int a1 <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>set; <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class ccc : bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aaa.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>int bbb.a1 { <o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class ddd: bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() {}<o:p></o:p></p>

<p class=programs>int bbb.a1 <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class eee: bbb<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aaa.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public int a1 <o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>set<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The interface aaa has one function a1 which clashes with the
name of the property in interface bbb. We have three ways to create a class
which is derived from bbb. In the first case ccc, we are explicitly qualifying
with the name of interface. In the second case of ddd, we are qualifying only
the property and not the function. In the third case i.e. class eee, we do the
reverse. Thus one of the a1or both must be qualified or else it will result in
an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ccc : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a3();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class ddd : aaa,bbb,ccc<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void bbb.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a2() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void a3() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(21,6): error CS0539: 'bbb.a1' in explicit interface
declaration is not a member of interface<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(19,7): error CS0535: 'ddd' does not implement interface
member 'aaa.a1()'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Both interfaces bbb and ccc derive from interface aaa. Class
ddd derives from three interfaces aaa and bbb and ccc. In class ddd, we have
only 3 functions, a1, a2 and a3 that come from aaa, bbb and ccc respectively.
Even though interface bbb derives from aaa, it does not carry a1 into class
ccc. So, we cannot write bbb.a1 in class ccc. Hence, we have only one a1 from
interface aaa in class ccc and none from interfaces bbb and ccc. This proves
that C# forgets the interfaces bbb and ccc are derived from. It also means that
bbb and ccc cannot have their own implementations of a1.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa a = new ccc();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;bbb a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class<span style="mso-spacerun: yes">  </span>ccc : bbb , aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output <o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The class ccc derives from bbb and aaa. The function a1 from
interface aaa is implemented by class bbb and not by ccc. No one cares as long
as there is a function a1 somewhere. The function a1, in this case, can be in
the actual class or in the base class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>bbb b = new ccc();<o:p></o:p></p>

<p class=programs>b.a1();<o:p></o:p></p>

<p class=programs>ccc c = new ccc();<o:p></o:p></p>

<p class=programs>c.a1();<o:p></o:p></p>

<p class=programs>aaa a = new ccc();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>aaa aa = new bbb();<o:p></o:p></p>

<p class=programs>aa.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;bbb a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class<span style="mso-spacerun: yes">  </span>ccc : bbb <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>new public void a1() {<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;ccc a1&quot;);<o:p></o:p></p>

<p class=programs>}<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=DOSPROMPT>ccc a1<o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In this case, class ccc is derived from class bbb, which in
turn is derived from interface aaa. Both the classes implement the function a1.
The question on our minds is from which class will the function a1 be called.
Both b and c are initialized to an object that looks like ccc. b.a1() will
obviously call the function a1 from bbb and c.a1() will call it from ccc.
Saying the same thing over and over again like a malfunctioning record disk is
trying but essential. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Objects a and aa look like aaa but are initialized to
objects that look like ccc and bbb respectively. It does not seem to make any
difference as each time the function a1 gets called from the base class bbb and
not from the derived class ccc or the class that we have initialized the object
to.<o:p></o:p></p>

<p class=cbasetext>This means that the derived class cannot alter the interface
mappings it receives from the base class. The mapping of function a1 is to the
class bbb as bbb was derived from the interface. Class ccc cannot change this
fact.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>bbb b = new ccc();<o:p></o:p></p>

<p class=programs>b.a1();<o:p></o:p></p>

<p class=programs>bbb b1 = new bbb();<o:p></o:p></p>

<p class=programs>b1.a1();<o:p></o:p></p>

<p class=programs>ccc c = new ccc();<o:p></o:p></p>

<p class=programs>c.a1();<o:p></o:p></p>

<p class=programs>aaa a = new ccc();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>aaa aa = new bbb();<o:p></o:p></p>

<p class=programs>aa.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public virtual void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;bbb a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class<span style="mso-spacerun: yes">  </span>ccc : bbb <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;ccc a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>ccc a1<o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=DOSPROMPT>ccc a1<o:p></o:p></p>

<p class=DOSPROMPT>ccc a1<o:p></o:p></p>

<p class=DOSPROMPT>bbb a1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have made two changes in our program. We made the
function a1 virtual in the class bbb and also, in the class ccc, we declared a1
with the override modifier. Whenever we declare a function to be virtual, the
derived classes will and can override it. The modifier override has the
opposite meaning over new. It means do not create a new function but override
the base class definition.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Objects b and b1 both look like bbb but are initialized to
objects that look like ccc and bbb respectively. When we write b.a1(), C# first
looks into the class bbb as that is the data type of b. Here the function a1 is
marked virtual, so C# now asks what was b initialized by? As the answer is an
object that looks like ccc, C# now looks at the class ccc for the function a1.
As it is marked override, C# will execute the function a1 from<span
style="mso-spacerun: yes">  </span>class ccc and not bbb. If the override was
missing, the default is new, and the function will be called from the data type
of the object i.e. bbb.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As object b1 has been initialized by an object that looks
like bbb, C# will call a1 from class bbb only. The object c follows the earlier
specified rules. As for objects a and aa, both look like interface aaa which
has no code for the function aaa. Here the object used to initialize will
decide the class a1 will be called from. This is due to the explanation above
as a1 is marked virtual in class bbb and override in class ccc.<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ppp<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb : aaa , ppp<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public virtual void aaa.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;bbb a1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class<span style="mso-spacerun: yes">  </span>ccc : bbb <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override void a1() {<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;ccc a1&quot;);<o:p></o:p></p>

<p class=programs>}<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(17,21): error CS0106: The modifier 'public' is not
valid for this item<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(17,21): error CS0106: The modifier 'virtual' is not
valid for this item<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Lets make matters worse. We have an interface ppp which also
brings in a function called a1. The class bbb also derives from ppp. Thus we
have two a1 functions and we have to explicitly qualify them. Unfortunately we
cannot add the qualifier virtual here. The only way out is as follows.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa a = new ccc();<o:p></o:p></p>

<p class=programs>a.a1();<o:p></o:p></p>

<p class=programs>aaa aa = new bbb();<o:p></o:p></p>

<p class=programs>aa.a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface ppp<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb : aaa , ppp<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void aaa.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aa1();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void ppp.a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public virtual void aa1()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa1&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class<span style="mso-spacerun: yes">  </span>ccc : bbb <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public override void aa1()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;aa1 ccc&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>aa1 ccc<o:p></o:p></p>

<p class=DOSPROMPT>aa1<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>What we have done here is that in the a1 function of aaa we
have called the function aa1. So in other words, a1 simply calls aa1. We have
made aa1 virtual such that each time aa1 is called, the question asked will be
- which object was used at the time of initialization? Depending upon the type
of object, the relevant function aa1 would be executed. Thus we get the same
answer as earlier. If we have to reimplement an interface, you can look at the
example earlier. C# forgets about the initial derivation.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>abstract class bbb : aaa <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,16): error CS0535: 'bbb' does not implement
interface member 'aaa.a1()'<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,16): error CS0535: 'bbb' does not implement
interface member 'aaa.a2()'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Whenever we have a abstract class deriving from an
interface, the class must implement all the methods of the interface as
follows.<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface aaa<o:p></o:p></p>

<p class=programs>{ <o:p></o:p></p>

<p class=programs>void a1();<o:p></o:p></p>

<p class=programs>void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>abstract class bbb : aaa <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void a1() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public abstract void a2();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>If the abstract class does not want to implement all the
members of the interface, it has to mark the functions as abstract and public.
The class deriving from bbb will now have to supply the code of the class bbb<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Structures <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx x = new xxx(10);<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x.i);<o:p></o:p></p>

<p class=programs>x.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public xxx( int j)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=DOSPROMPT>abc<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A structure or struct to be precise is similar to a class in
many ways. A struct can contain fields, methods etc. If a struct and class were
100 per cent similar, then why have both? We will now explain the differences
between a struct and a class. Unless otherwise stated, they share the same
features.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i = 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,12): error CS0573: 'xxx.i': cannot have instance
field initializers in structs<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In a class we are allowed to create a field/variable and
initialize it at the same time. A structure cannot contain such
initializations. Thus these fields must be initialized either through functions
or by using the object itself. Fields cannot be given initial values at the
time of creation.<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new xxx();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public xxx()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,8): error CS0568: Structs cannot contain explicit
parameterless constructors<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A class can contain many constructors. And even if we do not
have any, C# supplies a free constructor with no parameters. It's very
different with structures. You cannot have<span style="mso-spacerun: yes"> 
</span>a constructor with no parameters. If you do, you will get the above
error. Thus C# lets you have as many constructors as you like but none without
parameters.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() {<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new xxx(10);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public xxx(int p) { }<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(10,8): error CS0171: Field 'xxx.i' must be fully
assigned before control leaves the constructor<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A small problem here. As mentioned earlier we cannot
initialize a field like we do in a class. Hence C# insists on constructors that
accept parameters to initialize fields; at the end of the constructor if you
have not initialized the fields in the structure, we get the above error. Thus
C# actually reads our code and makes sure that the constructor initializes all
the fields in the structure.<o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx <span style="mso-spacerun: yes"> </span>a = new xxx(10);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i,j;<o:p></o:p></p>

<p class=programs>public xxx(int p) {<o:p></o:p></p>

<p class=programs>i = p;<o:p></o:p></p>

<p class=programs>} <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,8): error CS0171: Field 'xxx.j' must be fully
assigned before control leaves the constructor<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The keyword shown in all the above errors is fields.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new xxx(10);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i,j;<o:p></o:p></p>

<p class=programs>public xxx(int p)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = p;<o:p></o:p></p>

<p class=programs>j = 0;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext>We get no error as the structure has two fields and we have
now initialized both of them.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new xxx();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Warning<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,12): warning CS0649: Field 'xxx.i' is never assigned
to, and will always have its default value 0<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output <o:p></o:p></p>

<p class=DOSPROMPT>0<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>If we do not have any constructors, we get no error. As we
have not initialized the field i, in the constructor, we have none. C# gives
you a warning and for the sake of your sanity, initializes i to 0.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new xxx();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct yyy : xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,14): error CS0527: 'xxx' : type in interface list is
not an interface<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A structure yyy cannot be derived from another structure. A
useful feature of a class was the fact that we could share/use code from other
classes. A structure does not support the concept of inheritance. Had xxx been
a class we would have received the same error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new yyy();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>interface xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct yyy : xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The previous error message gave us a hint . It expected xxx
to be a interface. Thus we can derive a structure from an interface. As xxx has
no members we do not have to implement any code in our structure.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx<span style="mso-spacerun: yes">  </span>a = new yyy();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(11,7): error CS0509: 'xxx' : cannot inherit from sealed
class 'yyy'<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As a structure could not inherit from a class, the reverse
is also true. xxx cannot inherit from a structure yyy. Internally a structure
behaves as a sealed class as the error message reads. For those who came in
late, a sealed class cannot be used a base class.<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>sealed struct yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(7,15): error CS0106: The modifier 'sealed' is not valid
for this item<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You cannot declare a structure as sealed as they are by
definition sealed. If you add the word sealed as we have done, C# complains
about the fact that we are repeating the same modifier again and nobody likes
repetition.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>abstract struct yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(7,17): error CS0106: The modifier 'abstract' is not
valid for this item<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As C# does not like repetition, we have to bow to its
wishes. But you do not have an option. We are free to repeat ourselves with you
as many times as we like. So let us indulge ourselves. A structure as mentioned
earlier cannot be used as a base class i.e. be used in a derivation. An
abstract modifier, means an incomplete entity which cannot be used directly but
only as a base class. It makes no sense for a structure to use the modifier
abstract. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In the same vein, function in a structure cannot be marked
abstract or virtual as these are concepts, which apply to derived classes only.
<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>protected struct xxx {<span style="mso-spacerun: yes"> 
</span>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(7,1): error CS1527: Namespace elements cannot be
explicitly declared as private or protected<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A structure cannot be derived from and the modifier
protected deals with the visibility of members from derived classes. Replacing
protected with private results in the same error.<o:p></o:p></p>

<p class=cbasetext><span style="mso-spacerun: yes"> </span><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy<span style="mso-spacerun: yes">  </span>a = new yyy();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.ToString());<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>yyy<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>However every structure like a class is implicitly derived
from the class Object and thus has the functions Object contains. In this case
ToString returns the name of the derived class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy<span style="mso-spacerun: yes">  </span>a = new yyy();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.ToString());<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct yyy : System.Object<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,14): error CS0527: 'System.Object' : type in
interface list is not an interface<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>How do we explain the above error? We just mentioned earlier
that as a structure inherits from the class Object and we called a function
called ToString from the class Object. However we cannot derive from Object
explicitly as the compiler insists on the name of an <span style="mso-spacerun:
yes"> </span>interface and Object is a name of a class. These little quirks
make learning C# difficult. If you replace the word struct with class in the
above example, you will not get an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A computer has lots of memory. We logically divide this
memory into two, the stack and the heap. Memory denoted as the stack lives as
long as the function lives and heap memory lives as long as your program runs.
Objects, instances of a class are allocated on the heap. They will live for a
long time. They are also called reference objects. Structures are allocated on
the stack by new and live for a shorter duration. We call them value objects.
This means that a structure directly represents the data where as a object
contains a reference to the data. Structures thus offer a more efficient access
to variables than classes. Int, bool and all the other basic data types are
implemented as structures. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx x,y;<o:p></o:p></p>

<p class=programs>yyy a,b;<o:p></o:p></p>

<p class=programs>x = new xxx(1); y = new xxx(2);<o:p></o:p></p>

<p class=programs>a = new yyy(1); b = new yyy(2);<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x.i + &quot; &quot; + y.i + &quot;
&quot; + a.i + &quot; &quot; + b.i);<o:p></o:p></p>

<p class=programs>x = y; a = b;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x.i + &quot; &quot; + y.i + &quot;
&quot; + a.i + &quot; &quot; + b.i);<o:p></o:p></p>

<p class=programs>x.i = 100; a.i = 200;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(x.i + &quot; &quot; + y.i + &quot;
&quot; + a.i + &quot; &quot; + b.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public yyy(int j)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i;<o:p></o:p></p>

<p class=programs>public xxx(int j)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = j;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>1 2 1 2<o:p></o:p></p>

<p class=DOSPROMPT>2 2 2 2<o:p></o:p></p>

<p class=DOSPROMPT>100 2 200 200<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have created two objects a and b which look like a class
yyy and two structures x and y which look like xxx. In the constructors of
each, we are initializing the field i to 1 and 2 respectively. Then we are
equating the object a to b and the structure x to y. This will set the i of x
to 2 from 1 and also the i of a to 2. Thus the second WriteLine displays all
two's. We are now changing the i of x, which is a structure to 100 and we
realize that the i of y, the structure it was initialized to remains the same.
Thus x.i is 100 and y.i remains at 2. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>For classes it does not work the same way. Changing a.i to
200, somehow changes the i of b which a was initialized to, also to 200. This
could only be possible if when we equate structures, each has its own copy of
the data. When we equate objects, no copying takes place and now object a
refers to object b in memory. Both a and b represent the same object. Changing
a changes b. A little later, we dwell on this concept further. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The same rules of passing parameters to a function i.e. out
and ref that apply to an int also apply to a structure as int is also a
structure internally. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx x;<o:p></o:p></p>

<p class=programs>yyy a;<o:p></o:p></p>

<p class=programs>x=null;<o:p></o:p></p>

<p class=programs>a=null;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(7,3): error CS0037: Cannot convert null to 'xxx'
because it is a value type<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>In computer programming, a large number of times we do not
know the value of a variable at a point in time. These variables are given a
value of null. Null can be only applied to objects of reference types and not
value types.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>struct xxx<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public ~xxx()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,9): error CS0575: Only class types can contain
destructors<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>After a long time, we get an error message that is readable.
Structures are created on the stack and die when we reach the closing brace.
There is thus no memory management to be done from the point of view of the
programmer. The structure life cycle is very deterministic and hence no destructors
are permitted.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap11.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:36 GMT -->
</html>
