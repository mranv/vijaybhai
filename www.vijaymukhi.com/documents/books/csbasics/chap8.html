<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap8.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:28 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap8_files/filelist.html">
<link rel=Edit-Time-Data href="chap8_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Modifiers - C# The Basics - Beta2</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>1</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2001-09-27T10:59:00Z</o:Created>
  <o:LastSaved>2001-09-27T11:00:00Z</o:LastSaved>
  <o:Pages>15</o:Pages>
  <o:Words>3165</o:Words>
  <o:Characters>18045</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>150</o:Lines>
  <o:Paragraphs>36</o:Paragraphs>
  <o:CharactersWithSpaces>22160</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:36.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Times New Roman";
	mso-font-kerning:0pt;
	font-weight:normal;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:8.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	letter-spacing:10.0pt;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:24.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.ChapName, li.ChapName, div.ChapName
	{mso-style-name:ChapName;
	mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.SubTitle, li.SubTitle, div.SubTitle
	{mso-style-name:SubTitle;
	mso-style-parent:"c\# base text";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.ChapName0, li.ChapName0, div.ChapName0
	{mso-style-name:"Chap Name";
	mso-style-parent:"base text of the book";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.ChapIntro, li.ChapIntro, div.ChapIntro
	{mso-style-name:"Chap Intro";
	mso-style-parent:"base text of the book";
	margin-top:0in;
	margin-right:42.65pt;
	margin-bottom:0in;
	margin-left:1.25in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-style:italic;}
p.basetextofthebook1, li.basetextofthebook1, div.basetextofthebook1
	{mso-style-name:"base text of the book1";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.figure, li.figure, div.figure
	{mso-style-name:figure;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.PageNo, li.PageNo, div.PageNo
	{mso-style-name:"Page No";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.0pt;
	font-family:Arial;
	mso-fareast-font-family:"Times New Roman";}
p.Subhead2, li.Subhead2, div.Subhead2
	{mso-style-name:"Subhead 2";
	mso-style-parent:"Subhead 1";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.Subhead1, li.Subhead1, div.Subhead1
	{mso-style-name:"Subhead 1";
	mso-style-parent:Headline;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:18.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.Headline, li.Headline, div.Headline
	{mso-style-name:Headline;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	font-weight:bold;}
p.Hangingindent, li.Hangingindent, div.Hangingindent
	{mso-style-name:"Hanging indent";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	mso-pagination:widow-orphan;
	tab-stops:12.0pt;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Bodytext, li.Bodytext, div.Bodytext
	{mso-style-name:"Body text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-indent:24.0pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:48.0pt'>8</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h1>Modifiers</h1>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Access Modifiers <o:p></o:p></p>

<p class=SubTitle><span style='font-size:10.0pt;mso-bidi-font-size:12.0pt'>Public,
Private, Protected<span style="mso-spacerun: yes">  </span>and Internal</span><o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Whenever a class is created by us we want to have the
ability to decide who can access certain members of the class. In other words,
we would like to restrict access to the members of the class. The basic rule is
that members of a class can freely access each other. There is no way one can
prevent a function of a particular class from executing another function in the
same class. By default though, the same class is allowed complete access but no
one else is granted access to the members of the class. The default access
modifier is private.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy.pqr();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy abc”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy pqr”);<o:p></o:p></p>

<p class=programs>abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>yyy pqr<o:p></o:p></p>

<p class=DOSPROMPT>yyy abc<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Pqr is public and hence anyone is allowed to execute it. abc
has no access modifier which makes it private, which is anyway the default.
The<span style="mso-spacerun: yes">  </span>private modifier has no effect on
members of the same class and hence pqr is allowed to call abc. This concept is
called member access.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy abc”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy pqr”);<o:p></o:p></p>

<p class=programs>abc(); } }<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0122: ‘yyy.abc()’ is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>abc is private an no one but members of yyy can access it. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>protected static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy abc”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy pqr”);<o:p></o:p></p>

<p class=programs>abc();<o:p></o:p></p>

<p class=programs>} }<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0122: ‘yyy.abc()’ is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have now introduced one more access modifier, protected,
which also does not let you access a class from outside. However pqr is allowed
to access abc as access modifiers do not effect the same class as mentioned
earlier. <o:p></o:p></p>

<p class=programs><span style='font-size:11.0pt;font-family:"Times New Roman"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>xxx.aaa();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy abc”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy pqr”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>protected static void xyz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“yyy xyz”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void aaa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>abc();<o:p></o:p></p>

<p class=programs>pqr();<o:p></o:p></p>

<p class=programs>xyz();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(27,1): error CS0122: ‘yyy.abc()’ is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We are now dealing with<span style="mso-spacerun: yes"> 
</span>derived classes. When we flag a function with the modifier, protected,
we are informing C# that only derived classes can access the function. Nobody
else can. Thus<span style="mso-spacerun: yes">  </span>in function aaa we can
call xyz as it is flagged protected, but it cannot be called from anywhere else
including Main. The function abc is private and can be called only from the
class yyy. Comment out abc(); in aaa and csc will show you no errors. <o:p></o:p></p>

<p class=cbasetext>To sum up, we have learnt three concepts. Private means only
the same class has access, public means everyone has access and protected lies
in between where only derived classes have access.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>All functions for example reside in a class. The
accessibility of that function is decided by the class in which it resides as
well as the modifiers on the function. If we are allowed access to a member, we
say that the member is accessible, else inaccessible. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>internal class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>csc /t:library b.cs<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>This command will produce a library b.dll with one class
yyy.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>&gt;csc a.cs /r:b.dll<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0122: ‘yyy’ is inaccessible due to its
protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We get the above error as the modifier internal means that
we can only access yyy from b.dll and not from any other file or program. Never
create a component and flag the class internal as no one would be able to use
it. Internal means access limited to this program only. <o:p></o:p></p>

<p class=cbasetext>Also writing csc a.cs b.cs would not give us any error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public namespace vijay<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(1,8): error CS1518: Expected class, delegate, enum,
interface, or struct<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Namespaces by default can have no accessibility modifiers at
all. They are public by default and we cannot add any other access modifier
including public again.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>private class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(1,1): error CS1527: Namespace elements cannot be
explicitly declared as private or protected<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A class can only be public or internal. It cannot be marked
as protected or private. The default is internal.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>csc b.cs /t:library<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>fatal error CS2022: Options ‘/out’ and ‘/target’ must appear
before source file names<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Mistake, done on purpose. At times we will forget to tell
you that some compiler options like /t and /out must appear before the names of
the source files.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>&gt;csc /t:library b.cs<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>&gt;csc a.cs /r:b.dll<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0122: ‘yyy’ is inaccessible due to its
protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Thus if we want other programs/files to access classes
created by us, we must not forget that by default they are marked as internal
as explained earlier.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Members of a class can have all the modifiers described
above and default to private.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public private void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,8): error CS0107: More than one protection modifier<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You are not allowed more than one access modifier most of
the time. The exceptions, we will soon take care off. Predefined types like
int, object have no accessibility restrictions. They can be used anywhere and
everywhere.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>csc /t:library b.cs<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(5,1): error CS0122: 'yyy' is inaccessible due to its
protection level<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0246: The type or namespace name 'a'
could not be found (are you missing a using directive or an assembly
reference?)<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As the class yyy has not been specified by an access
modifier, it is by default internal. Even though abc is public, the type
enclosing it i.e. yyy is internal and hence no member of yyy can be accessed
from outside b.cs. Thus the access modifiers of the class and the members is important.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>&gt;csc /t:library b.cs<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0122: ‘yyy.abc()’ is inaccessible due to
its protection level<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Here yyy is accessible as the modifier is public but the
function abc is private and hence cannot be accessed by anyone but the class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>From now on we will only display a.cs and b.cs as the
command line executions of the compiler will remain the same. a.cs remains the
same for this program.<o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>internal void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0122: ‘yyy.abc()’ is inaccessible due to
its protection level<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Internal means no one from outside the dll can access the
function.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext style='margin-left:.5in'><u><span style='font-size:10.0pt;
font-family:Tahoma'>a.cs</span></u><span style='font-size:10.0pt;font-family:
Tahoma'><o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>class zzz<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>{<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>{<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>ppp a = new ppp();<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>a.aaa();<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>}<o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Tahoma'>}<o:p></o:p></span></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>b.cs</u><o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>protected internal void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class ppp<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public void aaa()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a = new yyy();<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>} <o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>No error occurs as protected internal means two things. It
is either derived classes or classes in the same file that can access abc.
Therefore derived class xxx can use it as well as class ppp.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>What we are trying to get at here is that the containing
type decides first the accessibility and then the member modifiers also comes
in. Making the class internal and then the members public will in no way allow
classes in others files access it.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>protected int x;<o:p></o:p></p>

<p class=programs>void abc( yyy a , xxx b)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>a.x = 1; <o:p></o:p></p>

<p class=programs>b.x = 2;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>void pqr( yyy a , xxx b)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>a.x = 1; <o:p></o:p></p>

<p class=programs>b.x = 2;<o:p></o:p></p>

<p class=programs>} }<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(20,1): error CS1540: Cannot access protected member
‘yyy.x’ via a qualifier of type ‘yyy’; the qualifier must be of type ‘xxx’ (or
derived from it)<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Class yyy contains a protected member x. To the same class
no modifiers make sense. However as x is protected, in the derived class
function pqr, we cannot access it through yyy as a.x gives us an error. However
b which looks like xxx does not give an error. To check this out, comment out
the line a.x=1 in pqr(). This means that we can access the protected members
not from an object of the base class, but from the derived class objects only.
This is in spite of the fact that x is a member of yyy, the base class. Even
so, we still cannot access it. Also we cannot access x from the function Main.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(10,14): error CS0060: Inconsistent accessibility: base
class ‘yyy’ is less accessible than class ‘xxx’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Between internal and public, public allows greater access to
its members. The class yyy is by default internal and xxx which derives from
yyy is explicitly made public. We get an error as the derived class yyy has to
have an access modifier which allows greater access than the base class access
modifier. Here internal is more restrictive than public.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>If we reverse the modifiers, i.e. we make yyy public and xxx
the derived class internal we get no error. The base class allows more
accessibility than the derived class.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class xxx <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public yyy f()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>return new yyy();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,12): error CS0050: Inconsistent accessibility:
return type ‘yyy’ is less accessible than method ‘xxx.f()’<o:p></o:p></p>

<p class=cbasetext>The accessibility of yyy is internal which is more
restrictive than public. The accessibility of function f is public which is
more than that of the type yyy. The error occurred as return values must
have<span style="mso-spacerun: yes">  </span>greater accessibility than that of
the method, which is not true in this case.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class xxx <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public yyy a;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(12,12): error CS0052: Inconsistent accessibility: field
type ‘yyy’ is less accessible than field ‘xxx.a’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Rules are rules – they remain the same everywhere. The class
yyy or data type yyy is internal. a, an object/field is public which makes it
more accessible than yyy which is internal. Hence the error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void<span style="mso-spacerun: yes"> 
</span>Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class xxx <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy a;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Now we get no error as a has been made private which gives
it a lower accessibility than yyy which is internal. Logic is that whatever you
create must be more accessible than what you create from.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Sealed Classes <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Sealed is another modifier that applies to classes. aaa is a
sealed class. No class can derive from aaa. In another words aaa cannot act as
a base class for any class.<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>sealed class aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class bbb : aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(10,7): error CS0509: ‘bbb’ : cannot inherit from sealed
class ‘aaa’<o:p></o:p></p>

<p class=programs><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>aaa a = new aaa();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i);<o:p></o:p></p>

<p class=programs>a.abc();<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>sealed class aaa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int i = 9;<o:p></o:p></p>

<p class=programs>public void abc()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“hi”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>9<o:p></o:p></p>

<p class=DOSPROMPT>hi<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The only difference between a sealed class and a non-sealed
class is that a sealed class cannot be derived from. Otherwise there is no
difference at all. It can contain the same variables, functions etc as a normal
class does . A sealed class lets us create classes which no one can derive
from. Thus the code in such classes cannot be overridden. Also as the compiler
knows this, certain run time optimizations can be performed on a sealed class <o:p></o:p></p>

<p class=SubTitle><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Constants <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>const int i = 10;<o:p></o:p></p>

<p class=programs>public static void Main() {<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A constant or const variable behaves as a variable. We give
it an initial value and can use it wherever we can use a variable. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>const int i = 10;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i++;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>i = 30;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0131: The left-hand side of an assignment
must be a variable, property or indexer<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(8,1): error CS0131: The left-hand side of an assignment
must be a variable, property or indexer<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Unlike a variable, we are not allowed to change the value of
a const. The change is an assignment statement.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>const int i ;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = 30;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(3,13): error CS0145: A const field requires a value to
be provided<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We have to initialize the const variable at the time of
creation. We are not allowed to initialize it later in our program. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>const int i = j + 4;<o:p></o:p></p>

<p class=programs>const int j = k - 1;<o:p></o:p></p>

<p class=programs>const int k = 3;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“{0} {1} {2}”,i,j,k);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>6 2 3<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A constant can depend upon another constant. C# is smart
enough to realize that to calculate the value of const i, it first needs to
know the value of j. j’s value depends upon another const k, whose value is 3.
Thus C# first evaluates k to 3 then j becomes 2 i.e. k -1 and finally i takes
on the value of j i.e. 2 + 4<span style="mso-spacerun: yes">  </span>resulting
in 6.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Like classes const’s cannot be circular i.e., they cannot
depend upon each other.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>const int i = j + 4;<o:p></o:p></p>

<p class=programs>const int j = k - 1;<o:p></o:p></p>

<p class=programs>const int k = i;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“{0} {1} {2}”,i,j,k);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(3,11): error CS0110: The evaluation of the constant
value for ‘zzz.i’ involves a circular definition<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The value of the const i depends upon j which in turn
depends upon k, which is equal to i. This becomes a circular definition. A
const is a variable whose value cannot be changed but whose initial value is
compile time determined.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public const aa a = new aa();<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(3,17): error CS0133: The expression being assigned to
‘zzz.a’ must be constant<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public const aa a = null;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The error vanishes as we are now initializing a to an object
which has a value that can be determined at compile time. We cannot ever change
the value of a, so it will always be null. Normally we do not have consts as a
reference type as they have value only at runtime.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>As mentioned earlier we can only initialize a const to a
compile time value i.e. a value available to the compiler while it is
executing. new unfortunately gets executed at runtime and therefore has no
value at compile time. This gives us an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>yyy y = new yyy();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(y.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy {<o:p></o:p></p>

<p class=programs>public const int i = 3;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,26): error CS0176: Static member 'yyy.i' cannot be
accessed with an instance reference; qualify it with a type name instead<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A constant is static by default and we cannot use the
instance reference i.e. a name to reference a const. A const has to be static
as no one is allowed to make any changes to a const. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static const int i = 3;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,25): error CS0504: The constant ‘yyy.i’ cannot be
marked static<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>C# does not want us to repeat the obvious over and over
again. Just like humans, programming language too have their own quirks. Some
other time, perhaps, C# may permit us to write a static before an entity that
is already static by default.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>class zzz<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(yyy.i + “ “ + xxx.i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public const int i = 3;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>class xxx : yyy<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public const int i = 30; }<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Warning<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(14,18): warning CS0108: The keyword new is required on
‘xxx.i’ because it hides inherited member ‘yyy.i’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>3 30<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>We can create a const with the same name as another const in
the base class. The const of the class xxx i will hide the const i in class yyy
for the class xxx only.<o:p></o:p></p>

<p class=SubTitle>Fields <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A field to start with is another word for a variable in a
class. There are a large number of generic rules that apply to all members of a
class and we will not tire you by repeating them ad nauseam. <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A variable can never have an uninitialized value in C#.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static int i;<o:p></o:p></p>

<p class=programs>static bool j;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(zzz.i + “ “ + zzz.j );<o:p></o:p></p>

<p class=programs>} }<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>0 False<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Static variables are initialized when the class is loaded
first. An int is given an initial value of<span style="mso-spacerun: yes"> 
</span>zero and a bool False.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int i;<o:p></o:p></p>

<p class=programs>bool j;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>zzz a = new zzz();<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(a.i + “ “ + a.j );<o:p></o:p></p>

<p class=programs>} }<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>0 False<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>An instance variable is initialized at the time of creation.
The keyword new will create an instance of<span style="mso-spacerun: yes"> 
</span>the zzz. It will allocate memory for each of the non static variables
and then initialize each of them to their default values.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>static int i = j + 10;<o:p></o:p></p>

<p class=programs>static int j = i + 1;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(zzz.i + “ “ + zzz.j );<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>10 11<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Outputs make a lot of sense if you understand them in plain
simple English. C# always initializes static fields to their initial value
after creating them . Variables i and j are thus given a default of zero. Then
C# realizes that these variables need to be assigned some values. It does not
read all the lines, only one at a time. It will now read the first line and as
the variable j has a value of 0, i will get a value of 10. Then at the next
line, j is the value of i plus 1. The variable i has a value of 10 and j now
becomes 11. As it does not see both lines at the same time, it does not notice
the circularity of the above definition. In short, though the above example
works, it is frowned upon by the powers to be at C#.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>int i = j + 10;<o:p></o:p></p>

<p class=programs>int j = i + 1;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(3,9): error CS0236: A field initializer cannot
reference the nonstatic field, method, or property ‘zzz.j’<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(4,9): error CS0236: A field initializer cannot
reference the nonstatic field, method, or property ‘zzz.i’<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>It does not work for instance variables as the rules of an
instance variable are different than that of static. The field initializer of
an instance variable has to be determined at the time of creation of the
object. The variable j does not have a value at this point in time. It cannot
refer to variables of the same instance at the time of creation. Thus we can
refer to no instance members to initialize an instance member. Textual order
means first come first served.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=SubTitle>Readonly Fields <o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Fields can be also tagged with the modifier readonly.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static readonly<span style="mso-spacerun: yes"> 
</span>int<span style="mso-spacerun: yes">  </span>i = 10;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Arial'>Output <o:p></o:p></span></p>

<p class=cbasetext style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Arial'>10<o:p></o:p></span></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>No errors at all. However, remember if we use a non static
variable in a static function we will get an error.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static readonly<span style="mso-spacerun: yes"> 
</span>int<span style="mso-spacerun: yes">  </span>i = 10;<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = 20;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(6,1): error CS0198: A static readonly field cannot be
assigned to (except in a static constructor or a variable initializer)<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>You cannot change the value of a readonly field after its
being given an initial value.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz {<o:p></o:p></p>

<p class=programs>public static readonly<span style="mso-spacerun: yes"> 
</span>int<span style="mso-spacerun: yes">  </span>i ;<o:p></o:p></p>

<p class=programs>public static void Main() {<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Unlike a const, a readonly field does not have to be
initialized at the time of creation.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static readonly<span style="mso-spacerun: yes"> 
</span>int<span style="mso-spacerun: yes">  </span>i ;<o:p></o:p></p>

<p class=programs>static zzz()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>i = 20;<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(“In Const”);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>System.Console.WriteLine(i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT>Output<o:p></o:p></p>

<p class=DOSPROMPT>In Const<o:p></o:p></p>

<p class=DOSPROMPT>20<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>A static readonly field can be initialized in a static
constructor also. This is the major difference between a const and a readonly
field.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public readonly aa a = new aa();<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>The same example which gave an error with const does not
give an error with readonly. To sum up a readonly is a more generic const and
it makes our programs more readable as we refer to a name and not a number. Is
100 more intuitive or priceofcopper easier to understand? The compiler would
for reasons of efficiency convert all const’s and readonly variables to the
actual values.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs</u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public int readonly i = 10;<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,12): error CS1585: Member modifier ‘readonly’ must
precede the member type and name<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(9,23): error CS1519: Invalid token ‘=’ in class,
struct, or interface member declaration<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=cbasetext>Wherever you can place multiple modifiers, remind yourself
that there are rules that decide the order of modifiers, which comes first.
Here the readonly modifier precedes the data type int. Once again, no great
cosmic law responsible, just a rule that must be remembered.<o:p></o:p></p>

<p class=cbasetext><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=programs><u>a.cs </u><o:p></o:p></p>

<p class=programs>public class zzz <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>public static void Main() <o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>public class aa {<o:p></o:p></p>

<p class=programs>public readonly int i = 10;<o:p></o:p></p>

<p class=programs>void abc(ref int<span style="mso-spacerun: yes">  </span>z)<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>void pqr()<o:p></o:p></p>

<p class=programs>{<o:p></o:p></p>

<p class=programs>abc(ref i);<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=programs>}<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=DOSPROMPT>Compiler Error<o:p></o:p></p>

<p class=DOSPROMPT>a.cs(13,9): error CS0192: A readonly field cannot be passed
ref or out (except in a constructor)<o:p></o:p></p>

<p class=DOSPROMPT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>A readonly field cannot be changed by anyone except a
constructor. The function abc expects a ref parameter which if you have
forgotten allows you to change the value of the original. Thus C# does not
permit a readonly as a parameter to a function that accepts a ref or a out
parameters.</p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/csbasics/chap8.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:38:30 GMT -->
</html>
