<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/vs2net/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:11:01 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap5_files/filelist.html">
<link rel=Edit-Time-Data href="chap5_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Visual Studio.Net - Controls and Add-ins</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>vmukhi</o:Author>
  <o:LastAuthor>vmukhi</o:LastAuthor>
  <o:Revision>5</o:Revision>
  <o:TotalTime>13</o:TotalTime>
  <o:Created>2002-01-21T06:08:00Z</o:Created>
  <o:LastSaved>2002-01-21T06:08:00Z</o:LastSaved>
  <o:Pages>10</o:Pages>
  <o:Words>3210</o:Words>
  <o:Characters>18299</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>152</o:Lines>
  <o:Paragraphs>36</o:Paragraphs>
  <o:CharactersWithSpaces>22472</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;
	mso-font-charset:0;
	mso-generic-font-family:script;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=103 height=77 id="_x0000_i1025"
src="../img/bpb.html"></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:24.0pt;font-family:"Monotype Corsiva";color:black'>5.</span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal style='mso-layout-grid-align:none;text-autospace:none'><span
style='font-size:24.0pt;font-family:"Monotype Corsiva";color:black'>Writing C#
Code </span><span style='font-size:20.0pt;font-family:"Monotype Corsiva"'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the ensuing chapter, we shall
devise user-defined controls whose primary task is to generate C# code in the
code editor. In other words, the basic intent of this chapter is to incorporate
controls that in turn shall add more code to the already existent code
generated by the designer.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>As usual, we set out with the
smallest possible control.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.ComponentModel;<o:p></o:p></p>

<p class=ILprg>public class aaa : Component<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Create a new Windows Application
called WindowsApplication2. The designer that is provided with Visual
Studio.Net, generates the code that ensues. We shall now concede some time for
discerning this code in its entirety. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Drawing;<o:p></o:p></p>

<p class=ILprg>using System.Collections;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel;<o:p></o:p></p>

<p class=ILprg>using System.Windows.Forms;<o:p></o:p></p>

<p class=ILprg>using System.Data;<o:p></o:p></p>

<p class=ILprg>namespace WindowsApplication2<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public class Form1 : System.Windows.Forms.Form<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>private System.ComponentModel.Container components = null;<o:p></o:p></p>

<p class=ILprg>public Form1()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>InitializeComponent ();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>#region Windows Form Designer generated code<o:p></o:p></p>

<p class=ILprg>private void InitializeComponent()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>this.components = new System.ComponentModel.Container();<o:p></o:p></p>

<p class=ILprg>this.Size = new System.Drawing.Size(300,300);<o:p></o:p></p>

<p class=ILprg>this.Text = &quot;Form1&quot;;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>#endregion<o:p></o:p></p>

<p class=ILprg>[STAThread]<o:p></o:p></p>

<p class=ILprg>static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Application.Run(new Form1());<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Every code fragment always gets
underway with the usual gang of suspects, viz. the 'using' statements. There
are six such 'using' statements in all. We shall shortly fill you in on why
these six namespaces are so special to the designer. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The namespace shares its name
with our project, i.e. WindowsApplication2. Then, the code is inserted within
the class Form1, which is derived from the class Form. To jog your memory, the
class Form is provided as the base class, since the application requires a
Windows Form user interface. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the Main function, a new
object is created, which is an instance of the class Form1. Then, the Run
function is called from the Application property. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The constructor of the Form1
class simply calls the function InitializeComponent. This is where most of the
code generated by the individual controls would be posited. The entire code is
placed in the function named InitializeComponent instead of the constructor,
merely to cater to a programming style quirk. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In this function, the instance
variable components are initialized first, along with the two properties of
Size and Text. The rest of the properties assume their default values. The
Dispose function, which has not been depicted here, is called at the time of
winding up. Region, which is a preprocessor directive, is utilized either to
expand or to contract the code. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>It is always preferred to use a
RAD tool such as VisualStudio.Net, since the framework generates tons of
essential, albeit mundane code. A RAD tool proves to be extremely beneficial,
since it aids in easing out the tedium and monotony of writing large amounts of
humdrum code.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>When you double-click on the
control aaa, the control gets placed in the lower area of the window. This is
because the control has no User Interface, since it is derived from Component
and not from Control or UserControl. The code painter reveals two lines of code
that have been freshly inducted.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>private aaa aaa1; <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The first line illustrates the
creation of an instance variable aaa1. The name of our control class is aaa.
Resultantly, the variable or object is named as aaa1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>this.aaa1 = new aaa(); <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the function
InitializeComponent, an instance of the object aaa1 is created. Keep in mind
that it is the designer who inserts the above two lines of code.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, we wish to write controls
that would add supplementary code to the already existing code in the code
painter.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel.Design;<o:p></o:p></p>

<p class=ILprg>using System.CodeDom;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel.Design.Serialization;<o:p></o:p></p>

<p class=ILprg>class ccc : CodeDomSerializer<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public override object Deserialize(IDesignerSerializationManager
manager, object codeObject)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Deserialize&quot;);<o:p></o:p></p>

<p class=ILprg>return null;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Serialize &quot;);<o:p></o:p></p>

<p class=ILprg>return null;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>[DesignerSerializer (typeof(ccc), typeof(CodeDomSerializer))]<o:p></o:p></p>

<p class=ILprg>public class aaa : Component<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class sss<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void abc(string s)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>FileStream fs = new FileStream(&quot;c:\\a1\\a.txt&quot;,
FileMode.Append, FileAccess.Write);<o:p></o:p></p>

<p class=ILprg>StreamWriter w = new StreamWriter(fs);<o:p></o:p></p>

<p class=ILprg>w.WriteLine(s);<o:p></o:p></p>

<p class=ILprg>w.Flush();<o:p></o:p></p>

<p class=ILprg>w.Close();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>a.txt</u><o:p></o:p></p>

<p class=ILoutput>Serialize<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Like before, create a new
project and name it as w7. Then, bring in the control aaa, which has an
attribute DesignerSerializer added to it. This attribute calls upon the code
painter or the designer serialization manager to bring into play the custom serializer
and to also write code in the code painter. The constructor to this attribute
is passed two parameters; the first parameter is the class that contains
functions to serialize and deserialize, while the second parameter is the base
data type of the serializer. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The file a.txt establishes the
fact that the function Serialize actually gets called. This function educates
the Code painter regarding the most appropriate code to be generated for the
object aaa. The value returned is null. Therefore, the code painter does not
generate any code for the control aaa. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The next task is to get the code
painter to generate code that is specific for our control.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Serialize &quot; + v.GetType().ToString());<o:p></o:p></p>

<p class=ILprg style='margin-left:.3in'>CodeDomSerializer a = <span
style='font-size:9.0pt'>(CodeDomSerializer)m.GetSerializer(typeof(Component),typeof(CodeDomSerializer));</span><o:p></o:p></p>

<p class=ILprg>object c = a.Serialize(m, v);<o:p></o:p></p>

<p class=ILprg>sss.abc(c.GetType().ToString());<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>a.txt</u><o:p></o:p></p>

<p class=ILoutput>Serialize aaa<o:p></o:p></p>

<p class=ILoutput>System.CodeDom.CodeStatementCollection<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>All the action transpires in the
function Serialize. Hence, we have only delineated this function. All the
residual code remains unaffected, and hence, is not displayed. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The Serialize function gets
called with the second parameter of type aaa, which is our control. Using v,
which is an object of type aaa, a CodeDOM object is created. This object is
transformed into tangible code by the code painter. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The first parameter m of the
type interface IDesignerSerializationManager, provides the interface that
handles design time serialization. This class renders services to deal with
objects during the process of serialization. Using the parameter m, a function
named GetSerializer is called. The first parameter to this function specifies
the type of object that is to be serialized. The second parameter specifies the
type of serializer that is required.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The control class aaa is derived
from the class Component. The run time data type returned from the
GetSerializer function is ccc, which is the Code Serializer class. Thus, the
Serializer is of type CodeDomSerializer, which would serialize a Component. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The object 'a' is used to call
the Serialize function of the CodeDomSerializer class. The second parameter 'v'
that is supplied to the function, is the aaa control. This has to be
serialized. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The base Serialize function
cannot be called directly, since it is abstract. Therefore, a serialization
manager is used, which creates a CodeStatementCollection to represent the
control aaa. This CodeStatementCollection object is returned. It eventually
gets serialized, i.e. converted into two lines of code. Thus, using the
serialization manager, the default serialization for a Component object is
accomplished.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(zzz), &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput>#region Windows Form Designer generated code<o:p></o:p></p>

<p class=ILoutput>/// &lt;summary&gt;<o:p></o:p></p>

<p class=ILoutput>/// Required method for Designer support - do not modify<o:p></o:p></p>

<p class=ILoutput>/// the contents of this method with the code editor.<o:p></o:p></p>

<p class=ILoutput>/// &lt;/summary&gt;<o:p></o:p></p>

<p class=ILoutput>private void InitializeComponent()<o:p></o:p></p>

<p class=ILoutput>{<o:p></o:p></p>

<p class=ILoutput>zzz Vijay;<o:p></o:p></p>

<p class=ILoutput>//<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the Serialize function, the
CodeStatementCollection object that is to be returned, is created initially.
Since the task is to insert a simple statement that creates a variable in the
code painter, the class named CodeVariableDeclarationStatement is pressed into
action. The constructor is passed two parameters, viz. the data type of the
variable as a type, and its name Vijay as a string. Then, using the Add
function, the object d is added to the Collection class. Therefore, when the
control is placed in the form, a variable called Vijay of type zzz is exposed
to view.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(zzz), &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodeObjectCreateExpression(typeof(yyy));<o:p></o:p></p>

<p class=ILprg>d.InitExpression = e;<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>} <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>public class yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>private void InitializeComponent()<o:p></o:p></p>

<p class=ILoutput>{<o:p></o:p></p>

<p class=ILoutput>zzz Vijay = new yyy();<o:p></o:p></p>

<p class=ILoutput>// <o:p></o:p></p>

<p class=ILoutput>// Form1<o:p></o:p></p>

<p class=ILoutput>//<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>After creating a variable, the
next task is to initialize it. The variable Vijay is to be initialized to some
instance. Therefore, the InitExpression property of type CodeExpression is put
to use. A new CodeExpression object is created and the constructor is given a
data type of yyy. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The InitExpression property is
initialized to this CodeExpression object. This results in the object Vijay
being initialized to a new instance of the class yyy. This function performs no
error checks. Therefore, attempts to build the form in Visual Studio.Net, would
result in the generation of an error.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(zzz), &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodeObjectCreateExpression(typeof(yyy));<o:p></o:p></p>

<p class=ILprg>d.InitExpression = e;<o:p></o:p></p>

<p class=ILprg>CodeLinePragma p = new CodeLinePragma(&quot;sonal.txt&quot; ,
100);<o:p></o:p></p>

<p class=ILprg>d.LinePragma = p;<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>#line 100 &quot;sonal.txt&quot;<o:p></o:p></p>

<p class=ILoutput>zzz Vijay = new yyy();<o:p></o:p></p>

<p class=ILoutput>#line default<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The LinePragma property appends
the file name and the line number to the code in the editor. The pragma #line
requires two parameters, viz. a line number and a filename. In case of an error
in the file, the code painter resorts to its own line numbering and file name. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The pragma option allows a
modification to be effected in both, the file name and the line number, since
the code is being inserted by the code painter. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The default parameter resets the
line number to the default value of the code painter. In the above code, the
LinePragma property is initialized to the new CodeLinePragma object, whose
constructor is assigned the file name and the line number.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new CodeVariableDeclarationStatement(typeof(zzz),
&quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodeArgumentReferenceExpression
(&quot;mukhi&quot;);<o:p></o:p></p>

<p class=ILprg>d.InitExpression = e;<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILprg>private void InitializeComponent()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>zzz Vijay = mukhi;<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The CodeExpression class is a
base class for a large number of classes. The latest progressive feature to be
incorporated is that the object Vijay can be initialised to a variable or a
parameter of a function. Towards this end, the class CodeArgumentReferenceExpression
is used, and its constructor is provided with the name of the variable as a
string.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(int), &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodePrimitiveExpression (100);<o:p></o:p></p>

<p class=ILprg>d.InitExpression = e;<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>int Vijay = 100;<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The class
CodePrimitiveExpression is used whenever the value types are to be initialized
to a specific value. In the above case, Vijay is declared to be of type int and
is initialized to a value type 100.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableReferenceExpression r = new
CodeVariableReferenceExpression (&quot;mukhi&quot;);<o:p></o:p></p>

<p class=ILprg>CodeMethodInvokeExpression cm = new
CodeMethodInvokeExpression(r, &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>c.Add(cm);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>mukhi.Vijay();<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The next step is to convert
Vijay into a function and to call it off the object mukhi. Therefore, an entity
named 'r', of type CodeVariableReferenceExpression is created. This class is
used for reference purposes, and as a function in our case. Thereafter, a
CodeMethodInvokeExpression object named cm is created, and the constructor is
assigned the reference object 'r', as well as the name of the function, i.e.
Vijay. The outcome can be viewed in the code painter. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The point being driven home is
that, since the control takes on the onus of writing its own code, the user is
liberated from the necessity of comprehending a large amount of code in order
to be more productive and efficient.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableReferenceExpression r = new
CodeVariableReferenceExpression(&quot;mukhi&quot;);<o:p></o:p></p>

<p class=ILprg>CodeMethodInvokeExpression cm = new
CodeMethodInvokeExpression(r, &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpressionCollection ec = cm.Parameters;<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodePrimitiveExpression (100);<o:p></o:p></p>

<p class=ILprg>ec.Add(e);<o:p></o:p></p>

<p class=ILprg>c.Add(cm);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>mukhi.Vijay(100);<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, let us add a parameter to
the function. We start with the simplest parameter, which is the number 100, as
featured above. The Parameters property of the CodeMethodInvokeExpression
returns a CodeExpressionCollection, which is a collection of CodeExpressions.
All the CodeExpressions that we have encountered so far, are worthy of being
reused. The Add member of the Collection object permits the addition of as many
parameters to the function Vijay, as is deemed fit. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableReferenceExpression r = new
CodeVariableReferenceExpression(&quot;mukhi&quot;);<o:p></o:p></p>

<p class=ILprg>CodeMethodInvokeExpression cm = new
CodeMethodInvokeExpression(r, &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpressionCollection ec = cm.Parameters;<o:p></o:p></p>

<p class=ILprg>CodeExpression e = new CodePrimitiveExpression (100);<o:p></o:p></p>

<p class=ILprg>CodeExpression e1 = SerializeToReferenceExpression (m, v);<o:p></o:p></p>

<p class=ILprg>ec.Add(e);<o:p></o:p></p>

<p class=ILprg>ec.Add(e1);<o:p></o:p></p>

<p class=ILprg>c.Add(cm);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>mukhi.Vijay(100, this.aaa1);<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Moreover, the next variation is
that, one of the parameters to the function Vijay should be the aaa1 object, which
has just been passed to the Serialize function. In order to realize this
objective, the function SerializeToReferenceExpression from the class
CodeDomSerializer is used, which obtains the name of the object from the second
parameter of the Serialize function.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Since the parameter v represents
the object aaa1, a reference is made to this object in the code painter. The
'this' reference is inserted by the code painter.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection c = new CodeStatementCollection();<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(int []), &quot;Vijay&quot;);<o:p></o:p></p>

<p class=ILprg>CodeArrayCreateExpression a = new<span style="mso-spacerun:
yes">  </span>CodeArrayCreateExpression(typeof(int) , 10);<o:p></o:p></p>

<p class=ILprg>d.InitExpression = a;<o:p></o:p></p>

<p class=ILprg>c.Add(d);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>int[] Vijay = new int[10];<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Creating an array is easier said
than done. To create a variable Vijay of type int[], the class
CodeArrayCreateExpression is brought into play. This class creates an array of
data type int, having a size of 10. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We would sincerely recommend
that you spend some time trying to gain an insight into the CodeDom namespace.
We would also advise you to try out the classes independently. Not only are
they<span style="mso-spacerun: yes">  </span>simple and functional, but they
also augment your knowledge about the inner mechanism of compilers.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel.Design;<o:p></o:p></p>

<p class=ILprg>using System.Drawing;<o:p></o:p></p>

<p class=ILprg>using System.Windows.Forms;<o:p></o:p></p>

<p class=ILprg>using System.CodeDom;<o:p></o:p></p>

<p class=ILprg>using System.ComponentModel.Design.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Collections;<o:p></o:p></p>

<p class=ILprg>class ccc : CodeDomSerializer<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public override object Deserialize(IDesignerSerializationManager
manager, object codeObject)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>return null;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public override object Serialize(IDesignerSerializationManager
m, object v)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Serialize&quot;);<o:p></o:p></p>

<p class=ILprg>CodeDomSerializer a = <span style='font-size:9.0pt'>(CodeDomSerializer)m.GetSerializer(typeof(Component),typeof(CodeDomSerializer));</span><o:p></o:p></p>

<p class=ILprg>object c = a.Serialize(m, v);<o:p></o:p></p>

<p class=ILprg>PropertyDescriptor p = TypeDescriptor. GetProperties
(v)[&quot;Mukhi&quot;];<o:p></o:p></p>

<p class=ILprg>Control c1 = (Control)p.GetValue(v);<o:p></o:p></p>

<p class=ILprg>sss.abc(m.GetName(v));<o:p></o:p></p>

<p class=ILprg>string s = m.GetName(v) + &quot;Sonal&quot;;<o:p></o:p></p>

<p class=ILprg>CodeVariableDeclarationStatement d = new
CodeVariableDeclarationStatement(typeof(zzz), s);<o:p></o:p></p>

<p class=ILprg>d.InitExpression = new CodeObjectCreateExpression(typeof(zzz));<o:p></o:p></p>

<p class=ILprg>CodeVariableReferenceExpression r = new
CodeVariableReferenceExpression(s);<o:p></o:p></p>

<p class=ILprg>CodeMethodInvokeExpression cm = new
CodeMethodInvokeExpression(r, &quot;Bad&quot;);<o:p></o:p></p>

<p class=ILprg>CodeExpressionCollection ec = cm.Parameters;<o:p></o:p></p>

<p class=ILprg>CodeExpression e1 = SerializeToReferenceExpression(m, c1);<o:p></o:p></p>

<p class=ILprg>ec.Add(e1);<o:p></o:p></p>

<p class=ILprg>CodeExpression e2 = SerializeToReferenceExpression(m, v);<o:p></o:p></p>

<p class=ILprg>ec.Add(e2);<o:p></o:p></p>

<p class=ILprg>CodeStatementCollection st = c as CodeStatementCollection;<o:p></o:p></p>

<p class=ILprg>st.Add(d);<o:p></o:p></p>

<p class=ILprg>st.Add(cm);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>class ddd : ComponentDesigner<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>private Control c;<o:p></o:p></p>

<p class=ILprg>Control Mukhi<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>get<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Mukhi get&quot;);<o:p></o:p></p>

<p class=ILprg>return c;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>set<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Mukhi set&quot;);<o:p></o:p></p>

<p class=ILprg>c = value;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public override void Initialize(IComponent component)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;Initialize&quot;);<o:p></o:p></p>

<p class=ILprg>base.Initialize(component);<o:p></o:p></p>

<p class=ILprg>IDesignerHost h =
(IDesignerHost)GetService(typeof(IDesignerHost));<o:p></o:p></p>

<p class=ILprg>Mukhi = (Control)h.RootComponent ;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>protected override void PreFilterProperties(IDictionary p)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>sss.abc(&quot;PreFilterProperties&quot;);<o:p></o:p></p>

<p class=ILprg>base.PreFilterProperties(p);<o:p></o:p></p>

<p class=ILprg>p[&quot;zzz&quot;] =
TypeDescriptor.CreateProperty(this.GetType(), &quot;Mukhi&quot;,
typeof(Control));<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>[Designer(typeof(ddd))]<o:p></o:p></p>

<p class=ILprg>[DesignerSerializer(typeof(ccc), typeof(CodeDomSerializer))]<o:p></o:p></p>

<p class=ILprg>public class aaa : Component<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class sss<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void abc(string s) {<o:p></o:p></p>

<p class=ILprg>FileStream fs = new FileStream(&quot;c:\\a1\\a.txt&quot;,
FileMode.Append, FileAccess.Write);<o:p></o:p></p>

<p class=ILprg>StreamWriter w = new StreamWriter(fs);<o:p></o:p></p>

<p class=ILprg>w.WriteLine(s);<o:p></o:p></p>

<p class=ILprg>w.Flush();<o:p></o:p></p>

<p class=ILprg>w.Close();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>a.txt</u><o:p></o:p></p>

<p class=ILoutput>Initialize<o:p></o:p></p>

<p class=ILoutput>Mukhi set<o:p></o:p></p>

<p class=ILoutput>PreFilterProperties<o:p></o:p></p>

<p class=ILoutput>Mukhi get<o:p></o:p></p>

<p class=ILoutput>Mukhi get<o:p></o:p></p>

<p class=ILoutput>Serialize<o:p></o:p></p>

<p class=ILoutput>Mukhi get<o:p></o:p></p>

<p class=ILoutput>Mukhi get<o:p></o:p></p>

<p class=ILoutput>aaa1<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>Form1.cs</u><o:p></o:p></p>

<p class=ILoutput>zzz aaa1Sonal = new zzz();<o:p></o:p></p>

<p class=ILoutput>this.aaa1 = new aaa();<o:p></o:p></p>

<p class=ILoutput>// <o:p></o:p></p>

<p class=ILoutput>// aaa1<o:p></o:p></p>

<p class=ILoutput>// <o:p></o:p></p>

<p class=ILoutput>this.aaa1.Mukhi = this;<o:p></o:p></p>

<p class=ILoutput>aaa1Sonal.Bad(this, this.aaa1);<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'>The focal point of any control
is the Initialize function. While writing any control, this is the first
function to be overridden, since it facilitates modification of the behaviour
of the ComponentDesigner class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Firstly, a handle to the
IDesignerHost service is obtained, and then, the RootComponent property is used
to access the Form object Form1. Thus, Mukhi now represents the window or the
form, where the control aaa would be placed. The 'this' object in the code
painter is a reference to the object that is an instance of the Form1 class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>It is amply evident that the Set
accessor of the Mukhi property gets called first, and the control c is utilized
to maintain state for the control. The system then calls PreFilterProperties.
Thereafter, using the hash value zzz, a property called Mukhi is created. It is
for this reason that the presence of a property called Mukhi in the designer
class ddd is imperative. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Although the property Mukhi is
not being called directly, the system still wants to internally ascertain its
value, since the properties window is inactive. Hence, the Get accessor gets
called. The system now calls the Serialize function, as the code painter wishes
to establish how it should represent control aaa in the code. It is at this
stage that the code painter would like the control to serialize itself, or to
write out the code that represents the control. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The original Serialize function
is called, wherein the base Serialize writes the basic two lines of code. Then,
the PropertyDescriptor object p is used to retrieve the value of the property
called Mukhi. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This value is retrieved by first
calling the static GetProperties functions with the object v, which represents
the control aaa. The return value is a PropertyDescriptorCollection object, since
there may be innumerable properties present in the control. Then, with the
assistance of the indexer, the property Mukhi is accessed. The GetValue
function finally provides access to the value of the property. However, in
order to access this function, the Get accessor of the property Mukhi must be
called. This is the only possible avenue by which a property can be accessed. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>For reasons unknown, the Get
accessor is called twice. The GetName function of the manager class assigns the
name aaa1 to the control. However, we have changed it to Sonal. As a
consequence, a new variable called aaa1Sonal is created and initialized to a
new zzz object, and the system adds the line &quot;aaa1 = new aaa()&quot; to
the code. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Now, we intend to create a
function Bad with two parameters, viz. the form object and the aaa1 object, and
then, we wish to call it off the object aaa1Sonal. This is certainly a tall
order, but we shall attempt it nonetheless. The final output should look like
this:-<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>aaa1Sonal.Bad(this, this.aaa1);<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>A reference r that stands for
the string, or the object aaa1Sonal, is created first. Then, it is associated
with a method named Bad. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Once this is done, two
parameters are required. The Form1 object is passed as the first parameter. It
is stored in the control object c1, which has just been retrieved from the
property Mukhi. This renders absolute control over what is to be serialized and
how this is to be done. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Even though the Mukhi property
in the aaa1 object has not been initialized, the system is astute enough to
realize that the Mukhi property is set to the Form1 object, and it is capable
of putting two and two together!<o:p></o:p></span></p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/vs2net/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:11:05 GMT -->
</html>
