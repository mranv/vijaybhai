<html>

<!-- Mirrored from www.vijaymukhi.com/documents/books/javajsp/chap6.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:13:21 GMT -->
<head>
<title>Java-Servlets-JSP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<script type="text/javascript">
<!-- hide the script from old browsers

if((navigator.appName == "Netscape" && parseInt(navigator.appVersion) >= 3 && navigator.userAgent.indexOf("Opera") == -1 && navigator.userAgent.indexOf("WebTV") == -1) || (navigator.appName == "Microsoft Internet Explorer" && parseInt(navigator.appVersion) >= 4)) {

  for(i = 0; i < parent.frames.length; i++) {
    if(parent.frames[i].name == "code" && parent.frames[i].MTMLoaded) {
      parent.frames[i].MTMTrack = true;
      setTimeout("parent.frames[" + i + "].MTMDisplayMenu()", 250);
      break;
    }
  }
}

// End of script hiding -->
</script>
<link rel="stylesheet" href="css.css" type="text/css">
</head>

<body bgcolor="#FFFFFF">
<table border="0" cellspacing="0" cellpadding="0" width="90%" align="center" height="0%">
  <tr> 
    <td height="6146" align="left" valign="top"> 
      <table border="0" cellspacing="3" cellpadding="0" width="100%">
        <tr>
          <td bgcolor="#FFFFCC" height="32"> 
            <div align="center"><b><font size="+1">6. JSP - Servlet Code</font><br>
              as generated by JSP Engine</b></div>
          </td>
        </tr>
      </table>
      <hr>
      <p>Introduction</p>
      <p>In the previous chapter we saw how the JSP engine first creates a servlet 
        after adding the JSP code, compiles it and then finally executes it. As 
        we have already laid the foundation for servlets, we will now try to gain 
        in-depth knowledge of servlets, in the light of our newly acquired knowledge.</p>
      <p>Let's now understand servlets. To do so, we will refer to our first script 
        in the previous chapter.</p>
      <p>Open it in the browser by giving the url as <br>
        http://127.0.0.1:8080/examples/jsp/e1.jsp </p>
      <p>You will see 'hi' displayed in your browser. </p>
      <p>e1.jsp<br>
        hi</p>
      <p>This Java file is located in one of the subdirectories of the work directory.<br>
        We explained the concept of servlets in one of the previous chapters. 
        Let's understand the servlet code generated by the JSP engine by looking 
        at smaller examples.</p>
      <p>p1.java<br>
        import com.sun.jsp.runtime.*;<br>
        public class p1 extends HttpJspBase {<br>
        }<br>
        Here, there is only one public class called p1 that extends HttpJspBase. 
        Since the class is called p1, you have no choice but to call the file 
        p1.java. This program is in c:\jswdk-1.0.1\webpages\web-inf\servlets. 
        The name of the class is not HttpJspBase but com.sun.jsp.runtime.HttpJspBase, 
        therefore we have to use the import statement. </p>
      <p>All code can be either in a .class file or in a .jar file. We have no 
        choice but to point the environmental variable named classpath to the 
        jar file or jar subdirectory so the compiler looks for the code there. 
        A jar file is a collection of .class files. We have set the CLASSPATH 
        to servlet.jar and jspengine.jar which are in the lib subdirectory and 
        the current directory. To compile, we now say javac p1.java</p>
      <p>Set CLASSPATH=c:\jswdk-1.0.1\lib\servlet.jar;c:\jswdk-1.0.1\lib\jspengine.jar;.;%CLASSPATH%</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;javac p1.java<br>
        p1.java:2: class p1 must be declared abstract. It does not define void 
        _jspService(javax.servlet.http.HttpServletRequest, avax.servlet.http.HttpServletResponse) 
        from class com.sun.jsp.runtime.HttpJspBase.<br>
        public class p1 extends HttpJspBase {<br>
        ^<br>
        1 error</p>
      <p>HttpJspBase is an abstract class and has one function named _jspService. 
        Since p1 extends HttpJspBase, p1 must define this class. Thus to eliminate 
        the error, we must add this to our next program. </p>
      <p>p1.java<br>
        import com.sun.jsp.runtime.*;<br>
        public class p1 extends HttpJspBase {<br>
        public void _jspService(HttpServletRequest request,HttpServletResponse 
        response) {<br>
        }<br>
        }<br>
        C:\jswdk-1.0.1\webpages\WEB-INF\servlets &gt;javac p1.java<br>
        p1.java:2: class p1 must be declared abstract. It does not define void 
        _jspService(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse<br>
        ) from class com.sun.jsp.runtime.HttpJspBase.<br>
        public class p1 extends HttpJspBase {<br>
        ^<br>
        p1.java:3: Class HttpServletResponse not found.<br>
        public void _jspService(HttpServletRequest request,HttpServletResponse 
        response<br>
        ) {<br>
        ^<br>
        p1.java:3: Class HttpServletRequest not found.<br>
        public void _jspService(HttpServletRequest request,HttpServletResponse 
        response<br>
        ) {<br>
        ^<br>
        3 errors</p>
      <p>_jspService is the same service that we have been using all this time. 
        doGet and service both belong to the same category. This function takes 
        two parameters, HttpServletRequest and HttpServletResponse. Hence we import 
        javax.servlet.http.* and since we will be using PrintWriter in the program, 
        we import java.io.* too. Now everything should work fine. </p>
      <p>p1.java<br>
        import com.sun.jsp.runtime.*;<br>
        import javax.servlet.http.*;<br>
        import java.io.*;<br>
        public class p1 extends HttpJspBase {<br>
        public void _jspService(HttpServletRequest request,<br>
        HttpServletResponse response) {<br>
        try<br>
        {<br>
        response.setContentType(&quot;text/html&quot;);<br>
        PrintWriter out = response.getWriter();<br>
        out.println(&quot;&lt;b&gt; Hi &quot;);<br>
        out.close();<br>
        }<br>
        catch ( Exception e ) {System.out.println(&quot;bye&quot;);}<br>
        }<br>
        }</p>
      <p>Run this program in the browser by typing<br>
        http://127.0.0.1:8080/servlet/p1</p>
      <p>/servlet is converted to c:\jswdk-1.0.1\webpages\web-inf\servlets</p>
      <p>This program now works like a servlet. A servlet will work in the same 
        manner whether it is derived from Servlet or GenericServlet or HttpServlet 
        or from HttpJspBaseServlet.</p>
      <p>Having understood this, let's check out a more complex program. </p>
      <p>p2.java<br>
        import java.io.*;<br>
        public class p2<br>
        {<br>
        public static void main(String argv[])<br>
        {<br>
        try {<br>
        char a[][] = {<br>
        { 'a','b','c' },{ 'd','e','f' }};<br>
        FileOutputStream fos =<br>
        new FileOutputStream(&quot;c:\\jswdk-1.0.1\\webpages\\web-inf\\servlets\\e.dat&quot;);<br>
        ObjectOutputStream oos = new ObjectOutputStream(fos);<br>
        oos.writeObject(a);<br>
        oos.close();<br>
        }<br>
        catch (Exception e)<br>
        {System.out.println(&quot;bye&quot;);e.getMessage();<br>
        }<br>
        }<br>
        }<br>
        C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;javac p2.java</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;java p2</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;dir *.dat</p>
      <p> Volume in drive C is SONAL<br>
        Volume Serial Number is 0661-13EE<br>
        Directory of C:\jswdk-1.0.1\webpages\WEB-INF\servlets</p>
      <p>E DAT 73 06-13-00 8:28p e.dat<br>
        1 file(s) 73 bytes<br>
        0 dir(s) 2,651.09 MB free</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;type e.dat<br>
        1/4_ -ur [[C&yuml;2~+#i_- xp ur [C_&amp;f__]&auml;1/4 xp a b cuq ~ d e 
        f</p>
      <p>Here, FileOutputStream creates a file named e.dat in the servlets subdirectory. 
        Then we write 'abc' and 'def' in it. These two strings are written as 
        chars to disk. </p>
      <p>The next program follows up the previous one, which assumes that you 
        have written an array of chars to the file e.dat. So in our next program, 
        we are merely picking them up and displaying them. First we find out how 
        many members are present in the file and then we display each of them. 
      </p>
      <p>p3.java<br>
        import java.io.*;<br>
        public class p3<br>
        {<br>
        public static void main(String argv[])<br>
        {<br>
        try<br>
        {<br>
        char a[][];int i;<br>
        FileInputStream fos = new FileInputStream(&quot;c:\\jswdk-1.0.1\\webpages\\web-inf\\servlets\\e.dat&quot;);<br>
        ObjectInputStream oos = new ObjectInputStream(fos);<br>
        a = (char [][] ) oos.readObject();<br>
        System.out.println(a.length);<br>
        for ( i=0; i&lt;a.length;i++)<br>
        System.out.println(a[i]);<br>
        }<br>
        catch (Exception e){System.out.println(&quot;bye&quot;);e.getMessage();}<br>
        }<br>
        }</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;javac p3.java</p>
      <p>C:\jswdk-1.0.1\webpages\WEB-INF\servlets&gt;java p3<br>
        2<br>
        abc<br>
        def</p>
      <p>These small programs explain certain points required to understand the 
        main program. So now let's understand the servlet written by the JSP engine.<br>
        p4.java<br>
        import javax.servlet.jsp.*;<br>
        import com.sun.jsp.runtime.*;<br>
        import javax.servlet.http.*;<br>
        import java.io.*;<br>
        import com.sun.jsp.JspException;<br>
        public class p4 extends HttpJspBase {<br>
        public void _jspService(HttpServletRequest request,<br>
        HttpServletResponse response) throws IOException,JspException {<br>
        JspFactory _jspxFactory = null;<br>
        PageContext pageContext = null;<br>
        JspWriter out = null;<br>
        try<br>
        {<br>
        _jspxFactory = JspFactory.getDefaultFactory();<br>
        pageContext = _jspxFactory.getPageContext(this, request, response,&quot;&quot;, 
        true, 8192, true);<br>
        out = pageContext.getOut();<br>
        response.setContentType(&quot;text/html&quot;);<br>
        out.print(&quot;&lt;b&gt;Hie.... &quot;);<br>
        out.print(out.getBufferSize());<br>
        } catch (Throwable t) {<br>
        if (out.getBufferSize() != 0)<br>
        out.clear();<br>
        throw new JspException(&quot;Unknown exception: &quot;, t);<br>
        } finally {<br>
        out.flush();<br>
        _jspxFactory.releasePageContext(pageContext);<br>
        }<br>
        }<br>
        }</p>
      <p>Output in browser<br>
        Hie.... 8192</p>
      <p>Run the above as </p>
      <p>http://127.0.0.1:8080/servlet/p4</p>
      <p>and compare the above code with that generated by the jsp engine. They 
        are identical.</p>
      <p>The JSP engine calls the _jspService function in the servlet for any 
        task that is to be performed. Here, we first create an object _jspFactory 
        that looks like JspFactory. JspFactory is a class and to use it we add 
        two imports statements. </p>
      <p>It is important to know which import statements are required for the 
        classes used in the program. To avoid all these permutations and combinations, 
        we have given all the imports that we think are appropriate._jspFactory 
        is initialized to the return value of getDefaultFactory. JspFactory like 
        System is a class. It has a static function getDefaultFactory, which returns 
        an object that looks like JspFactory. <br>
        JspFactory has a member named getPageContext that manages a page. For 
        the moment, we will leave the parameters aside. This function returns 
        a pageContext which has a member named getOut, used for writing purposes. 
        getOut returns an object that looks like JspWriter, which we store in 
        out. Here, we have JspWriter instead of PrintWriter, but both are the 
        same. out.println is used to write text and out also has one more function 
        named getBufferSize. getBufferSize returns 8192 because that is the buffer 
        size we have given in pageContent. If an error is encountered at any point 
        then catch will be called. </p>
      <p>Exception is derived from Throwable. The base class is Throwable and 
        all exceptions are derived from it. We first check the buffer size and 
        if it is not equal to 0, we clear the buffer. Anything in the buffer will 
        now be over-written. Then we throw the exception jspException (we have 
        imported com.sun.jsp.JspException.) After this has been done, out.flush 
        will flush the buffer and releasePageContext will release the pageContext.</p>
      <p>Here, JspWriter is performing the job of PrintWriter. Effectively, they 
        are the same; there is no difference between them.</p>
      <p>p5.java<br>
        import javax.servlet.*;<br>
        import javax.servlet.http.*;<br>
        import javax.servlet.jsp.*;<br>
        import java.io.PrintWriter;<br>
        import java.io.IOException;<br>
        import java.io.FileInputStream;<br>
        import java.io.ObjectInputStream;<br>
        import java.util.Vector;<br>
        import com.sun.jsp.runtime.*;<br>
        import java.beans.*;<br>
        import com.sun.jsp.JspException;<br>
        public class p5 extends HttpJspBase {<br>
        static char[][] _jspx_html_data = null;<br>
        private static boolean _jspx_inited = false;<br>
        public final void _jspx_init() throws JspException {<br>
        ObjectInputStream oin = null;<br>
        int numStrings = 0;<br>
        try {<br>
        FileInputStream fin=new<br>
        FileInputStream(&quot;c:\\jswdk-1.0.1\\webpages\\web-inf\\servlets\\e.dat&quot;);<br>
        oin = new ObjectInputStream(fin);<br>
        _jspx_html_data = (char[][]) oin.readObject();<br>
        } catch (Exception ex) {<br>
        throw new JspException(&quot;Unable to open data file&quot;);<br>
        } finally {<br>
        if (oin != null)<br>
        try { oin.close(); } catch (IOException ignore) { }<br>
        }<br>
        }<br>
        public void _jspService(HttpServletRequest request,<br>
        HttpServletResponse response)<br>
        throws IOException, ServletException {<br>
        JspFactory _jspxFactory = null;<br>
        PageContext pageContext = null;<br>
        HttpSession session = null;<br>
        ServletContext application = null;<br>
        ServletConfig config = null;<br>
        JspWriter out = null;<br>
        Object page = this;<br>
        String _value = null;<br>
        try {<br>
        if (_jspx_inited == false) {<br>
        _jspx_init();<br>
        _jspx_inited = true;<br>
        }<br>
        _jspxFactory = JspFactory.getDefaultFactory();<br>
        response.setContentType(&quot;text/html&quot;);<br>
        pageContext = _jspxFactory.getPageContext(this, request, response,&quot;&quot;, 
        true, 8192, true);<br>
        application = pageContext.getServletContext();<br>
        config = pageContext.getServletConfig();<br>
        session = pageContext.getSession();<br>
        out = pageContext.getOut();<br>
        out.print(_jspx_html_data[0]);<br>
        System.out.println(_jspx_html_data[0]);<br>
        } catch (Throwable t) {<br>
        if (out.getBufferSize() != 0)<br>
        out.clear();<br>
        throw new JspException(&quot;Unknown exception: &quot;, t);<br>
        } finally {<br>
        out.flush();<br>
        _jspxFactory.releasePageContext(pageContext);<br>
        }<br>
        }<br>
        }</p>
      <p>In this program, all that we have done is, within _jspService we have 
        created 3 more objects, session, application and config. Like the earlier 
        program, getPageContext returns pageContext. pageContext has a function 
        which will create the respective object and then initialize session, application 
        and config. </p>
      <p>Before all this is done, the if statement checks whether _jspx_inited, 
        a static variable, holds a true or false. The first time it holds false, 
        so _jspx_init is called. This function has an object that looks like ObjectInputStream. 
        We now open a file named e.dat which we created a little while ago. This 
        entire file is read into _jspx_html_data, an array of chars, using FileInputStream. 
        In case an error is encountered, an exception is thrown and finally, the 
        file is closed. All this has been explained individually earlier, so we 
        won't explain it again.<br>
        <br>
        Once the function is called, _jspx_inited is made true so that the function 
        is not called again. In the main code, there is an out.print for _jspx_html_data[0]. 
        This is the only new statement added. This array had been initialized 
        in _jspx_init with the contents of e.dat. So when you run this servlet, 
        it will show you abc in the browser because jspx_html_data [0] is the 
        first array and jspx_html_data [1] is the second array. <br>
      </p>
      <p></p>
      <p></p>
      <p></p>
      <hr>
    </td>
  </tr>
</table>
  
<table border="0" cellspacing="3" cellpadding="0" align="center">
  <tr> 
    <td> 
      <div align="center"><font size="-1"><font size="-2" face="Verdana, Arial, Helvetica, sans-serif"><a href="contents.html">Contents</a> 
        | <a href="foreword.html">Foreword</a> | <a href="about.html">About the 
        Authors</a> | <a href="intro.html">Introduction</a> |</font></font><font size="-2" face="Verdana, Arial, Helvetica, sans-serif"><br>
        <a href="chap0-2.html">Appendix</a> |<a href="chap1.html">Chapter 1</a> |<a href="chap2.html">Chapter 
        2</a> |<a href="chap3.html">Chapter 3</a> |<a href="chap4.html">Chapter 
        4</a> |<a href="chap5.html">Chapter 5</a> |<a href="chap6.html">Chapter 
        6</a> |<br>
        <a href="chap7.html">Chapter 7</a> |<a href="chap8.html">Chapter 8</a> 
        |<a href="chap9.html">Chapter 9</a> |<a href="chap10.html">Chapter 10</a> 
        |<a href="chap11.html">Chapter 11</a></font></div>
    </td>
  </tr>
</table>
</body>

<!-- Mirrored from www.vijaymukhi.com/documents/books/javajsp/chap6.html by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:13:21 GMT -->
</html>
