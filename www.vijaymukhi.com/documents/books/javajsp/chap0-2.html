<html>

<!-- Mirrored from www.vijaymukhi.com/documents/books/javajsp/chap0.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:41:56 GMT -->
<head>
<title>Java-Servlets-JSP</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<script type="text/javascript">
<!-- hide the script from old browsers

if((navigator.appName == "Netscape" && parseInt(navigator.appVersion) >= 3 && navigator.userAgent.indexOf("Opera") == -1 && navigator.userAgent.indexOf("WebTV") == -1) || (navigator.appName == "Microsoft Internet Explorer" && parseInt(navigator.appVersion) >= 4)) {

  for(i = 0; i < parent.frames.length; i++) {
    if(parent.frames[i].name == "code" && parent.frames[i].MTMLoaded) {
      parent.frames[i].MTMTrack = true;
      setTimeout("parent.frames[" + i + "].MTMDisplayMenu()", 250);
      break;
    }
  }
}

// End of script hiding -->
</script>
<link rel="stylesheet" href="css.css" type="text/css">
</head>

<body bgcolor="#FFFFFF">
<table border="0" cellspacing="0" cellpadding="0" width="90%" align="center">
  <tr> 
    <td height="32807" align="center" valign="middle">
      <table border="0" cellspacing="3" cellpadding="0" width="100%">
        <tr>
          <td bgcolor="#FFFFCC"> 
            <div align="center"><b><font size="+1">Shlurrrpp......Java </font></b> 
            </div>
          </td>
        </tr>
      </table>
      <hr>
      <p>Men are amused by anything. That is why professional ice hockey is so 
        popular. That is why Disneyland runs into lengthier balance sheets than 
        the scientific museums. And that is why something like Java is touted 
        as the next Glasnost (well, unless you are a snoozebucket, you are probably 
        aware of Java, the language that is bowling the world over). Make way. 
        Here comes the stuff our forefathers warned us about. It is mightier than 
        the sword, the pen and usually, the programmer. A thousand and one news-breakers 
        and articles have done their rounds on how Java is invariably an isotope 
        of C++ minus the warts and pimples, on how it is going to give the Internet 
        an upbeat facelift, on how...... </p>
      <p>But wait. The last thing you want to do is to sit back and worship the 
        greatness of a language; you want to use it. The one sad hitch with today's 
        software is that the so-called tutorials and manuals are scarcely meant 
        for anyone to understand. Take the samples bundled with Java for instance. 
        How would you like the idea of brooding over a hundred-line sample code 
        to begin with? What these codes fail to do is spark an interest among 
        the wide-eyed newbies. ( Between you and me, I suspect that is the state-of-the-art 
        way of doing graffitti on aspiring programmers :) ). </p>
      <p>That's precisely what we aim to do here - to give you the first few sips 
        of Java (seasoned not to burn your tongue). Our approach is simple. As 
        far as possible, we will add a line at a time and expect you to try it 
        out (if we exceed that, we apologize). The worst thing that could happen 
        by trying to learn programming in this way is that we might lead to grazing 
        down of a few more trees (we will use more paper, right). But at least 
        we can comprehend the language better. </p>
      <p>Undoubtedly, Java has flung open a whole slew of possibilities to spruce 
        up a page on the Internet. Every little Johnny in the world, who has anything 
        close to a GK, knows that Java can change lives. <i><b>How</b></i> is 
        the question. Before we begin, let us make a few things clear. First, 
        to learn programming in Java, it is undoubtedly a prerequisite to have 
        a passing knowledge of C++ or we'd rather you sit over the weekend with 
        a load of beer and cheetos in the fridge and atleast a dozen aspirins 
        in the drawer :) . Secondly, the programs in Java here are explained in 
        a simple, understandable manner and hence anybody expecting a display 
        of rhetorical caliber is in for a disappointment of his lifetime. Just 
        like an artist's potrait speaks for itself, we'd rather have Java speak 
        for itself too. Third, while each concept is clearly explained, we prefer 
        to keep our distance from the 'gears and cogs' of the language. And yes, 
        it is also assumed you have downloaded the Java Develoment Kit. (For those 
        who came in late, the software can be downloaded from the address <a href="http://www.javasoft.com/">http://www.javasoft.com</a> 
        ) </p>
      <p><b>Some Conventions that we swear by</b></p>
      <center>&quot; The essence of magic is simplicity &quot; </center>
      <p>We are not concerned with inculcating obedience or influencing the programming 
        style of our readers; quite the contrary, we intend the development of 
        initiative. The simplicity that will inevitably be exhibited in our code 
        and explanation is merely a method to refrain from pedantic. The idea 
        is not to win a prize in computer literature but to shorten your learning 
        curve. The naming conventions that we will adhere to include: </p>
      <p>The variables that we use will be of one letter, for instance i, j, g 
        etc. <br>
        The functions will be of two letters, e.g., aa() , bb() etc. <br>
        The class names will be three letters, e.g., zzz etc. </p>
      <p>When we started learning java 5 years ago, we made an attempt to put 
        up tutorials relating to different aspects of Java programming language 
        on http://www.vijaymukhi.com. Since it was ranked as one of the best online 
        tutorials then, we have decided to add a few of these tutorials to our 
        very first book on Java. A lot has changed since then but most of the 
        code written still works. We would like to thank our writer then, <b>'Shashank 
        Tripathi' </b>for having used the best langauge and vocabulory thereby 
        making it an interesting readable literature.</p>
      <p>PS: Some programs will repeat in a few chapters, but the explanation 
        given here will give you a different insight into this widely used language.</p>
      <p><font size="+1"><b><i><u>Applets</u> <br>
        </i></b></font><br>
        <b>A Tweak of Lemon...</b></p>
      <p><i><b>&quot;Ours is the age of substitutes; instead of principles, we 
        have slogans; instead of genuine ideas, bright ideas; instead of languages, 
        jargon. &quot; </b></i></p>
      <p>When it comes to bright jargon, Sun Microsystems has left no stone unturned. 
        And the creative terminology goes a long way (if not all the way) in making 
        it like the tidal wave it has been. Java programs are called 'Applets'. 
        In the directory in which the whole downloaded software of Java is saved, 
        there is a subdirectory called Bin. This is where we have the Java compiler 
        called 'Javac.exe'. The first thing we do is to create a subdirectory 
        under the root called, say, &quot;xxx&quot;. Then set the path to \(javadirectory)\bin. 
        We are going to write our Applets here. Each applet or program has to 
        be written in a file with the extension of .java. In keeping with the 
        ritual, let us consider this one-liner code first...</p>
      <p>a1.java<br>
        class zzz<br>
        {<br>
        }</p>
      <p>You'll agree that even an ice-hockey player or a visitor to Disneyland 
        will love this sort of a program because it is looks manageably concise 
        and absolutely simple. Well, we do not expect fireworks with that sort 
        of a code, but let us compile it all the same. Save the file a1.java. 
        It is noteworthy to mention here that like C/C++, Java is case-sensitive 
        too (and preposterously so!). Type the command javac a1.java. The compiler 
        gives no errors. If you key in the DIR command now, you will see that 
        after successful compilation, a file called zzz.class is made automatically. 
        That is because we specified zzz as the name of our class. This makes 
        it adequately clear that the name of the applet file (the .java file) 
        and the class can very well be different. </p>
      <p>Now comes the question of viewing how our applet works. If it is a Java 
        applet, you can call it only from an HTML file (An HTML file, in case 
        you don't know, is nothing but a text file with tags that link it to other 
        documents). Since all the documents on the Internet use this format, an 
        applet has to be specified in an HTML file. Consider the following HTML 
        file. </p>
      <p>aa.html<br>
        &lt;applet code=&quot;zzz&quot; width=120 height=120&gt;<br>
        &lt;/applet&gt;</p>
      <p>As is evident, the .class file (zzz.class in our case) that is formed 
        after successful compilation of the .java file (a1.java) is specified 
        in the HTML file alongwith the width and the height This is the way in 
        which you can incorporate an applet in the HTML format. The applet could 
        be a program to display animation or perform any other dynamic task and 
        thus, enliven a page on the net. </p>
      <p>But it still remains to be seen how the applet works or what the output 
        looks like. Towards this end, we have a program called the appletviewer 
        (in the same directory as javac). This is a program that allows you to 
        view how your applet works. Hence, we key in the command appletviewer 
        aa.html. Sorry folks, but there is no output (if your stars are not happy 
        with you, your machine might even hang!). </p>
      <p>There are a hundred and sixty five things to be done in the background 
        before our class begins work (like the initialization routines et al). 
        Our class does not have any property towards that end. As one does not 
        know what routines are to be initialized internally, the safest thing 
        to do is to derive a class from another class provided with the language. 
        Now edit your a1.java file in the following way.</p>
      <p>a1.java<br>
        class zzz extends Applet<br>
        {<br>
        }</p>
      <p>Applet is a class that has all the required functions necessary for this 
        purpose, so we derive zzz from Applet or extend zzz to Applet. This means, 
        in plain English, that we can now use all the functions and variables 
        of the Applet class and also add our own ones. The only hitch now is that 
        compiler refuses to recognize Applet, unless we mention specifically the 
        name of the class library in which it is contained. So we now have to 
        formally introduce the compiler to the Applet class. We do this by inviting 
        the Applet class into our program (how else?). Only, the invitation here 
        is in the form of importing a file called Applet.class from the classes.zip 
        which is within a java subdirectory.<br>
        a1.java<br>
        import java.applet.*<br>
        class zzz extends Applet<br>
        {<br>
        }</p>
      <p>When we compile this program, however, we get some lines of dreadful 
        errors, with only one making any sort of horse-sense, &quot; ; expected&quot;. 
        Guess what, we missed out on the elusive semicolon after the import statement! 
        Remember, this is a sibling of C and C++ and the use of semicolon is inevitable. 
        And hence, our program now looks like this...<br>
        a1.java<br>
        import java.applet.*;<br>
        class zzz extends Applet<br>
        {<br>
        }</p>
      <p>However, having put that necessary punctuation, when we compile and run 
        the program again, it gives the error that the 'class not public'. As 
        a result, the applet is not initialized. That brings us to another important 
        feature of Java, as it stands today. All the classes that we define have 
        to be public, otherwise the class cannot be initialised by the Appletviewer. 
        Not being the arguing types, we make our class public in the following 
        way...</p>
      <p>a1.java<br>
        import java.applet.*;<br>
        public class zzz extends Applet<br>
        {<br>
        }</p>
      <p>One snag with making a class public is that the name of your file and 
        that of the class have to be the same. So after adding the word public, 
        rename a1.java to zzz.java. </p>
      <p>&gt; ren a1.java zzz.java</p>
      <p>Before you begin to swear about this queue of unending snags, let us 
        state that this is it. We finally have what can be safely labeled as the 
        smallest Java program. Now compile the new java file using javac and when 
        we key in the command appletviewer aa.html, a small window appears to 
        show the output. This is the first successful applet and all the economists 
        out there would love it. Because it is concise, precise and absolutely 
        useless ( :-) ). As we are not economists and expect our applet to do 
        something, let us make some additions. But to continue further, we have 
        to quit from the appletviewer. For this, click on the Applet menu that 
        you see in the appletviewer window and select Quit.<br>
        zzz.java<br>
        import java.applet.*;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { resize(300, 500);<br>
        }<br>
        }<br>
        All the functions in our class have to be public. The function init() 
        gets called initially when you run an applet. Whenever your applet begins 
        and you need to do something put it in the init(). Inside this, we have 
        the resize() which is one of the many functions of the Applet class. It 
        is used to change the size of the area in which our applet can work. By 
        default, a small area is given to the applet but the resize() says &quot;Give 
        me two parameters, the width and the height and I can increase or decrease 
        the scope of your applet&quot;. We obediently pass two parameters to this 
        function, the width of the area(300) and the height(500). When we compile 
        and run the above program, we can see a rectangular box as an output. 
        As yet, we have just plain specified the area for the applet, now let 
        us try displaying something inside it...<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.* ;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawString(&quot;Hello&quot;, 10, 50);<br>
        }<br>
        }</p>
      <p>As you must have realized, this program displays &quot;Hello&quot; at 
        the coordinates 10, 50. As mentioned earlier, the init () gets called 
        first. The workarea is resized in the same way as before. Everytime the 
        screen or the window has to be displayed, the paint() gets called. You 
        cannot set your watch by it. An object g that looks like the class Graphics 
        has to be tagged along as a parameter. As Graphics is a predefined class, 
        we require to import the Graphics class, (which is in classes.zip ). The 
        Graphics class has many functions including the drawString(). Give this 
        function its due in the form of three parameters, the string to be displayed, 
        and the x and the y coordinates and promises to display the string at 
        that position. So when the paint is called, &quot;Hello&quot; appears 
        on the screen. </p>
      <p><br>
        Now that we are aware of the method of displaying, let us write a program 
        that is a little more interesting. We propose to display a string and 
        a value everytime the Mouse is clicked. Key in the following code... <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { int i;<br>
        public void init()<br>
        { resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawString(&quot;i.....&quot; + i, 10, 50);<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        { i++;<br>
        repaint();<br>
        return true;<br>
        } <br>
        }</p>
      <p>When you compile this java file, you will get one warning. Warnings can 
        be ignored for the time being. </p>
      <p>Let us start from the very beginning. A variable i is defined before 
        any other function. This make sure that the variable can be used in any 
        function (for you C++ programmers out there, it is similar to a public 
        variable). A very interesting feature is the mouseUp(). Every time you 
        click with the mouse, the mouseUp() gets called. The mouseUp() is counted 
        upon to return a True or false. And that is the reason why that ugly word 
        'Boolean' comes into picture (which will be explained at a later stage). 
        Note that the mouseUp() accepts three parameters. The Event is irrelevant 
        to explain at this point of time and it will be explained later with a 
        useful example. The other parameters are x and y coordinates, which are 
        internally calculated everytime the mouse is clicked. That is, if i click 
        at, say, the position (15, 20), then the value of x will automatically 
        become 15 and that of y will be 20. With every click the value of i is 
        increased by 1. Then the repaint() is called, which in turn calls the 
        paint(). This way, with each click we display the string &quot;i....&quot; 
        followed by the value of i. The drawString() takes care of that. Note 
        the plus sign (+), it is used to concatenate or join two strings to be 
        displayed. </p>
      <p>They said programming in Java is object-oriented and event-driven. That 
        sent my brains for a toss when I first heard it, but the above program 
        bears a glittering testimony to that. The function mouseUp() gets activated 
        everytime the mouse button is clicked, the paint() is called whenever 
        a window or a screen has to be redrawn etc.</p>
      <p>Let us alter this code to display our usual &quot;Hello&quot;, but now 
        at the coordinates where the user clicks. Change the code in zzz.java 
        as the following..<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.* ;<br>
        public class zzz extends Applet<br>
        { int a; int b;<br>
        public void init()<br>
        { resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawString(&quot;Hello&quot;, a, b);<br>
        }<br>
        public boolean mouseUp(Event evt, int x, int y) <br>
        { a=x; b=y;<br>
        repaint();<br>
        return true;<br>
        }<br>
        }</p>
      <p>Here, a and b are public variables as they are defined outside all the 
        functions. When a variable is public, it can be used inside any function. 
        The logic to the above applet is pretty simple. Everytime the mouse is 
        clicked, the mouseUp() function is called. We can get to know the coordinates 
        where the user has clicked because the coordinates are stored automatically 
        in x and y. These values are assigned to a and b. Now when the repaint() 
        is called, it calls the paint(). Here, the drawString() will display &quot;Hello&quot; 
        at the specified position. But since the specified coordinates are nothing 
        but the coordinates of the place where the user has clicked (a and b), 
        &quot;Hello&quot; will now be displayed at the position where the user 
        clicks. </p>
      <p>Our next program draws a line between two clicks of the mouse. That is, 
        a line is drawn between the first and the second click, the third and 
        the fourth click and so on. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.* ;<br>
        public class zzz extends Applet<br>
        { int a; int b; int c; int d; int e;<br>
        public void init()<br>
        { resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawLine(a, b, d, e);<br>
        }<br>
        public boolean mouseUp(Event evt, int x, int y) <br>
        { if (c==0)<br>
        {<br>
        a=x;<br>
        b=y;<br>
        c=1; <br>
        }<br>
        else<br>
        {<br>
        d=x;<br>
        e=y;<br>
        c=0;<br>
        repaint();<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p><br>
        We define five public variables a, b, c, d and e. The paint() is called 
        by default for the first time. It is passed four parameters, the x and 
        y coordinates of the points between which the line has to be drawn, i.e. 
        the two endpoints of the line. But since the four variables a, b, d and 
        e are currently zero, initially there is no line displayed. Whenever the 
        user clicks with the mouse, mouseUp() functions gets called. A variable 
        c takes care of the fact whether the click is for the first or the second 
        time. If the click is for the first time (i.e if c is 0), a and b are 
        given the value of x and y. These are the points of the first end of the 
        line. Then c is made 1. The second time the user clicks, c is 1. Therefore, 
        d and e given the values of x and y. c is made 0 again. And the repaint() 
        is called. Now when the paint() is called by the repaint(), the drawLine() 
        will draw a line from (a, b) - the position of the first click, to (c, 
        d) - the position of the second click. In this way, the value of c can 
        be alternated and a line drawn between two successive clicks. <br>
        <br>
        <font size="+1"><b>Making the clouds look good - Images </b></font></p>
      <p>Let us face it, drawing a line is too dry a thing to do; so let us move 
        on to displaying an image on the screen. And to write an applet that displays 
        an image is simpler than you ever feared. Consider this code... </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Image n;<br>
        public void init()<br>
        { n = getImage(getCodeBase(), &quot;cow.gif&quot;);<br>
        resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawImage(n, 10, 15, this);<br>
        }<br>
        }</p>
      <p><br>
        As is amply apparent, the basic structure of the program remains the same. 
        An object n that looks like the class Image is defined. Inside the init(), 
        n is initialised to an image called &quot;cow.gif&quot; which exists on 
        our hard disk. (PS Check up the \demo directory for more .gif files; gif 
        files are nothing but images). This is done with the getImage() that is 
        a member of the Applet class. As n looks like the class Image, it can 
        use the member functions of that class. The getImage() accepts two parameters, 
        the getCodeBase() and the name of the .gif file. Now, n contains the image 
        &quot;cow.gif&quot;. So when the paint() is called using g (which looks 
        like Graphics), we can use n to display the image. The Graphics class 
        has a member function called drawImage(), which is used to actually draw 
        the image (n) on to the screen. This takes four parameters. First is the 
        image that we wish to draw, as is n in our case. The second and the third 
        are the coordinates where we want the image to be displayed. The fourth 
        parameter is this. If you are a C/C++ programmer, you are well-versed 
        with this, but for the rest it should suffice right now to say that this 
        refers to the current object ( pun unintended :-) ).</p>
      <p>Now, the same image can be displayed at the coordinates where the user 
        clicks by using the mouseUp() and trapping the coordinates where the mouse 
        was clicked. If you have not got it already, the code for this will be..</p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.* ;<br>
        public class zzz extends Applet<br>
        { Image n;<br>
        int a; int b;</p>
      <p> public void init()<br>
        { n = getImage(getCodeBase(), &quot;cow.gif&quot;);<br>
        resize(300, 500);<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawImage(n, a, b, this); <br>
        }</p>
      <p> public boolean mouseUp(Event e, int x, int y)<br>
        { a=x;<br>
        b=y;<br>
        repaint();<br>
        return true;<br>
        }<br>
        }</p>
      <p><b><font size="+1">At Work Then</font></b></p>
      <p><b>Straight dope on The Abstract Windows Toolkit </b></p>
      <p>If your most fiendish nightmare is drowning in a bowl of alphabet soup, 
        maybe you'd better re-think your Java-oriented strategies; because you 
        are about to leap into a scaffold of functions that come wrapped up, ribbon 
        and all, to help you give that graphical look! And yep, from a fairly 
        prudent perspective, The Abstract Windows Toolkit as it is called, with 
        its horde of teeny-weeny functions, does indeed provide the underpinnings 
        for the user-friendly Graphic interface. In this section, we will tinker 
        with these little widgets that come bunched up as the AWT. Before embarking 
        on any sort of coding, let us look at the following diagram... </p>
      <p><u><b>Button</b></u><br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { add(new Button (&quot;hell&quot;));<br>
        }<br>
        }</p>
      <p>In the init(), we add a button called &quot;hell&quot;. When you run 
        this program, you will see a button with the name (or the label ) &quot;hell&quot; 
        on the screen. That's not great shakes afterall, but you just wrote your 
        first AWT program! </p>
      <p><b><u>TextField</u></b><br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { add(new TextField());<br>
        }<br>
        }</p>
      <p>Like running the earlier program presented you with a button, this one 
        will give you a text field. That is nothing but a single line edit box 
        on the screen. Well, I don't mind going on like that for each and every 
        wee feature, showing you one new thing at a time, but its the space that 
        counts (not to mention your patience). Hence, I guess it should suffice 
        to say that like the above objects,i.e, Button and Textfield, the following 
        can also be created. </p>
      <p><u><b>TextArea </b></u></p>
      <p>add(new TextArea());</p>
      <p>This is similar to a huge text field, that is, it covers a larger area 
        than the Textfield. While trying the text area, I'd rather you maximise 
        the applet window because it comes like a multiple line edit box on the 
        screen. </p>
      <p><b><u>Choice </u></b></p>
      <p>add(new Choice());</p>
      <p>Choice is a word straight out from the Jargon Dump (which, incidentally, 
        is the favourite hang-out of the techno-nerds!). A Choice() adds a drop 
        down list box. </p>
      <p><b><u>List </u></b><br>
        add(new List());</p>
      <p>This will display a dry list box displayed on the screen. Dry because 
        there will be no options given. (Well you wouldn't want to use their options 
        anyway). </p>
      <p><b><u>Checkbox </u></b></p>
      <p>add(new Checkbox()); </p>
      <p>Unless you bought your computer to serve as the world's most expensive 
        doorstop, you are well-versed with the check-boxes. In Java, this is the 
        way you create your own checkboxes. CheckboxGroup :The Windows aficionados 
        know it as the radio-buttons. </p>
      <p><u><b>Scrollbar </b></u></p>
      <p>add(new Scrollbar()); </p>
      <p>Remember how you scroll through your love letters? Well, ulterior motives 
        aside, you are well-versed with the scrollbars (unless ofcourse, your 
        fiancee is a DOS-diehard). </p>
      <p><b><u>Label </u></b></p>
      <p>add(new Label(&quot;Good&quot;)); </p>
      <p>Here, let us meet the most drab member of the AWT family. Just plain 
        text that drawls on the screen whatever you pass it as a parameter. </p>
      <p><b><font size="+1">Actually Getting down to work</font></b></p>
      <p>Now that we are a little better than AWT-bumpkins, let us unwrap it all 
        one by one and pick up the pieces from the toolkit cornucopia... <br>
      </p>
      <p><br>
        <b><u>Controls</u></b><br>
        The little yet useful underpinnings for the Graphical look </p>
      <p>Buttons<br>
        We said a while ago that this tutorial was tailor-made for you. How in 
        blazes could a tailor do without buttons ? Try out the following code... 
        <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        public void init()<br>
        { b = new Button(&quot;hell&quot;);<br>
        add(b);<br>
        }<br>
        }</p>
      <p>Here we have a button b added, very much the same as our first AWT program 
        but for one hair-breadth difference. In this way, we have an object b 
        that looks like a Button . Therefore, we can also use the functions of 
        the class Button . With this in mind, let us proceed to the next one... 
      </p>
      <p>setLabel()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        int i=0;<br>
        public void init()<br>
        { b=new Button(&quot;i...&quot; + i);<br>
        add(b);<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        { i++;<br>
        b.setLabel(&quot;i...&quot; + i);<br>
        return true;<br>
        }<br>
        }</p>
      <p>Out here we first add the button b with the name of &quot;i...0&quot;(because 
        i is 0 in the beginning). Then we include the mouseUp() where we change 
        the label or the name of the button with the setLabel() . Meanwhile, we 
        have a variable i which we increment everytime the user clicks with the 
        mouse. The increased value of i is displayed as the name of the button. 
      </p>
      <p>reshape()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        int i = 0;<br>
        public void init()<br>
        { b = new Button(&quot;hell&quot;);<br>
        add(b);<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        { b.reshape(x, y, 30, 40);<br>
        return true;<br>
        }<br>
        }</p>
      <p>This program demonstrates how the button or any other feature in the 
        AWT like the text field, list box etc can be moved to any coordinate and 
        resized. For our button b , we use the reshape() which means we want to 
        change the shape and the position of our button. It is apparent that the 
        reshape() consumes four parameters. The coordinates of the position where 
        we want the button to be, and its width and height. </p>
      <p>getLabel()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        int i = 0;<br>
        public void init()<br>
        { b=new Button(&quot;hello&quot;);<br>
        add(b);<br>
        }<br>
        public boolean mouseUp(Event e,int x, int y)<br>
        { showStatus(b.getLabel());<br>
        return true;<br>
        }<br>
        }</p>
      <p>When we can set a label to a button, it ofcourse is possible to get the 
        label of the button as well. The above program explains how the getLabel() 
        functions. It will become a little clearer with the following program... 
        <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        public void init()<br>
        { b=new Button(&quot;hello&quot;);<br>
        add(b);<br>
        }<br>
        public boolean mouseUp(Event e,int x, int y)<br>
        { if(b.getLabel()==&quot;hello&quot;)<br>
        b.setLabel(&quot;hi&quot;);<br>
        else<br>
        b.setLabel(&quot;hello&quot;);<br>
        return true;<br>
        }<br>
        }</p>
      <p>When the user clicks with the mouse, it is checked if the label of the 
        button is &quot;hello&quot; or &quot;hi&quot;. If it is &quot;hello&quot;, 
        the label is being changed to &quot;hi&quot; and vice versa. If a button 
        is beginning to give you the pips, let's move on to a little higher level. 
        <br>
        Hide and seek<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button a, b, c;<br>
        public void init()<br>
        { a = new Button(&quot;Hide&quot;);<br>
        b = new Button(&quot;Show&quot;);<br>
        c = new Button(&quot;Hello&quot;);<br>
        add(a);<br>
        add(b);<br>
        add(c);<br>
        }<br>
        public boolean action(Event e,Object o)<br>
        { if(&quot;Hide&quot;.equals(o))<br>
        { c.hide();<br>
        }<br>
        if(&quot;Show&quot;.equals(o))<br>
        { c.show();<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>Three is a crowd. That's why we have three buttons here. The buttons 
        a, b and c are assigned the names &quot;Hide&quot;, &quot;Show&quot; and 
        &quot;Hello&quot; respectively. And then, for reasons other than impressing 
        you, we use the action() instead of the variety of mouse functions. The 
        actions function uses the parameters Event and Object . If clicked inside 
        any of the button, the Object o stores the string that is the label of 
        that particular button. Inside the action() function, which keeps a record 
        of all the actions of the user, we have the condition. If the user clicks 
        on the button named &quot;Hide&quot;, o will be &quot;Hide&quot; and in 
        that case we are hiding the button. If, on the other hand , the user has 
        clicked on &quot;Show&quot;, we show back the button. </p>
      <p><br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button a, b, c;<br>
        public void init()<br>
        { a = new Button(&quot;Enable&quot;);<br>
        b = new Button(&quot;Disable&quot;);<br>
        c = new Button(&quot;Hello&quot;);<br>
        add(a);<br>
        add(b);<br>
        add(c);<br>
        }<br>
        public boolean action(Event e,Object o)<br>
        { if(&quot;Enable&quot;.equals(o))<br>
        { c.enable();<br>
        }<br>
        if(&quot;Disable&quot;.equals(o))<br>
        { c.disable();<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>This program works exactly like the previous one. But instead of hide() 
        and the show() , we have the enable() and the disable() . It is hard to 
        find another program more self-explanatory. Most of the functions that 
        work with buttons also work with other members of the AWT, for e.g., a 
        textfield can be hidden/shown or disabled/enabled too. </p>
      <p>TextField<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        TextField t;<br>
        public void init()<br>
        { b = new Button(&quot;click&quot;);<br>
        t = new TextField(60);<br>
        add(b);<br>
        add(t);<br>
        }<br>
        public boolean action (Event e, Object o)<br>
        { if (&quot;click&quot;.equals(o))<br>
        { showStatus(t.getText());<br>
        t.setText(&quot;Hello how are you&quot;);<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>We create a TextField 60 characters long and a button to go along with 
        it. When clicked on the button, first the text already present in the 
        TextField will be shown in the status bar. Then, its text of is set to 
        &quot;Hello how are you&quot;. The programs here can be a little hard 
        for the people not really conversant with programming. It can be further 
        simplified as follows... <br>
        public boolean action (Event e, Object o)<br>
        { String s; boolean b;<br>
        s = &quot;click&quot;;<br>
        b = s.equals(o); <br>
        if (b)<br>
        { showStatus(t.getText());<br>
        t.setText(&quot;Hello how are you&quot;);<br>
        }<br>
        return true;<br>
        }</p>
      <p>appendText() <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        TextArea t;<br>
        public void init()<br>
        { b = new Button(&quot;click&quot;);<br>
        t = new TextArea(5,60);<br>
        add(b);<br>
        add(t);<br>
        }<br>
        public boolean action (Event e, Object o)<br>
        { if (&quot;click&quot;.equals(o))<br>
        { showStatus(t.getText());<br>
        t.appendText(&quot;Hello how are you&quot;);<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>We have a text field that has 5 lines and 60 columns. In the action() 
        we don't say setText, but appendText . This means that the text provided 
        in this way will be added on to the text already present in the text field. 
      </p>
      <p>CheckboxGroup<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { CheckboxGroup g;<br>
        Checkbox a, b, c;<br>
        public void init()<br>
        { g = new CheckboxGroup();<br>
        add(a = new Checkbox(&quot;Good&quot;, g, false));<br>
        add(b = new Checkbox(&quot;Bad&quot;, g, false));<br>
        add(c = new Checkbox(null , g, true));<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        { showStatus(&quot;state of a...&quot; + a.getState() + &quot; <br>
        state of c...&quot; +c.getState());<br>
        return true;<br>
        } <br>
        }</p>
      <p>The CheckboxGroup is, in effect, a collection of checkboxes. But, too 
        weirdly to be argued, the CheckboxGroup looks like our usual radio buttons. 
        Here we create an object g that looks like a CheckboxGroup, and in the 
        init function, we initialize it. We add to it three Checkboxes, named 
        &quot;Good&quot;, &quot;Bad&quot; and null respectively (null is not a 
        name, it means that no name has been given). We also have to tell that 
        the checkbox belongs to which CheckboxGroup, as in our case is g . The 
        third parameter tells which Checkbox will be currently active. In plain 
        English, this means that when we run the program, the third one will be 
        active. After that if we click in, say, the Checkbox a, and then clicked 
        inside the window, the showStatus() will show us that the &quot;state 
        of a...&quot; is true and that of c is false. </p>
      <p>Choice<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        Choice c;<br>
        public void init()<br>
        { c=new Choice();<br>
        c.addItem(&quot;xxx&quot;);<br>
        c.addItem(&quot;yyy&quot;);<br>
        c.addItem(&quot;zzz&quot;);</p>
      <p> l = new List();<br>
        l.addItem(&quot;a1&quot;);<br>
        l.addItem(&quot;a3&quot;);<br>
        l.addItem(&quot;a2&quot;);<br>
        add(l);<br>
        add(c);<br>
        }<br>
        }</p>
      <p>We have a List l and a list box (or a Choice as it is called). To the 
        Choice , we add three items with addItem ... xxx, yyy and zzz . Likewise, 
        to the List we add a1, a3 and a2 . We are not really drunk to have the 
        order as a1, a3, a2 and our basic arithmetic is not all that weak either. 
        It is plainly to demonstrate that the items do not get added in a sorted 
        order. After adding the items to the List and Choice , we add them to 
        the Applet window with the add() . That, and a little tinkering with the 
        functions of the previous examples will have you deft in Lists and choices 
        in minutes. </p>
      <p>delItem()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        Button b;<br>
        public void init()<br>
        { b = new Button(&quot;Remove&quot;);<br>
        l = new List(3, false);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);<br>
        add(b);<br>
        }<br>
        public boolean action (Event e, Object o)<br>
        { if(&quot;Remove&quot;.equals(o))<br>
        { l.delItem(1);<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>First a list of 5 members is created (though only 3 will be visible because 
        we specify so) and added to the applet window. A button called &quot;remove&quot; 
        is created. When the user clicks on this button, we delete the item number 
        1 from the list using delItem() . Note that when we specify 1, the second 
        item gets the scissors because the items start from 0 onwards. Also the 
        'false' that we specify in the statement new List() (or for the C++ folks, 
        in the constructor) means that multiple selection will not be allowed 
        from the list. If we want to allow multiple selection of the items in 
        a list, we have to specify it as true. consider the following code... 
      </p>
      <p>Multiple Selection<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        public void init()<br>
        { l = new List(3,true);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);<br>
        }<br>
        }</p>
      <p>Now you can select more than one options of the list at the same time. 
        <br>
        getSelectedIndex() and getSelectedItem()</p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        int i=0;<br>
        String s;<br>
        public void init()<br>
        { l = new List(3,false);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);<br>
        }<br>
        public boolean handleEvent(Event e)<br>
        { if (e.target instanceof List)<br>
        { i=l.getSelectedIndex();<br>
        s=l.getSelectedItem();<br>
        showStatus(&quot;Name..&quot;+s+&quot;..no..&quot;+i);<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>When an item of the list is selected, the showStatus() will display the 
        number of the item selected and its name on the status line. The getSelectedIndex() 
        returns the number of the item that was selected, and the getSelectedItem 
        returns a string that is the name of the item selected. </p>
      <p>countItems()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        public void init()<br>
        { l = new List(3,false);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        { showStatus(&quot;Number of items..&quot;+l.countItems());<br>
        l.clear();<br>
        return true;<br>
        } }<br>
        When clicked with the mouse, the countItems() will display the number 
        of items in the list box on the status line. The clear() should clear 
        the list but for some old grudge, it does not. (Beta version?) </p>
      <p>Scrollbars <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet <br>
        { Scrollbar s;<br>
        public void init()<br>
        { setLayout(new BorderLayout());<br>
        s = new Scrollbar(Scrollbar.HORIZONTAL,10,5,1,100);<br>
        add(&quot;North&quot;,s);<br>
        }<br>
        public boolean mouseDown(Event e, int x,int y)<br>
        { s.setValue(s.getValue()+5);<br>
        showStatus(&quot;value &quot; + s.getValue()); <br>
        return true;<br>
        }<br>
        }</p>
      <p>The above program gives you a horizontal scrollbar with 1 as the minimum 
        value for the scroll bar and 100 as the maximum value/limit. The parameter 
        10 is the starting point. Everytime we click, we increase the value of 
        the scrollbar by 5. A noteworthy feature is that we'd rather have the 
        borderlayout because the scrollbars are better off in the corners. I still 
        have to see a scrollbar which reposes in the centre of a window. </p>
      <p>Labels<br>
        zzz.java<br>
        import java.awt.*;<br>
        import java.applet.*;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { Label l=new Label(&quot;good&quot;);<br>
        add(l);<br>
        }<br>
        }</p>
      <p>Inside the init(), we initialize a Label and call it &quot;good&quot;. 
        We add it to the current Applet window. When you run the above code, you 
        see a label on the screen. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { public void init()<br>
        { setLayout(new BorderLayout());<br>
        Label l=new Label(&quot;good&quot;);<br>
        add(&quot;North&quot;,l);<br>
        }<br>
        }</p>
      <p>Here we explicitly state the layout we desire, viz., BorderLayout. Then 
        we add the Label to the North. In this way, we can control the positioning 
        of a label. </p>
      <p>Text Area <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { TextArea t;<br>
        public void init()<br>
        { t=new TextArea();<br>
        add(t);<br>
        }<br>
        public boolean mouseMove(Event e, int x, int y)<br>
        { t.setForeground(Color.blue);<br>
        if (t.inside(x,y))<br>
        { showStatus(&quot;in&quot;);<br>
        setBackground(Color.red);<br>
        }<br>
        else<br>
        { showStatus(&quot;out&quot;);<br>
        setBackground(Color.blue);<br>
        }<br>
        repaint();<br>
        return true; }<br>
        }</p>
      <p>With the setForeground() function, the color of the TextArea is set to 
        blue. The inside() , if fed with two parameters, obediently tells us if 
        the mouse is inside the scope of the text area or not. Depending on whether 
        the mouse is within the text region or outside it, we alternate background 
        colors. If inside, then red, if out, blue. Side by side, the showStatus 
        also shows whether the cursor is &quot;in&quot; the text area or not. 
      </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { TextArea t;<br>
        public void init()<br>
        { t=new TextArea();<br>
        add(t);<br>
        }<br>
        public boolean handleEvent(Event e)<br>
        { if(e.target instanceof TextArea)<br>
        { t.setForeground(Color.blue);<br>
        setBackground(Color.red);<br>
        }<br>
        else<br>
        { setBackground(Color.blue);<br>
        }<br>
        repaint();<br>
        return false;<br>
        }<br>
        }</p>
      <p><br>
        With this porgram, we introduce the handleEvent() . If the user types 
        inside the textarea or has the mouse inside the region (this is determined 
        through instanceof ), the foreground color is set to blue and the background 
        color to red. </p>
      <p>getText()<br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { Button b;<br>
        TextArea t,u;<br>
        public void init()<br>
        { b = new Button(&quot;click&quot;);<br>
        t = new TextArea(10,50);<br>
        u = new TextArea(&quot;Hello ...&quot;,5,10);<br>
        add(b);<br>
        add(t);<br>
        add(u);<br>
        }<br>
        public boolean action (Event e, Object o)<br>
        { if (&quot;click&quot;.equals(o))<br>
        { showStatus(t.getText()+&quot;.....&quot;+u.getText());<br>
        }<br>
        return true;<br>
        }<br>
        }</p>
      <p>We have a button and two text areas. The button is named &quot;click&quot;. 
        The text area called t is placed at 10, 50 and the one called u is placed 
        at 5, 10. But notice the difference. u is given a text to be displayed 
        as an initial text (&quot;Hello ...&quot;). Now, when the user clicks 
        on the button, we get the text of u and show it as the status. Therefore, 
        the status will be &quot;Hello ...&quot;. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l;<br>
        TextArea t;<br>
        Button b;<br>
        int i=0;<br>
        public void init()<br>
        { t = new TextArea(3,10);<br>
        l = new List(3,false);<br>
        b= new Button(&quot;click&quot;);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);<br>
        add(t);<br>
        add(b);<br>
        }<br>
        public boolean action(Event e, Object o)<br>
        { if(&quot;click&quot;.equals(o));<br>
        { i = l.countItems();<br>
        for(int j = 0; j &lt; i; j++)<br>
        t.appendText(l.getItem(j));<br>
        }<br>
        return true; <br>
        }<br>
        }</p>
      <p>Quite a simpleton program, this one. We have a list with 5 items and 
        a text area. Now the names of all the items in the list are to be appended 
        to the text area. Even a blonde could crack this one :) But consider the 
        following code and try to figure what it does... <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l, m;<br>
        Button a, b, c;<br>
        TextArea t;<br>
        int i = 0;<br>
        String s;<br>
        public void init()<br>
        { l = new List(3, false);<br>
        m = new List(5, false);<br>
        a = new Button(&quot;Add&quot;);<br>
        b = new Button (&quot;Del&quot;);<br>
        c = new Button(&quot;Go&quot;);<br>
        t = new TextArea(5,30);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);add(a);add(b);add(c);<br>
        add(m);add(t);<br>
        }<br>
        public boolean action(Event e, Object o)<br>
        { if(&quot;Add&quot;.equals(o))<br>
        { s=l.getSelectedItem();<br>
        m.addItem(s);<br>
        }<br>
        if (&quot;Del&quot;.equals(o))<br>
        { if (m.countItems() &gt; 0)<br>
        { i=m.getSelectedIndex();<br>
        m.delItem(i);<br>
        }<br>
        }<br>
        if(&quot;Go&quot;.equals(o))<br>
        { t.setText(&quot; &quot;);<br>
        for(int k = 0; k &lt; m.countItems(); k++)<br>
        t.appendText(m.getItem(k)+&quot;...&quot;);<br>
        }<br>
        return true; <br>
        }<br>
        }</p>
      <p><br>
        Cryptic clues: Add will add to the other list box, delete will delete 
        from the second list, go will show the items in the second list on the 
        text area </p>
      <p>Or try another modified form of this one: </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        { List l,m;<br>
        Button a,b,c;<br>
        TextArea t;<br>
        int i=0;<br>
        String s;<br>
        public void init()<br>
        { l = new List(3,false);<br>
        m = new List(5,false);<br>
        a = new Button(&quot;Add&quot;);<br>
        b = new Button (&quot;Del&quot;);<br>
        c = new Button(&quot;Go&quot;);<br>
        t = new TextArea(5,30);<br>
        l.addItem(&quot;aaa&quot;);<br>
        l.addItem(&quot;bbb&quot;);<br>
        l.addItem(&quot;ccc&quot;);<br>
        l.addItem(&quot;ddd&quot;);<br>
        l.addItem(&quot;eee&quot;);<br>
        add(l);add(a);add(b);add(c);<br>
        add(m);add(t);<br>
        }<br>
        public boolean action(Event e, Object o)<br>
        { if(&quot;Add&quot;.equals(o))<br>
        { i=l.getSelectedIndex();<br>
        s=l.getSelectedItem();<br>
        m.addItem(s);<br>
        l.delItem(i);<br>
        }<br>
        if (&quot;Del&quot;.equals(o))<br>
        { if (m.countItems() &gt; 0)<br>
        { s=m.getSelectedItem();<br>
        i=m.getSelectedIndex();<br>
        m.delItem(i);<br>
        l.addItem(s);<br>
        }<br>
        }<br>
        if(&quot;Go&quot;.equals(o))<br>
        { t.setText(&quot; &quot;);<br>
        for(int k = 0; k &lt; m.countItems();k++)<br>
        t.appendText(m.getItem(k)+&quot;...&quot;);<br>
        }<br>
        return true; <br>
        }</p>
      <p>}</p>
      <p><font size="+1"><b>Threads: The stretchy skeins of possibilities </b></font></p>
      <p>It is a poorly-kept secret how programmers quail at embarking on learning 
        a new concept. When they begin, they look like they were waiting for the 
        dentist's drill and by the time they wind up, they give the impression 
        they just got trampled in a thousand-cow stampede! The concept of threads, 
        though relatively fresh, is by no means one of these gut-wrenching features 
        of Java. We will address threads very soon, but let us first consider 
        the following code.. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        {<br>
        Image m[];<br>
        int i=0;<br>
        int a=0, b=0;<br>
        int j = 1;<br>
        public void init()<br>
        {<br>
        m = new Image[10];<br>
        for (i = 0; i&lt;10; i++)<br>
        {<br>
        m[i] = getImage(getCodeBase(), &quot;T&quot;+j+&quot;.gif&quot;);<br>
        j++;<br>
        }<br>
        i=0;<br>
        }<br>
        public void paint(Graphics g)<br>
        {<br>
        g.drawImage(m[i], a, b, this); <br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        repaint();<br>
        i++;<br>
        if (i == 10)<br>
        i = 0;<br>
        a = x;<br>
        b = y;<br>
        return true;<br>
        }<br>
        }</p>
      <p>From the animator examples in the subdirectory demo, we picked up the 
        ten *.gif files and this is the way you can animate them.The above code 
        is to display an image out of the 10 every time you click. As seen in 
        the earlier programs, an image was displayed wherever you clicked. Here 
        the concept is very much the same, only everytime a new image is displayed. 
        From an array of images, each image is picked up individually. After the 
        10th image is displayed, the counter is set to 0 again. To acquaint you 
        with these pictures well enough, so that you can percieve the roots of 
        animation clearly, we will now display 10 images at different coordinates. 
      </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;</p>
      <p>public class zzz extends Applet<br>
        {<br>
        Image m[];<br>
        int i, j = 1;<br>
        public void init()<br>
        {<br>
        resize(600, 400);<br>
        m = new Image[10];<br>
        for (i = 0; i&lt;10; i++)<br>
        {<br>
        m[i] = getImage(getCodeBase(), &quot;T&quot;+j+&quot;.gif&quot;);<br>
        j++;<br>
        }<br>
        }<br>
        public void paint(Graphics g)<br>
        {<br>
        g.drawImage(m[0], 5, 10, this);<br>
        g.drawImage(m[1], 120, 30, this);<br>
        g.drawImage(m[2], 240, 50, this);<br>
        g.drawImage(m[3], 360, 70, this);<br>
        g.drawImage(m[5], 480, 100, this);</p>
      <p> g.drawImage(m[6], 5, 130, this);<br>
        g.drawImage(m[7], 120, 170, this);<br>
        g.drawImage(m[8], 240, 200, this);<br>
        g.drawImage(m[9], 360, 230, this);<br>
        <br>
        }<br>
        }</p>
      <p>Now we will display the above-seen images at the same coordinates to 
        get the effect of animation. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;</p>
      <p>public class zzz extends Applet<br>
        {<br>
        Image m[];<br>
        int i;<br>
        int j = 1;<br>
        public void init()<br>
        {<br>
        m = new Image[10];<br>
        for (i = 0; i&lt;10; i++)<br>
        {<br>
        m[i] = getImage(getCodeBase(), &quot;T&quot;+j+&quot;.gif&quot;);<br>
        j++;<br>
        }<br>
        i = 0;<br>
        }<br>
        public void paint(Graphics g)<br>
        {<br>
        g.drawImage(m[i], 50, 100, this); <br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        repaint();<br>
        i++;<br>
        if (i == 10)<br>
        i = 0;<br>
        return true;<br>
        }<br>
        }</p>
      <p>The next program demonstrates what necessiates the concept of threads. 
      </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        {<br>
        int i=0;<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        for(int k=0;k&lt;10000;k++)<br>
        {<br>
        i++;<br>
        showStatus(&quot;i...&quot;+i);<br>
        repaint();<br>
        }<br>
        return true;<br>
        }<br>
        public void paint(Graphics g)<br>
        {<br>
        g.drawString(&quot;i...&quot;+i, 50, 100);<br>
        }<br>
        }</p>
      <p>When you run the above program, a click of mouse will take us into the 
        loop of 10000. showStatus() does the work of displaying whatever is passed 
        to it as a parameter.Therefore, the value of i will continuously be incremented 
        and shown as the status. Now, consider the following code... </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet<br>
        {<br>
        int i=0;<br>
        Button b;<br>
        public void init()<br>
        {<br>
        b=new Button(&quot;hell&quot;);<br>
        add(b);<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        for(int k=0;k&lt;1000;k++)<br>
        {<br>
        i++;<br>
        showStatus(&quot;i...&quot;+i);<br>
        repaint();<br>
        }<br>
        return true;<br>
        }<br>
        public boolean action (Event e, Object o)<br>
        {<br>
        if(&quot;hell&quot;.equals(o))<br>
        showStatus(&quot;button clicked&quot;);<br>
        return true;<br>
        }<br>
        public void paint(Graphics g)<br>
        {<br>
        g.drawString(&quot;i...&quot;+i, 50, 100);<br>
        }<br>
        }</p>
      <p>Don't despair, the Button is introduced here, only to show that until 
        the loop of incrementing i does not get accomplished, you are hapless 
        with the Button. As for now, rack your brains and run the program.</p>
      <p>While it is against our religious beliefs to cavil over trivia, it is 
        also essential to know of some Tid-bit functions that come along with 
        threads. They might come in handy when threads try to play hob with you. 
        Let us check out the first one, which, infact, is the solution to an array 
        of problems. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet implements Runnable<br>
        {<br>
        public void run()<br>
        {<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        Thread t;<br>
        t = new Thread(this);<br>
        showStatus(t.toString());<br>
        return true;<br>
        }<br>
        }</p>
      <p>The toString() does the work of converting the relevant details into 
        a string form. Here we use toString() with t, so the 'relevant details' 
        are the details of the thread t. When this converted string is specified 
        as a parameter to the showStatus, the value is displayed on the show status. 
        <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet implements Runnable<br>
        {<br>
        public void run()<br>
        {<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        Thread t;<br>
        t = new Thread(this);<br>
        t.start();<br>
        list();<br>
        return true;<br>
        }<br>
        }</p>
      <p>The list(), (which is the only new thing introduced here - in case you 
        are wondering about the necessity of the above program), tells you what 
        are the components of the current window and what are the threads currently 
        executed. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet implements Runnable<br>
        {<br>
        public void run()<br>
        {<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        Thread t;<br>
        t = new Thread(this);<br>
        showStatus(t.getThreadGroup().toString());<br>
        t.getThreadGroup().list();<br>
        return true;<br>
        }<br>
        }</p>
      <p>The ThreadGroup() will list the different threads executed at the moment 
        when clicked with the mouse. But the hitch is that this output is available 
        only in the DOS shell,i.e., if you switch to the DOS shell from the Windows 
        environment. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        class ttt extends Thread<br>
        {<br>
        zzz a;int i=0;<br>
        ttt( zzz z)<br>
        {<br>
        super(&quot;good&quot;);<br>
        a = z;<br>
        }<br>
        public void run()<br>
        { <br>
        while ( true)<br>
        {<br>
        i++;<br>
        a.repaint();<br>
        a.showStatus(getName());<br>
        }<br>
        }<br>
        }<br>
        class uuu extends Thread<br>
        {<br>
        zzz a;int j=0;<br>
        uuu(zzz z)<br>
        {<br>
        a = z;<br>
        }<br>
        public void run()<br>
        {<br>
        while ( true)<br>
        {<br>
        a.showStatus(getName());<br>
        j++;<br>
        a.repaint();<br>
        }<br>
        }<br>
        }<br>
        public class zzz extends Applet<br>
        {<br>
        uuu u;<br>
        ttt t;<br>
        public void init()<br>
        {<br>
        u = new uuu (this);<br>
        t = new ttt (this);<br>
        t.start();<br>
        u.start();<br>
        }<br>
        public boolean mouseDown(Event e, int x,int y)<br>
        {<br>
        u.setName(&quot;bad&quot;);<br>
        return true;<br>
        }<br>
        }</p>
      <p>The super() will give a name to the thread (whatever provided as the 
        parameter will be the name given to the thread). In the ttt class, we 
        name it as &quot;good&quot;. In the mouseDown(), we set the name of the 
        thread u to &quot;bad&quot;. So, now the run(), which is supposed to show 
        the name of the thread will alternate between &quot;good&quot; and &quot;bad&quot;. 
      </p>
      <p>zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        public class zzz extends Applet implements Runnable<br>
        {<br>
        public void run()<br>
        {<br>
        }<br>
        public boolean mouseUp(Event e, int x, int y)<br>
        {<br>
        Thread t;<br>
        t = new Thread(this, &quot;good&quot;);<br>
        showStatus(t.getName());<br>
        return true;<br>
        }<br>
        }</p>
      <p>The yield() </p>
      <p>As must be evident, while creating the new thread t, we are also giving 
        it the name of &quot;good&quot;. This is another way of giving your thread 
        a name. Now when we show the status of the thread, the getName() will 
        display &quot;good&quot;. <br>
        zzz.java<br>
        import java.applet.*;<br>
        import java.awt.*;<br>
        class ttt extends Thread<br>
        { zzz a;<br>
        int i=0;<br>
        ttt( zzz z)<br>
        { a = z;<br>
        }<br>
        public void run()<br>
        { while ( true)<br>
        { yield();<br>
        i++;<br>
        a.repaint();<br>
        a.showStatus(getName());<br>
        }<br>
        }<br>
        }</p>
      <p>class uuu extends Thread<br>
        { zzz a;int j=0;<br>
        uuu( zzz z)<br>
        { a = z;<br>
        }<br>
        public void run()<br>
        { while ( true)<br>
        { j++;<br>
        a.repaint();<br>
        a.showStatus(getName());<br>
        }<br>
        }<br>
        }<br>
        public class zzz extends Applet<br>
        { uuu u;<br>
        ttt t;<br>
        public void start()<br>
        { u = new uuu (this);<br>
        t = new ttt (this);<br>
        t.start();<br>
        u.start();<br>
        }<br>
        public void paint(Graphics g)<br>
        { g.drawString(&quot;i ..&quot; + t.i,1,20);<br>
        g.drawString(&quot;j ..&quot; + u.j,1,60);<br>
        }<br>
        }</p>
      <p><font size="+1"><b><br>
        BREWING JAVA - THE FIRST SIP </b></font></p>
      <p><b>Brrr....Its Hot : - </b></p>
      <p>We briefed you on what the Java ballyhoo is all about. Bet you are throbbing 
        for the innards of Java programming by now. We will get down to that right 
        off the bat. </p>
      <p>Before we hop on to savor the wondercoffee, however, let up get clear 
        on one thing. The Java mug actually has two shades to it. For one. You 
        can write applets , which will wriggle down the cast skeins of Internet 
        cables on to a user's terminal, with the browser picking up the cudgels 
        to execute them. As the other shade, you can write Java standalone programs, 
        which will compile and execute on the user's local machine. As promised, 
        in this series, we will master the techniques of creating such stand-alone 
        Java programs and calling them your own (though we really like calling 
        internet-independent programs). </p>
      <p>Owing to security reasons, there is an array of functionalities which 
        the applets are denied by the rather rigid duo of Java and the Java-enabled 
        browser. On the other hand, the stand-alone programs are, fortunately, 
        spared from the security rigmarole. That gives us one good reason to pursue 
        such programs. </p>
      <p>Unfortunately for the people who want to run without bothering to learn 
        to walf first, we will stick to our rituals, that is, a step-by-step approach 
        to programming. As regards our naming conventions, we do not intend to 
        inculcate style-specific practices. Quite the contrary, we intend development 
        of initiative and understanding. Hence, the names of our classes, functions 
        and variables will not exceed three letters. In case you overlooked, the 
        presence of classes etc. Also presupposes the fact that the reader is 
        versed to a reasonable extent with C/C++ </p>
      <p>With that widget of wisdom up our sleeve, let's take the first sip. Make 
        sure you are in the DOS mode and running a text editor of your choice. 
        (According to our reliable astrologer, Edit serves the purpose well enough). 
        <br>
        zzz.java <br>
        class aaa<br>
        {<br>
        }</p>
      <p>Well, that's admittedly a simple program. We define a class by the name 
        of aaa. Mark that the name of our java file is zzz.java, which implies 
        that the names of the class and the .java file do not matter so much now, 
        though they will soon begin to. Hopefully, you know that the program has 
        to be compiled before it can be executed. The Java compiler is called 
        javac. So now we key in the following command at the DOS prompt. </p>
      <p>javac zzz.java</p>
      <p>The compilation process turns out to be comfortably peaceful and a file 
        called aaa.class is created by javac. Which indicates that Java makes 
        .class files instead of the usual .obj (the cheeky chappies at Sun were 
        always creative with their names anyway). It is now a fair idea to try 
        and execute the program. For this, we have to type : </p>
      <p>java aaa</p>
      <p>Bet you have realized that this command would actually read : java aaa. 
        Class since we are trying to execute the .class file. But a period (.) 
        is supposed to be a part of file path in Java, so we'd rather you skip 
        the .class part out. The program, though successfully compiled, refuses 
        to run without hassles. It flings the error message : In class aaa: vodi 
        main(String argv[]) is undefined. If anything, that error message smacks 
        nostalgically of C - main() and all. So we very willingly add the main() 
        to our code. Consider the following code... </p>
      <p>zzz.java <br>
        class aaa<br>
        {<br>
        void main( String s[] ) { }<br>
        }</p>
      <p>Our main() has one argument - an array called s. This array will contain 
        strings, hence the String. It is similar to your argv in C, the only variation 
        being, the number of parameters are not specified. A point to be noted 
        here is that arrays in Java and C differ slightly. C gave no errors even 
        if you tried to refer to an element outside the actual size of the array. 
        That is, assuming we have an array a[10]. The size of the array is 10. 
        While using C, we could cheerfully say a[11] in the program without any 
        errors, though the output would be some out-of-this-world junk. Java, 
        however, has built-in error checks that keep a track of the number of 
        members and prevent us from going beyond the specified limit. </p>
      <p>When we javac the above code, it compiles quite conveniently. However, 
        it refuses to run. This time the error shown is : In class aaa: main must 
        be public and static. By default, the main() is private and hence, the 
        others cannot avail of it. The simple reason why it must be public is 
        that it should be visible to others (e.g., other classes, other programs 
        and very importantly, our own Java Run time system). In plain English, 
        when we say java aaa, the Java runtime system contacts the class aaa, 
        looks for a function called main() init. But since the function has not 
        been declared as public, the system cannot look into it. </p>
      <p>As regards static, a C++ programmer should be very well-versed with it. 
        Ordinarily, to access a function inside a class, we have to define an 
        object that looks like that class and access the function through the 
        object. But by defining main() as static, we can access it directly, without 
        needing to create an object that looks like class aaa. So we modify the 
        code as follows... </p>
      <p>zzz.java <br>
        class aaa<br>
        {<br>
        public static void main( String s[] ) { }<br>
        }</p>
      <p>After all those changes, the program finally works. But sadly, there 
        is no attractive output because we have admittedly done nothing in the 
        main(). Let us go right ahead and add some code. Retain the name of the 
        java file. </p>
      <p>zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        System.out.println(&quot;in main&quot;);<br>
        }<br>
        }</p>
      <p>Everytime we use java, we have a free reign to use the objects that are 
        pre-created, so we are spared the burden of creating our own objects. 
        One very helpful of these objects is System (and note the case because 
        Java is pretty unforgiving with case-errors), which in turn has various 
        other objects in it. In our case, the object is called out. From out, 
        w use a function or a method called println, which can safely be likened 
        to printf in C. Just like printf, whatever we snuff inside the double 
        quotes will be snuffed out on the screen. So when we run this program, 
        ofcourse after compiling, it will display the string &quot;in main&quot;. 
      </p>
      <p>A program in any self-respecting language is virtually useless unless 
        it makes use of variables. Since Java is surely one of them, let us add 
        a variable to the code... <br>
        zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        int i = 0;<br>
        System.out.println( &quot;in main.i..&quot;+i );<br>
        }<br>
        }</p>
      <p>We choose to call our variable i. It is of the type int, and it is inside 
        main(). It is initialized to 0. That very eloquently shows that Java looks 
        and feels like C/C++. However, the println scores over the strict, old 
        printf. Note that we are displaying a string - - &quot;in main.i..&quot; 
        and the variable i.Unlike C, Java figures out how to display two different 
        data types at the same time, chucking out the fuss involved in the cumbersome 
        conversions. <br>
        The output of the above program will be... </p>
      <p> in main i..0<br>
        The object String has a member called length. Since s (in the definition 
        of the main()), looks like a String, we can access length through s. That's 
        what our next program speaks about. <br>
        zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        int i;<br>
        i = s.length;<br>
        System.out.println(&quot;in main.i..&quot;+i);<br>
        }<br>
        }</p>
      <p>When you run the above program, with the command line being java aaa, 
        you will see the output: </p>
      <p> in main.i...0</p>
      <p>This is because the command line has to have some arguments besides the 
        java aaa. For instance, if you type out java aaa a b c, the output will 
        be </p>
      <p> in main.i...3</p>
      <p>Which is to say that the object String works very much like argv[] of 
        C, while the length can be likened to argc. The array s stores the command 
        line arguments (that is, whatever you type besides java aaa) and length 
        counts the number of extra arguments typed in. Now if we want to display 
        the actual elements, we can do that by saying s [0, s [1] and so on. In 
        our case, for example, when we say s[0] it will print the a, s[1] will 
        print b and s[2], c). Let us see for ourselves how... </p>
      <p>zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        int i;<br>
        i = s.length;<br>
        System.out.println(&quot;in main.i..&quot;+i);<br>
        System.out.println(&quot;in main s[0] ...&quot; + s[0]);<br>
        }<br>
        }</p>
      <p>If you run the above program without any extra parameters, it will display 
        the error.. </p>
      <p>java.lang.ArrayIndexOutOfBoundsException </p>
      <p>To check for that, we can modify the program a little... </p>
      <p>zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        int i;<br>
        i = s.length;<br>
        System.out.println(&quot;in main.i..&quot;+i);<br>
        if (i &gt; 0)<br>
        System.out.println(&quot;in main s[0] ...&quot; + s[0]);<br>
        else<br>
        System.out.println(&quot;no parameters&quot;);<br>
        }<br>
        }</p>
      <p>In the above program, we check whether the user has entered anything 
        other than java aaa with the if condition. That is because i stores the 
        number of these extra arguments. If the user has entered nothing, we display 
        &quot;no parameters&quot;, otherwise we display the first additional argument. 
        All the arguments can be displayed inthe following way... </p>
      <p></p>
      <p>zzz.java<br>
        class aaa<br>
        {<br>
        public static void main( String s[] )<br>
        {<br>
        int i;<br>
        i = s.length;<br>
        System.out.println(&quot;in main.i..&quot;+i);<br>
        if (i &gt; 0)<br>
        for (int j = 0; j &lt; i; j++ )<br>
        System.out.println(&quot;in main ..&quot;+ j +&quot;...&quot; + s[j]);<br>
        else<br>
        System.out.println(&quot;no parameters&quot;);<br>
        }<br>
        }</p>
      <p>The above code checks for the presence of extra arguments, and if present, 
        it displays all of them. </p>
      <p>Consider this code for another minor revelation... <br>
        zzz.java<br>
        class aaa<br>
        {<br>
        int i = 0;<br>
        public static void main( String s[] )<br>
        {<br>
        System.out.println( &quot;i..&quot; + i );<br>
        }<br>
        }</p>
      <p>Here the compilation will give an error saying : can't make static reference 
        to a nonstatic variable i in class aaa. That is because main() is a static 
        function and static functions cannot refer to any variables outside their 
        own body. Whereas, in the above program, our variable i is a global variable, 
        i.e., it is defined outside any function. So it cannot be referred by 
        the <br>
        main() . The only way to access in a case as this is by making i static. 
        This can be done by rewriting the first line in the function as static 
        int i = 0;</p>
      <p><br>
        <b><font size="+1">Before we bid adieu</font></b></p>
      <p>We believe we have made our technique sufficiently clear by now. Ofcourse, 
        with the kind of programs illustrated here, we can not look forward to 
        a prize in the field of computer sciences. But yes, we make no compromises 
        with our fundamentals. As regards the concepts of Java, there are quite 
        a few potatoes in the sack. We promise to bring you all of them in elaborate 
        detail and with a similar simple, step-by-step approach to programming. 
        Whatever the implications of how Java is being accepted as a popular language 
        or how it is starting a whole new revolution, one fact remains undeterred. 
        It definitely is the harbinger of a dynamic future. Sun Microsystems, 
        by introducing the unprecedented concept, has planted a stake in the sand. 
        What we make out of it is in our hands.</p>
      <p><font size="+1"><b>With a little help from my friends</b></font></p>
      <p>There are so many of us out there goofing up our programs trying hard 
        to figure out the myriad concepts of Java and so few who actually seem 
        to be getting anywhere. The least we can do is be together in cyberspace 
        and share our experiences and knowledge. All your comments, queries, headaches, 
        suggestions and experiences, both of the moments of bright flashes of 
        understanding and the baffling times are welcome. You can reach us at 
        : <a href="mailto:vmukhi@vsnl.com">vmukhi@vsnl.com</a>. We might serve 
        as Java Aspirins for your digital headaches :) . </p>
      <p></p>
      <p></p>
      <p></p>
      <hr>
    </td>
  </tr>
</table>
  <table border="0" cellspacing="3" cellpadding="0" align="center">
    <tr>
      <td>
        <div align="center"><font size="-1"><font size="-2" face="Verdana, Arial, Helvetica, sans-serif"><a href="contents.html">Contents</a> 
          | <a href="foreword.html">Foreword</a> | <a href="about.html">About 
          the Authors</a> | <a href="intro.html">Introduction</a> |</font></font><font size="-2" face="Verdana, Arial, Helvetica, sans-serif"><br>
        <a href="chap0-2.html">Appendix</a> |<a href="chap1.html">Chapter 1</a> |<a href="chap2.html">Chapter 
        2</a> |<a href="chap3.html">Chapter 3</a> |<a href="chap4.html">Chapter 
        4</a> |<a href="chap5.html">Chapter 5</a> |<a href="chap6.html">Chapter 
        6</a> |<br>
        <a href="chap7.html">Chapter 7</a> |<a href="chap8.html">Chapter 8</a> 
        |<a href="chap9.html">Chapter 9</a> |<a href="chap10.html">Chapter 10</a> 
        |<a href="chap11.html">Chapter 11</a></font></div>
      </td>
    </tr>
  </table>
</body>

<!-- Mirrored from www.vijaymukhi.com/documents/books/javajsp/chap0.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:41:56 GMT -->
</html>
