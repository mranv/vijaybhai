<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/xsd/chap7.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:06:09 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap7_files/filelist.html">
<link rel=Edit-Time-Data href="chap7_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>XML Schema Definition - 7. Program Generated Schemas</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>vmukhi</o:Author>
  <o:LastAuthor>vmukhi</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>30</o:TotalTime>
  <o:Created>2002-01-20T08:41:00Z</o:Created>
  <o:LastSaved>2002-01-20T08:42:00Z</o:LastSaved>
  <o:Pages>28</o:Pages>
  <o:Words>8338</o:Words>
  <o:Characters>47528</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>396</o:Lines>
  <o:Paragraphs>95</o:Paragraphs>
  <o:CharactersWithSpaces>58367</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Book Antiqua";
	panose-1:2 4 6 2 5 3 5 3 3 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	letter-spacing:10.0pt;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:24.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.5pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.figure, li.figure, div.figure
	{mso-style-name:figure;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.figure1, li.figure1, div.figure1
	{mso-style-name:figure1;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ChapName, li.ChapName, div.ChapName
	{mso-style-name:"Chap Name";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ChapName1, li.ChapName1, div.ChapName1
	{mso-style-name:"Chap Name1";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Book Antiqua";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.basetextofthebook1, li.basetextofthebook1, div.basetextofthebook1
	{mso-style-name:"base text of the book1";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ChapName0, li.ChapName0, div.ChapName0
	{mso-style-name:ChapName;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.SubTitle, li.SubTitle, div.SubTitle
	{mso-style-name:SubTitle;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ChapIntro, li.ChapIntro, div.ChapIntro
	{mso-style-name:"Chap Intro";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:42.65pt;
	margin-bottom:0in;
	margin-left:1.25in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;}
p.PageNo, li.PageNo, div.PageNo
	{mso-style-name:"Page No";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Subhead2, li.Subhead2, div.Subhead2
	{mso-style-name:"Subhead 2";
	mso-style-parent:"Subhead 1";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.Subhead1, li.Subhead1, div.Subhead1
	{mso-style-name:"Subhead 1";
	mso-style-parent:Headline;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:18.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.Headline, li.Headline, div.Headline
	{mso-style-name:Headline;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.Hangingindent, li.Hangingindent, div.Hangingindent
	{mso-style-name:"Hanging indent";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	mso-pagination:widow-orphan;
	tab-stops:12.0pt;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Bodytext, li.Bodytext, div.Bodytext
	{mso-style-name:"Body text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-indent:24.0pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:12.0pt;
	mso-ansi-font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><img width=103
height=77 id="_x0000_i1027" src=bpb.gif><o:p></o:p></span></p>

<p class=ILbase><span style='font-size:24.0pt'>7.<o:p></o:p></span></p>

<p class=ILbase><span style='font-size:24.0pt'>Program Generated Schemas </span><span
style='font-family:"Bookman Old Style"'><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In all the
earlier chapters, the XML Schemas had been written manually. This is because we
wanted to experiment with our own permutations and combinations. Now, we shall
use a program,a.cs to create them. The focal point of this chapter is the
creation of the XML Schema files using a program. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; /&gt;<span
style='font-family:"Bookman Old Style";mso-bidi-font-family:"Times New Roman"'><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The program
starts out by creating an object 'a', which is an instance of class XmlSchema.
This class represents the schema element that kick starts all the schema files.
All the XML Schema Definition (XSD) language elements are children of the
schema element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The Write
function writes out the entire schema that is associated with the XmlSchema
object. The Write function has three overloads that accept either a stream, or
a TextWriter, or an XmlTextWriter, as parameters. Out of the varied choice of
outputs available, we employ the standard output, where the output device is
the screen.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The output is an
xsd file where the mandatory XML directive &lt;?xml gets written first, even
though there is no trace of it in the program. There is no way of forestalling
the directive from being written. However, since it is mandatory, it has to be
present. The encoding and version attributes have already been elucidated in the
earlier chapters. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The schema
element gets written next with the default namespace of xs and the XmlSchema
class using the URI of http://www.w3.org/2001/XMLSchema. This URI represents
the rules of the schema world. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>An XML Schema
encompasses various elements. Thus, the next logical step is to add an element
to the xsd file. In order to achieve this, a class XmlSchemaElement is used, which
represents an element called 'element'. This is similar to the XmlSchema class
that represents an element called 'schema'. Subsequent to its creation, a new
instance of the class is required to be added to the schema element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>As mentioned
earlier, every element has to be a part of a child of the root schema element.
The Items property of the XmlSchema class is of type XmlSchemaObjectCollection,
which is a collection class. Thus, the Add function contained in this class is
utilized to store all the entities associated with the schema element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>If we attempt to
display the contents of the schema, an empty element tag shall be flashed,
which symbolizes an error. So, why did the framework choose to ignore this
error?<span style="mso-spacerun: yes">                                    
</span><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>This can be
attributed to the fact that the schema has not been compiled. It is only after
the schema gets compiled that such errors will get reported. Since the
XmlSchema class was solicited to insert an element, it obliged without carrying
out any scrutiny for errors.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e ;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>The required attribute 'name' is missing.<o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>A delegate object
ValidationEventHandler is created and is passed the name of the function abc,
which shall get called on every occasion that an error occurs. This function
merely displays the value in the Message property. The Compile function, as is
evident from its name, compiles the XML Schema Definition language XSD Schema
Object Model (SOM) into schema information. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>To begin with, it
checks the syntax and semantic content of the schema file or SOM. Note that
this error check is performed prior to the compilation. Since no name has been
assigned to the element, the function abc reports an error.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e ;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>e.SchemaTypeName = new XmlQualifiedName(&quot;string&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>To rectify the
above error, merely an element name is required. So, using the Name property,
the element is assigned the name 'vijay'. No type is specified for an element;
therefore, the default type of ur-type comes into play. If the type has to be
specified, then the XmlSchemaTypeName member has to be used. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The
XmlQualifiedName class takes two parameters, viz. a string and the name of the
namespace that the type originates from. The default namespace is the
fountainhead of the string type, and therefore, there exists no namespace
prefix for the type string.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>e.SchemaTypeName = new XmlQualifiedName
(&quot;xs:string&quot;,&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Invalid 'type' attribute - The ':' character, hexadecimal
value 0x3A, cannot be included in a name..<o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;
type=&quot;xs:xsd_x003A_string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The first
parameter to the constructor of class XmlQualifiedName is the local name, while
the second parameter is the namespace. Both of these must be specified
separately.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the
constructor only the type must be specified. There is no rationale behind
furnishing the namespace, followed by a colon, and then by a type. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>e.SchemaTypeName = new XmlQualifiedName(&quot;c1&quot;,
&quot;b1.xsd&quot;);<o:p></o:p></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Type 'b1.xsd:c1' is not declared.<o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;
xmlns:q1=&quot;b1.xsd&quot; type=&quot;q1:c1&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The above error
message imparts substantial amount of information. The type c1 stems from the
namespace b1.xsd. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the xsd file,
the type is prefaced with q1 and the schema element, the namespace prefix q1
points to the URI b1.xsd. The Compile function comprehends and interprets the
namespaces.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e ;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>e.SchemaTypeName = new XmlQualifiedName(&quot;string&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e1 = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>sc.Add(e1);<o:p></o:p></p>

<p class=ILprg>e1.Name = &quot;sonal&quot;;<o:p></o:p></p>

<p class=ILprg>e1.SubstitutionGroup = new XmlQualifiedName(&quot;vijay&quot;);<o:p></o:p></p>

<p class=ILprg>e1.SchemaTypeName = new XmlQualifiedName(&quot;string&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;sonal&quot;
substitutionGroup=&quot;vijay&quot; type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The xsd file now
has two elements: the first one is 'vijay' and the second one is 'sonal'. For
the second element, the name property in the XmlSchemaElement is set to sonal
and the substitutionGroup property is set to vijay using the XmlQualifiedName
object. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>It is for these
very reasons that the xsd file displays the element sonal with the substitution
group as vijay, and the type as string. Thus, the above program demonstrates
how a property can be assigned for each and every attribute of the element.<o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e ;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>XmlSchemaComplexType t = new XmlSchemaComplexType();<o:p></o:p></p>

<p class=ILprg>e.SchemaType = t;<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output:</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:complexType /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:element&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the above
instance, the name of the new XmlElement is set to vijay. It obviously has no
type, but the SchemaType property is set to an object t, which is an instance
of an XmlSchemaComplexType. Therefore, in the output, we notice that the
element is followed by an empty complexType element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The Block
property of the XmlSchemaElement can contain only the following values: Enum,
Empty, None, Extension, Restriction, Union and List. All these values
facilitate either restriction or extension. Likewise, the Constraints property
can have the following three values: XmlSchemaKey, XmlSchemaKeyref and
XmlSchemaUnique. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e ;<o:p></o:p></p>

<p class=ILprg>e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaObjectCollection sc;<o:p></o:p></p>

<p class=ILprg>sc = s.Items;<o:p></o:p></p>

<p class=ILprg>sc.Add(e);<o:p></o:p></p>

<p class=ILprg>XmlSchemaComplexType t = new XmlSchemaComplexType();<o:p></o:p></p>

<p class=ILprg>e.SchemaType = t;<o:p></o:p></p>

<p class=ILprg>XmlSchemaChoice c = new XmlSchemaChoice();<o:p></o:p></p>

<p class=ILprg>t.Particle = c;<o:p></o:p></p>

<p class=ILprg>c.MinOccurs = 0;<o:p></o:p></p>

<p class=ILprg>c.MaxOccursString = &quot;unbounded&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e1 = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>c.Items.Add(e1);<o:p></o:p></p>

<p class=ILprg>e1.Name = &quot;sonal&quot;;<o:p></o:p></p>

<p class=ILprg>e1.SchemaTypeName = new XmlQualifiedName(&quot;string&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) {<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:complexType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:choice minOccurs=&quot;0&quot;
maxOccurs=&quot;unbounded&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;sonal&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:choice&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:element&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Here onwards, the
program assumes slightly more complex hues. Let us inspect the final xsd file.
The element named vijay is followed by a complexType, which in turn is followed
by a choice element, whose minOccurs and maxOccurs attributes have been set to
0 and 'unbounded', respectively. The element sonal, whose type is a string,
lies within the choice.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In order to build
the above xsd file, the Name property of XmlSchemaElement 'e' is set to vijay,
and is then added to the Items collection. Thereafter, to ensure that a
complexType element follows it, the SchemaType is set to an
XmlSchemaComplexType object. This has already been witnessed in the previous
example. Subsequently, an object 'c' of type XmlSchemaChoice is created, and
the property Particle of the complexType class is initialized to this newly
created object. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, here we
have a choice element as a child of the complexType. To jog your memory, this
property can have only four types of elements following it, viz. group,
sequence, all and a choice. The Particle property has a data type of
XmlSchemaParticle. The XmlSchemaChoice and the other three classes derive from
XmlSchemaParticle. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Simultaneously,
the MinOccurs and the MaxOccurs properties of the choice element are set to 0
and unbounded, respectively. The maxOccurs also has a maxOccursString property
that permits its usage as the single value of 'unbounded'. As mentioned
earlier, the maxOccurs value is a union of numbers and a string. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Then, the second
XmlSchemaElement e1 is created and its name is set to 'sonal'. Thereafter, it
is added to the Items collection of the choice and not to the element called
'vijay'. Hence, this element now falls under the choice element. The xsd file
is the xsd representation of these statements. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>…<o:p></o:p></p>

<p class=ILprg>c.MaxOccursString = &quot;unbounded&quot;;<o:p></o:p></p>

<p class=ILprg>c.MaxOccurs = 10;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput>Output<o:p></o:p></p>

<p class=ILoutput>…<o:p></o:p></p>

<p class=ILoutput>&lt;xs:choice minOccurs=&quot;0&quot;
maxOccurs=&quot;10&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>…<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>One more line of
code is initiated in the above program, wherein the property MaxOccurs is
initialized to 10. The Compile function uses the last MaxOccurs type of
property, and hence, ‘maxOccurs=&quot;10&quot; ‘ gets written to the xsd file. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>a.cs</u><o:p></o:p></p>

<p class=ILoutput>using System;<o:p></o:p></p>

<p class=ILoutput>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILoutput>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILoutput>class zzz<o:p></o:p></p>

<p class=ILoutput>{<o:p></o:p></p>

<p class=ILoutput>public static void Main() <o:p></o:p></p>

<p class=ILoutput>{<o:p></o:p></p>

<p class=ILoutput>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILoutput>XmlSchemaSimpleType t = new XmlSchemaSimpleType();<o:p></o:p></p>

<p class=ILoutput>t.Name = &quot;c1&quot;;<o:p></o:p></p>

<p class=ILoutput>XmlSchemaSimpleTypeRestriction r = new
XmlSchemaSimpleTypeRestriction();<o:p></o:p></p>

<p class=ILoutput>r.BaseTypeName = new XmlQualifiedName(&quot;string&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILoutput>XmlSchemaEnumerationFacet e1 = new
XmlSchemaEnumerationFacet();<o:p></o:p></p>

<p class=ILoutput>e1.Value = &quot;sonal&quot;;<o:p></o:p></p>

<p class=ILoutput>r.Facets.Add(e1);<o:p></o:p></p>

<p class=ILoutput>XmlSchemaEnumerationFacet e2 = new
XmlSchemaEnumerationFacet();<o:p></o:p></p>

<p class=ILoutput>e2.Value = &quot;Neha&quot;;<o:p></o:p></p>

<p class=ILoutput>r.Facets.Add(e2);<o:p></o:p></p>

<p class=ILoutput>t.Content = r;<o:p></o:p></p>

<p class=ILoutput>s.Items.Add(t);<o:p></o:p></p>

<p class=ILoutput>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILoutput>s.Compile(v);<o:p></o:p></p>

<p class=ILoutput>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILoutput>}<o:p></o:p></p>

<p class=ILoutput>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILoutput>{<o:p></o:p></p>

<p class=ILoutput>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILoutput>}<o:p></o:p></p>

<p class=ILoutput>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:simpleType name=&quot;c1&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:restriction base=&quot;xs:string&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:enumeration value=&quot;sonal&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:enumeration value=&quot;Neha&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:restriction&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:simpleType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The program
brings about the creation of an xsd file with a simple type named c1, followed
by a restriction element whose base type is string. The above string is
restricted to the two values of 'sonal' and 'neha'. This is achieved with the
help of the enumeration element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The basilisk gaze
now shifts to the C# program. Every element in the schema world has a
corresponding class that can comprehend it. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, the class
XmlSchemaSimpleType can understand and handle the simpleType element. The name
property is set to c1. Thereafter, an XmlSchemaSimpleType object is created,
since the restriction element has to be a child of the simpleType. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In our particular
case, the restriction element that is represented by the class XmlSchemaSimpleTypeRestriction,
is employed to restrict a string. The property BaseTypeName is set to an
XmlQualifiedName object. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Then, an object
e1 is created as an instance of the class XmlSchemaEnumerationFacet, which
represents the enumerator element. This enumerator element requires a value.
Therefore, the value property is set to sonal. The
XmlSchemaSimpleTypeRestriction class has a property called Facets, which is of
type XmlSchemaObjectCollection. It has the Add function, which keeps track of
the multiple facets that the restriction can handle. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Within the
restriction, the following eleven facets types are allowed:
XmlSchemaLengthFacet, XmlSchemaMinLengthFacet, XmlSchemaMaxLengthFacet,
XmlSchemaPatternFacet, XmlSchemaEnumerationFacet, XmlSchemaMaxInclusiveFacet, XmlSchemaMaxExclusiveFacet,
XmlSchemaMinInclusiveFacet, XmlSchemaMinExclusiveFacet,
XmlSchemaFractionDigitsFacet and XmlSchemaTotalDigitsFacet.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>After the
addition of the multiple facets, the next task is to associate the Content of
the simple type with the restriction. The Content property of type
XmlSchemaSimpleTypeContent is initialized to the restriction object. The other
two possible values are list and union. Finally, using the Add function, the
simpleType element is added to the Items collection of the XmlSchema.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaAttribute a = new XmlSchemaAttribute();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(a);<o:p></o:p></p>

<p class=ILprg>a.Name = &quot;a1&quot;;<o:p></o:p></p>

<p class=ILprg>a.SchemaTypeName = new XmlQualifiedName(&quot;integer&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:attribute name=&quot;a1&quot;
type=&quot;xs:integer&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The above example
basically creates an attribute using the class XmlSchemaAttribute. The
attribute is also added to the Items collection in a manner akin to the other
elements. The attribute is assigned the name a1 of type integer.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaGroup g = new XmlSchemaGroup();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(g);<o:p></o:p></p>

<p class=ILprg>g.Name = &quot;g1&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaSequence se= new XmlSchemaSequence();<o:p></o:p></p>

<p class=ILprg>g.Particle = se;<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>se.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;aaa&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaComplexType t = new XmlSchemaComplexType();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(t);<o:p></o:p></p>

<p class=ILprg>t.Name = &quot;c1&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaGroupRef g1= new XmlSchemaGroupRef();<o:p></o:p></p>

<p class=ILprg>t.Particle = g1;<o:p></o:p></p>

<p class=ILprg>g1.RefName = new XmlQualifiedName(&quot;g1&quot;);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:group name=&quot;g1&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;aaa&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:group&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:complexType name=&quot;c1&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:group ref=&quot;g1&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaAnnotation a = new XmlSchemaAnnotation();<o:p></o:p></p>

<p class=ILprg>e.Annotation = a;<o:p></o:p></p>

<p class=ILprg>XmlSchemaDocumentation d= new XmlSchemaDocumentation();<o:p></o:p></p>

<p class=ILprg>a.Items.Add(d);<o:p></o:p></p>

<p class=ILprg>XmlDocument dc = new XmlDocument();<o:p></o:p></p>

<p class=ILprg>XmlNode n;<o:p></o:p></p>

<p class=ILprg>n = dc.CreateTextNode(&quot;sonals husband&quot;);<o:p></o:p></p>

<p class=ILprg>XmlNode [] na = new XmlNode[1];<o:p></o:p></p>

<p class=ILprg>na[0] = n;<o:p></o:p></p>

<p class=ILprg>d.Markup = na;<o:p></o:p></p>

<p class=ILprg>XmlSchemaAppInfo ap = new XmlSchemaAppInfo();<o:p></o:p></p>

<p class=ILprg>a.Items.Add(ap);<o:p></o:p></p>

<p class=ILprg>XmlDocument dc1 = new XmlDocument();<o:p></o:p></p>

<p class=ILprg>XmlNode n1;<o:p></o:p></p>

<p class=ILprg>n1 = dc1.CreateTextNode(&quot;how are you&quot;);<o:p></o:p></p>

<p class=ILprg>XmlNode [] na1 = new XmlNode[1];<o:p></o:p></p>

<p class=ILprg>na1[0] = n1;<o:p></o:p></p>

<p class=ILprg>ap.Markup = na1;<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:annotation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:documentation&gt;sonals
husband&lt;/xs:documentation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:appinfo&gt;how are you&lt;/xs:appinfo&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:annotation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:element&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The annotation
element, which has not been touched upon so far, deals with documentation. This
element describes the user-defined elements. Programmers abhor the idea of
inserting comments into their code. This is one of the fundamental reasons for
taking up the annotation element much later in the day.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The annotation
must be the child of an element, which in our case is the element vijay. Thus,
an element 'e' with the name vijay is created first. Then, an instance 'a' of
the class XmlSchemaAnnotation is created and associated with the Annotation
property of the element 'e'. An annotation element can contain two other child
elements, viz. appinfo elements and documentation elements.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>An appinfo
element is essentially used to accommodate information used by various
applications. On the other hand, the documentation element stores information
aimed at the naïve users who may risk venturing forth to read the code. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>An
XmlSchemaDocumentation class represents a documentation element, which is 'd'
in this program. This documentation element is added to the XmlSchemaAnnotation
object 'a', since the annotation has to keep track of the documentation object.
This documentation object requires some text or markup representing its
content. Therefore, the XmlDocument object 'dc' is used, since it represents
the content placed between tags or elements. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The object 'dc'
has a function called CreateTextNode, which is passed the text that is to be
used as markup. The return object is an XmlNode that eventually represents the
text. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Then, an array
with an arraysize of 1 and of type XmlNode is created, whose first and only
member is initialized to the XmlNode object 'n'. The Markup property of the
documentation object 'd' is then initialized to this XmlNode array 'n'. An
array is used whenever multiple members of the same type are required. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The appinfo
element is represented by an XmlSchemaAppInfo object named 'ap'. This object is
initialized to the Items collection of the annotation object 'a'. This is
because an annotation object can have only two children, viz. the documentation
and the appinfo objects. So, just as before, the XmlNode object is created, and
thereafter, the Markup property of the appinfo object is used to specify the
content.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;vijay&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaAnnotation a = new XmlSchemaAnnotation();<o:p></o:p></p>

<p class=ILprg>e.Annotation = a;<o:p></o:p></p>

<p class=ILprg>XmlSchemaDocumentation d= new XmlSchemaDocumentation();<o:p></o:p></p>

<p class=ILprg>a.Items.Add(d);<o:p></o:p></p>

<p class=ILprg>XmlDocument dc = new XmlDocument();<o:p></o:p></p>

<p class=ILprg>XmlNode n,n1;<o:p></o:p></p>

<p class=ILprg>n = dc.CreateTextNode(&quot;sonal &quot;);<o:p></o:p></p>

<p class=ILprg>n1 = dc.CreateTextNode(&quot;Bye Bye&quot;);<o:p></o:p></p>

<p class=ILprg>XmlNode [] na = new XmlNode[2];<o:p></o:p></p>

<p class=ILprg>na[0] = n;<o:p></o:p></p>

<p class=ILprg>na[1] = n1;<o:p></o:p></p>

<p class=ILprg>d.Markup = na;<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;vijay&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:annotation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:documentation&gt;sonalBye Bye&lt;/xs:documentation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:annotation&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:element&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The earlier
program is updated now, wherein the array is extended to hold two XmlNode
structures. Thus, the array of XmlNode objects that is passed to the property
Markup, contains two bits. This does not result in the creation of two separate
documentation elements within the xsd file; instead, it spawns a single string
with all the individual contents concatenated together. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;zzz&quot;;<o:p></o:p></p>

<p class=ILprg>XmlSchemaAnnotation a = new XmlSchemaAnnotation();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(a);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:annotation /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the above
example, the annotation element is added to the schema and not to the element.
As an outcome of this, it becomes a child of the schema element. This brings
the annotation as well as the element to the same level, i.e. as children of
the schema.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<span style="mso-spacerun: yes">  </span><o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchema s = new XmlSchema();<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = new XmlSchemaElement();<o:p></o:p></p>

<p class=ILprg>s.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>e.Name = &quot;zzz&quot;;<o:p></o:p></p>

<p class=ILprg>s.Items.Add(e);<o:p></o:p></p>

<p class=ILprg>ValidationEventHandler v = new ValidationEventHandler(abc);<o:p></o:p></p>

<p class=ILprg>s.Compile(v);<o:p></o:p></p>

<p class=ILprg>s.Write(Console.Out);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public static void abc(object s, ValidationEventArgs a) <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(a.Message);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Global element 'zzz' has already been declared.<o:p></o:p></p>

<p class=ILoutput>&lt;?xml version=&quot;1.0&quot;
encoding=&quot;IBM437&quot;?&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The xsd file gets
created, notwithstanding any errors that may or may not occur. In the above
example, the element zzz is added twice using the Items collection. This
results in an error, since two elements with the same name cannot co-exist at
the same level. Despite this, the xsd file shows two zzz elements, but the abc
function displays an error message.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Henceforth, we
shall employ an altogether distinctive method for reading an existing xsd file.
Since an xsd file is eventually an xml file, the XmlTextWriter class is used to
read an xml file and fragment it into its constituent components. Thus, we
shall now read an xsd file as an xml file and simultaneously, display it
contents. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>A salient point
to be committed to memory is that the file being read or written to is an xml
file and not an XML Schema file. Nonetheless, the API is exceptionally
powerful, since it understands XML Schemas, unlike the approach adopted
presently. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(&quot;...&quot; + s.SourceUri+ &quot; &quot; +
XmlSchema.Namespace + &quot; &quot; + s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;schema&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>...file:///c:/xmlprg/b.xsd http://www.w3.org/2001/XMLSchema <o:p></o:p></p>

<p class=ILoutput>&lt;schema targetNamespace=&quot;&quot;
xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; /&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The XmlTextWriter
object 't' is conversant with writing an xml file to the disk or elsewhere. The
device chosen here is that of Console. The nitty-gritties of the XmlTextWriter
class shall not be touched upon, since they have been dealt with
comprehensively in our first book on XML. The properties of Formatting and
Indentation are used to make the xml file more readable.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The Add function
is used to add the schema files to the XmlSchemaCollection class. In this
program, we have only added the file b.xsd. Then, using the 'foreach' construct
on the XmlSchemaCollection object, an XmlSchema object that represents the
schema file, is returned. The only schema in the collection viz. b.xsd, is
represented by the XmlSchema object named 's'. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The SourceURI
property provides the name of the xsd file associated with the XmlSchema object
s. The Namespace property is like a normal URI. It is associated with the class
and not with the object. Since no target namespace is given in the xsd file,
the TargetNamespace property displays a value of null. As mentioned earlier,
the XmlTextWriter replicates the contents of the file, where the XmlSchema
object 's' represents the actual contents.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The function
WriteStartElement takes two parameters, viz. the name of the element and the
namespace that the function belongs to. For the first parameter, the name of
the element is specified as schema. For the second parameter, the familiar
namespace that holds the namespace is specified. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In order to
specify the attribute targetNamespace, the function WriteAttributeString is
employed. This function takes the attribute as its first parameter. This
attribute is part of the last element that has been written but not closed yet,
which in our case is schema. Our targetNamespace is an empty string. Then, the
element is closed using the function WriteEndElement.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>If you were to
observe closely, you would discern that the schema element has no namespace
prefixes such as xs: or xs:.<span style="mso-spacerun: yes">  </span>Instead,
it uses the xmlns to specify the default namespace as the namespace. In the
earlier programs, there existed a class that represented a schema element.
Moreover, the end of schema was not considered imperative. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the ultimate
analysis, what emerges is that all the classes that represent the various
elements are finally replaced by the two functions named WriteStartElement and
WriteEndElement.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(&quot;...&quot; + s.SourceUri+ &quot; &quot; +
XmlSchema.Namespace + &quot; &quot; + s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;xs:schema&quot;);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;xmlns:xs&quot;,
&quot;http://www.w3.org/2001/XMLSchema&quot;);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
&quot;&quot;);<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>...file:///c:/xmlprg/b.xsd http://www.w3.org/2001/XMLSchema <o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;&quot; /&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>An alternate way
of writing the same program is by omitting the namespace that the element
belongs to. Instead, the element name can be prefaced with the namespace
prefix. However, the attribute of xmlns:xs must be added with the XML namespace
value. The WriteAttributeString function expects a name and a value, but does
not expect any<span style="mso-spacerun: yes">  </span>parameter for the
namespace.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(&quot;...&quot; + s.SourceUri+ &quot; &quot; +
XmlSchema.Namespace + &quot; &quot; + s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;schema&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchemaInclude include in s.Includes)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;include&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;schemaLocation&quot;,
include.SchemaLocation);<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>b.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:include schemaLocation=&quot;a1.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:include schemaLocation=&quot;a2.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>...file:///c:/xmlprg/b.xsd http://www.w3.org/2001/XMLSchema <o:p></o:p></p>

<p class=ILoutput>&lt;schema targetNamespace=&quot;&quot;
xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;/&gt;<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">  </span>&lt;include
schemaLocation=&quot;a1.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">  </span>&lt;include
schemaLocation=&quot;a2.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/schema&gt;<o:p></o:p></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(&quot;...&quot; + s.SourceUri+ &quot; &quot; +
XmlSchema.Namespace + &quot; &quot; + s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;schema&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchemaInclude i in s.Includes)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;include&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;schemaLocation&quot;,
i.SchemaLocation);<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>...file:///c:/xmlprg/b.xsd http://www.w3.org/2001/XMLSchema <o:p></o:p></p>

<p class=ILoutput>&lt;schema targetNamespace=&quot;&quot;
xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">  </span>&lt;include
schemaLocation=&quot;a2.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">  </span>&lt;include
schemaLocation=&quot;a1.bsd&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/schema&gt;<o:p></o:p></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The xsd file can
contain multiple 'import' or 'include' elements to usher in the varied types
from other files. For this purpose, the XmlSchema class has a property called
Includes, which is of type XmlSchemaObjectCollection. Its indexer returns an
XmlSchemaInclude object that furnishes information related to the 'include' or
the 'import' element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The 'foreach'
construct is used to iterate over the collection class, wherein the 'include'
element is written out using the WriteStartElement function. Thereafter, only
the value of the schemaLocation attribute is written with the help of the
WriteAttributeString function. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The value of this
attribute is stored in the property SchemaLocation of the XmlSchemaInclude
class. The last EndElement function is used with the basic purpose of writing
the end tag for the schema element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(s.Items.Count);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;schema&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>foreach(object i in s.Items)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>if ( i is XmlSchemaElement)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = (XmlSchemaElement) i ;<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;element&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>if (e.Name != null)<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;name&quot;, e.Name);<o:p></o:p></p>

<p class=ILprg>if (!e.SchemaTypeName.IsEmpty)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>t.WriteStartAttribute(&quot;type&quot;, null);<o:p></o:p></p>

<p class=ILprg>t.WriteQualifiedName(e.SchemaTypeName.Name,
e.SchemaTypeName.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteEndAttribute();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>b.xsd</u><o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;zzz&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;yyy&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>2<o:p></o:p></p>

<p class=ILoutput>&lt;schema targetNamespace=&quot;&quot;
xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;element name=&quot;zzz&quot; type=&quot;string&quot;
/&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;element name=&quot;yyy&quot; type=&quot;string&quot;
/&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The Items
collection has a property called Count, which gives a count of the number of
items present in the xsd file. Given that the xsd file has two elements, the
Count property returns a value of 2. The schema element is not counted as a
valid element. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Then, using the
'foreach' construct, each one of the items in the collection is accessed. Since
these items may be of any type, they are received as a type object. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Using the 'if'
statement, a verification is carried out to ascertain if this object is indeed
of type XmlSchemaElement element. If the condition is true, it implies that the
element has been targeted, and therefore, the tag element is printed using the
WriteStartElement function. But prior to this, the value of 'i' is stored in an
object into 'e', which is an XmlSchemaElement. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The second check
is performed on the name property. If it is not null, then the attribute 'a' is
written with the name equal to the value of the property name in the
XmlSchemaElement. This check is indispensable, since there is a possibility of
using the 'ref' attribute instead. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Finally, a check
is performed on the SchemaTypeName. Contingent upon whether it is empty or
otherwise, the name of the attribute type is written. The other function that
is pressed into action is the WriteQualifiedName function, which contains the
name of the attribute string and the namespace from which it originates. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>This function is
astute enough to establish the fact that the name string shall automatically be
prefaced by the default xsd prefix. Hence, it writes the attribute as string
and not as xs:string. The WriteEndAttribute function is needed to conclude the
start of the attribute. Lastly, to end the element called 'element', the
WriteEndElement function is used.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System;<o:p></o:p></p>

<p class=ILprg>using System.IO;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlTextWriter t;<o:p></o:p></p>

<p class=ILprg>t= new XmlTextWriter(Console.Out);<o:p></o:p></p>

<p class=ILprg>t.Formatting = Formatting.Indented;<o:p></o:p></p>

<p class=ILprg>t.Indentation = 2;<o:p></o:p></p>

<p class=ILprg>XmlSchemaCollection sc = new XmlSchemaCollection();<o:p></o:p></p>

<p class=ILprg>sc.Add(null, &quot;b.xsd&quot;);<o:p></o:p></p>

<p class=ILprg>foreach(XmlSchema s in sc)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>Console.WriteLine(s.Items.Count);<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;schema&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;targetNamespace&quot;,
s.TargetNamespace);<o:p></o:p></p>

<p class=ILprg>foreach(object i in s.Items)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>if ( i is XmlSchemaComplexType)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchemaComplexType c = (XmlSchemaComplexType)i;<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;complexType&quot;,
XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;name&quot;, c.Name);<o:p></o:p></p>

<p class=ILprg>if (c.Particle != null)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>if (c.Particle is XmlSchemaSequence)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;sequence&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>if ( i is XmlSchemaElement)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>XmlSchemaElement e = (XmlSchemaElement ) i ;<o:p></o:p></p>

<p class=ILprg>t.WriteStartElement(&quot;element&quot;, XmlSchema.Namespace);<o:p></o:p></p>

<p class=ILprg>if (e.Name != null)<o:p></o:p></p>

<p class=ILprg>t.WriteAttributeString(&quot;name&quot;, e.Name);<o:p></o:p></p>

<p class=ILprg>if (!e.SchemaTypeName.IsEmpty)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>t.WriteStartAttribute(&quot;type&quot;, null);<o:p></o:p></p>

<p class=ILprg>t.WriteQualifiedName(e.SchemaTypeName.Name,
e.SchemaTypeName.Namespace);<o:p></o:p></p>

<p class=ILprg>t.WriteEndAttribute();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>t.WriteEndElement();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>b.xsd</u><o:p></o:p></p>

<p class=ILoutput>&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:element name=&quot;zzz&quot;
type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:complexType name=&quot;c1&quot; &gt;<o:p></o:p></p>

<p class=ILoutput>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>2<o:p></o:p></p>

<p class=ILoutput>&lt;schema targetNamespace=&quot;&quot;
xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;element name=&quot;zzz&quot; type=&quot;string&quot;
/&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;complexType name=&quot;c1&quot;&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;sequence /&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/complexType&gt;<o:p></o:p></p>

<p class=ILoutput>&lt;/schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The above program
is the concluding example of this series. The element is given a type of
complexType. As a consequence, the Items collection now contains an element as
well as a complex type. Therefore, the return value of 2 is obtained. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The 'if'
statement ascertains whether 'i' is an XmlSchemaComplexType element or not.
Then, it casts the object value, as was done previously. Thereafter, the tag
complexType is written along with the attribute name. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>As mentioned
earlier, the Particle property can either be a sequence, a choice, a group, or
all of these. If it is not null, it is indicative of the presence of a valid
Particle. It is then ascertained whether this Particle is an XmlSchemaSequence
or not; if it is so, then the sequence element is written out. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>We would
recommend the use of the earlier API in lieu of this method, since it can
understand and appreciate schemas, whereas this one can only comprehend XML.
The API enjoys intrinsic knowledge of the schema world, which may ironically
prove to be its biggest stumbling block.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>&gt;csc /t:library a.cs<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>This creates a
dll file named a.dll. We then run the xsd program on a.dll using the command <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>&gt; xsd a.dll <o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>This command
creates a file called schema0.xsd. The contents of this file are displayed
below.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;a1&quot;
type=&quot;xs:int&quot; /&gt;<o:p></o:p></span></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The schema tag is
created with the attributes of elementFormDefault having a value of qualified
and with the default namespace of xs . The class zzz results in the creation of
an element called zzz, with the nillable attribute set to true. This element
has a complexType of zzz.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><span
style="mso-spacerun: yes"> </span><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, a C# class
becomes an element as well as a type, both bearing the same name. The
complexType is followed by a sequence and then, by an element with an int
variable named a1. It is amply evident that its type is an int, and the values
assigned to the maxOccurs and minOccurs attributes are their default values,
which have been stated expressly. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlIgnoreAttribute()]<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the C#
program, an attribute called XmlIgnoreAttribute has been inserted from the
namespace System.Xml.Serialization . This attribute is entrusted with the onus
of ensuring that the variable that follows it is neither written nor serialized
to the disk. As an outcome of this, we find no mention of the variable a1
within the complexType zzz in the xsd file.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The C# class
places some attributes on the members of the class prior to the creation of a
dll. The dll file could even have been created by Visual Basic for all that we
care. Then, the xsd program is beckoned to generate a schema file. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The schema file
generated by the xsd file has a distinct appearance owing to the use of
attributes like Serialization. This schema file can be used for myriad
purposes, such as developing Web Services, etc. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlRootAttribute(ElementName=&quot;zzz1&quot;,
Namespace=&quot;ttt&quot;, IsNullable=true )]<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema xmlns:tns=&quot;ttt&quot;
elementFormDefault=&quot;qualified&quot; targetNamespace=&quot;ttt&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz1&quot; nillable=&quot;true&quot;
type=&quot;tns:zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;a1&quot;
type=&quot;xs:int&quot; /&gt;<o:p></o:p></span></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The
XmlRootAttribute can only be placed before one of the following: a class, a
structure, an enum and an interface. It identifies the aforementioned four
entities as the root or top-level elements of an XML-document instance. Akin to
all other attribute classes, it too has to be derived from the Attribute. This
class is basically used to determine the manner in which the xsd program
generates the root element.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The ElementName
property is set to zzz1. Thus, in the schema that is generated, the element
name has been changed to zzz1, but the complexType name is retained as zzz,
which is the name of the class. The elementFormDefault property takes the
default value of 'qualified'. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Owing to the
property Namespace, the targetNamespace that was null earlier, is now amended
to ttt. Thus, every entity created in this xsd file, such as the complexType
zzz, is prefaced with the namespace prefix q1. This prefix is created using the
xmlns attribute with a value of ttt. It is created in the element zzz1, and not
in the prefix. The property IsNullable represents the attribute of xsi:nil.<o:p></o:p></span></p>

<p class=ILprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlRootAttribute ()]<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>a.cs(6,2): error CS0592: Attribute
'System.Xml.Serialization.XmlRootAttribute' is not valid on this declaration
type. It is valid on 'class, struct, enum, interface, return' declarations
only.<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The attribute
class identifies the precise location wherein a newly created attribute can be
used. The XmlRootAttribute can only be used on the aforementioned four
entities.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int a2;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element minOccurs=&quot;1&quot;
maxOccurs=&quot;1&quot; name=&quot;a1&quot; type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;yyy&quot; nillable=&quot;true&quot;
type=&quot;yyy&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;yyy&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;a2&quot;
type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>There are two
classes in the dll file, viz. a zzz class and a yyy class. Therefore, two
elements of zzz and yyy are seen in the xsd file. The zzz element has a type of
zzz, while the yyy element has a type of yyy. Thus, there could exist as many
classes as one desires, but the general rule that never ceases to apply is that
each class becomes an element and a type.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public yyy a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int a2;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;a1&quot;
type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;yyy&quot; nillable=&quot;true&quot;
type=&quot;yyy&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;yyy&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;a2&quot;
type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In a.cs, the
variable a1 in the class zzz is declared to be of type yyy, instead of an int.
This change is witnessed in the xsd file, where the type of the element named
a1 is changed from int to yyy. The other modification is visually apparent. In
normal cases, the element yyy comes first, followed by its complex type.
However, in the above case, this sequence has been reversed. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlElementAttribute(ElementName=&quot;aa&quot;
, Namespace=&quot;ttt&quot;)]<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:import namespace=&quot;ttt&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;
xmlns:q1=&quot;ttt&quot; ref=&quot;q1:aa&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema1.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema xmlns:tns=&quot;ttt&quot;
elementFormDefault=&quot;qualified&quot; targetNamespace=&quot;ttt&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;aa&quot; type=&quot;xs:int&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the C#
program, the XmlElementAttribute is placed over the element a1. The ElementName
property is set to aa. Hence, in the xsd file schema1.xsd, the element name
changes from a1 to aa. The Namespace property is set to ttt. This leads to the
import element being added to the scheam0.xsd file, with the namespace
attribute set to ttt. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the
complexType zzz, there is an element that refers to q1:aa. This element is not
present in the file, and yet no errors are generated, since the xmlns attribute
points the q1 namespace prefix to ttt. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In schema1.xsd,
the targetNamespace is set to ttt. It contains one element, which is present in
namespace aa. Thus, all the items present in the other namespace are posited in
a separate file.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlElementAttribute(Namespace=&quot;ttt&quot;)]<o:p></o:p></p>

<p class=ILprg>public int a1;<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlElementAttribute(Namespace=&quot;uuu&quot;)]<o:p></o:p></p>

<p class=ILprg>public int a2;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:import namespace=&quot;ttt&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:import namespace=&quot;uuu&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;
xmlns:q1=&quot;ttt&quot; ref=&quot;q1:a1&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot;
xmlns:q2=&quot;uuu&quot; ref=&quot;q2:a2&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema1.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema xmlns:tns=&quot;ttt&quot;
elementFormDefault=&quot;qualified&quot; targetNamespace=&quot;ttt&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;a1&quot; type=&quot;xs:int&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema2.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema xmlns:tns=&quot;uuu&quot; elementFormDefault=&quot;qualified&quot;
targetNamespace=&quot;uuu&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;a2&quot; type=&quot;xs:int&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the above
instance, the elements a1 and a2 belong to separate namespaces ttt and uuu. In
the schema0.xsd file, the two import elements refer to the namespaces ttt and
uuu. The first element in the sequence refers to the element a1 using the
namespace prefix q1, which points to the namespace ttt. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In much the same
way, the second element uses the namespace prefix q2 to refer to the element
a2. Further, q2 is initialized to the namespace uuu, using the xmlns attribute.
The namespace ttt dwells in the file schema1.xsd, which contains a single
element named a1. The file schema2.xsd contains the namespace uuu and the
element a2. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, if the
elements emanate from a 100 disparate namespaces in the C# program, then there
would exist 100 distinct xsd files, one for each statement. Then, the import
statements shall usher them all in. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlElementAttribute(DataType=&quot;positiveInteger&quot;)]<o:p></o:p></p>

<p class=ILprg>public string a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;
name=&quot;a1&quot; type=&quot;xs:positiveInteger&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The type of the
element is changed from a string to a positiveInteger by using the DataType
property. As an outcome of this modification, the type of the element a1
transforms from a string into a positive integer in the xsd file. Thus, it sets
the type in the xml file and not in the C# program. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>There is a
mammoth table in the 'help' section of the property DataType, which furnishes
all the details of the various XML data types and their .NET equivalents. For
the most part, the .Net data types are strings.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>using System.Xml.Serialization;<o:p></o:p></p>

<p class=ILprg>using System.Xml;<o:p></o:p></p>

<p class=ILprg>using System.Xml.Schema;<o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>[System.Xml.Serialization.XmlElementAttribute(DataType=&quot;boolean&quot;)]<o:p></o:p></p>

<p class=ILprg>public string a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Error</u><o:p></o:p></p>

<p class=ILoutput>Error: There was an error processing 'a.dll'.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>-There was an error
reflecting 'zzz'.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>-'boolean' is an
invalid value for the XmlElementAttribute.DataType property. boolean can not be
converted to System.String.<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The xsd program
generates an error while trying to convert a boolean into a String. The table
very lucidly states that both, the XML data type and the .Net data type should
be strings. Thus, just any two types cannot be randomly brought together and
expected to work with each other. As a prerequisite, a conversion between the
two types should be achievable. This error is an xsd error and not a C#
compiler error.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public string [] a1;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;
name=&quot;a1&quot; type=&quot;ArrayOfString&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;ArrayOfString&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;0&quot;
maxOccurs=&quot;unbounded&quot; name=&quot;string&quot;
nillable=&quot;true&quot; type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The C# program
has a variable a1, whose type is an array of strings. This variable in the xsd
file becomes a type ArrayOfString. The complexType is a sequence containing one
element that has a minOccurs value of zero, which implies that the element does
not have to be present. It also has a maxOccurs value of 'unbounded'. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, an array is
represented by a complexType, where the element can occur from zero to infinite
number of times. It imbibes the name of the data type of the array in the C#
program.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public string a1<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>get <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>int i;<o:p></o:p></p>

<p class=ILprg>return &quot;&quot;;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>set <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;hell&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;
name=&quot;a1&quot; type=&quot;xs:string&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>What works for a
variable also works for a property. In the above C# program, a1 is declared as
a property called string, which becomes an element a1 in the xsd program. For
the user of a class, there is no possible means of distinguishing between a
property and a variable. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Variables have
fallen out of favour, while the properties are in vogue today, wherein code is
executed using a 'set' or a 'get' for the value of a property.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The property a1
contains a variable called i along with the WriteLine function. None of this
gets reflected in the XML Schema file. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public string a1<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>set <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;hell&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The property a1
in the C# program has only a 'set' accessor; hence, its value cannot be read.
Since its value can only be set, the property is not added into the schema
file.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public string a1<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>get <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>return &quot;&quot;;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The property with a 'get' accessor too is not added to the xsd
file. <o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public void abc()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>None of the code
present in the C# program is reflected in the XML Schema. Thus, the above
function abc finds no mention in the XML Schema file.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>int i;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The variable i
does not become an element in the xsd file since it is private to the class.
Only members that are public find a mention in the XML Schema file.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>int i;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class yyy : zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>int j;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot; xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; nillable=&quot;true&quot;
type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;yyy&quot; nillable=&quot;true&quot;
type=&quot;yyy&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;yyy&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexContent mixed=&quot;false&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:extension base=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexContent&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The class yyy
derives from the class zzz. This results in the conversion of the zzz class
into an element named zzz, having a data type of zzz. The class yyy becomes an
element of type yyy. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Now comes the
cropper. The complexType yyy has a complexContent element, which does not
permit content between tags, since the mixed attribute has a value of false.
This type now extends the class zzz, since the base attribute is initialized to
zzz. The derived class in C# is represented by the extension element in the xsd
world.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>interface iii<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>int i<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>get;<o:p></o:p></p>

<p class=ILprg>set;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public class yyy : iii<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int i<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>get {return 0;}<o:p></o:p></p>

<p class=ILprg>set {}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;yyy&quot; nillable=&quot;true&quot;
type=&quot;yyy&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;yyy&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;i&quot;
type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>The .cs file now
has an interface called iii with a property named 'i'. This property must be
present in the class yyy, since the class yyy extends from this interface. This
relationship is not stored in the xsd file, because interfaces have no
equivalence in the Schema world. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>Thus, the usage
of one or more interfaces in the class yyy definition shall never get reflected
in the xsd file. There is no way of discerning as to which element originates
from which interface. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>We have no reason
to fret in this regard, since interfaces have to be implemented in the class.
Moreover, the extension mechanism cannot have more than one base at a given
time.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public enum zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>a1=10,a2<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:simpleType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:restriction base=&quot;xs:string&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:enumeration value=&quot;a1&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:enumeration value=&quot;a2&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:restriction&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:simpleType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>An enum is a type
whose value is restricted. The enum zzz gets converted to an element zzz and a
simpleType zzz. This type is restricted by the string type, and it uses the
enumeration element to specify the valid values.<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public struct zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int i;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>schema0.xsd</u><o:p></o:p></p>

<p class=ILprg>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:schema elementFormDefault=&quot;qualified&quot;
xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:element name=&quot;zzz&quot; type=&quot;zzz&quot; /&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:complexType name=&quot;zzz&quot;&gt;<o:p></o:p></p>

<p class=ILprg>&lt;xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg><span style='font-size:9.5pt'>&lt;xs:element
minOccurs=&quot;1&quot; maxOccurs=&quot;1&quot; name=&quot;i&quot;
type=&quot;xs:int&quot; /&gt;</span><o:p></o:p></p>

<p class=ILprg>&lt;/xs:sequence&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:complexType&gt;<o:p></o:p></p>

<p class=ILprg>&lt;/xs:schema&gt;<o:p></o:p></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>C# is extremely
stringent about the disparity between value types structures and reference types
classes. <o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'>In the .cs file,
even though the struct zzz has an int, the schema file retains it as an element
and a complex type. Thus, there is no difference between a structure 'i' and a
class 'n' in the Schema world<o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='font-family:"Bookman Old Style"'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/xsd/chap7.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 14:06:11 GMT -->
</html>
