<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">


<!-- Mirrored from www.vijaymukhi.com/documents/books/vsnet/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:55:53 GMT -->
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="chap5_files/filelist.html">
<link rel=Edit-Time-Data href="chap5_files/editdata.html">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Visual Studio.Net with C#</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>4</o:Revision>
  <o:TotalTime>9</o:TotalTime>
  <o:Created>2001-11-18T20:14:00Z</o:Created>
  <o:LastSaved>2001-11-19T20:05:00Z</o:LastSaved>
  <o:Pages>8</o:Pages>
  <o:Words>6422</o:Words>
  <o:Characters>36607</o:Characters>
  <o:Company>V.M.C.I.</o:Company>
  <o:Lines>305</o:Lines>
  <o:Paragraphs>73</o:Paragraphs>
  <o:CharactersWithSpaces>44955</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.VSBASE, li.VSBASE, div.VSBASE
	{mso-style-name:"VS BASE";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.VSPROG, li.VSPROG, div.VSPROG
	{mso-style-name:"VS PROG";
	mso-style-parent:"VS BASE";
	mso-style-next:"VS BASE";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.VSOUTPUT, li.VSOUTPUT, div.VSOUTPUT
	{mso-style-name:"VS OUTPUT";
	mso-style-parent:"VS BASE";
	mso-style-next:"VS BASE";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.VSBULLETS, li.VSBULLETS, div.VSBULLETS
	{mso-style-name:"VS BULLETS";
	mso-style-parent:"VS BASE";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.jpg></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=VSBASE align=left style='text-align:left'><b><span style='font-size:
24.0pt;mso-bidi-font-size:10.0pt;color:windowtext'>5. The Basics of C#<o:p></o:p></span></b></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We are of the opinion that,
unless you are aware of what Visual Studio.Net does backstage, you will never
be comfortable using it. Therefore, we decided to devote an entire chapter in
explaining the rudiments of the C# programming language. We could have
requested you to refer to our voluminous books on C# programming, but we felt
that it would be unfair to expect you to learn, a great deal more than is
actually required. If you are already conversant with programming, you may skip
this chapter. However, we recommend that you read it anyway, and give us a
feedback on what impression you gain about our handiwork.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In order to expound the
language, we will commence by creating the smallest possible form, comprising
of a textbox and a button. When the user clicks on the button, our program gets
executed. Close all open Solutions, and then click on File - New - Project.
Select Visual C# Project as the project type, and Windows Application as the
template type. We have named this application as z1, and stored it in a
distinct location, i.e. c:\mukhi. Click on OK. You must ensure that the toolbox
and the Properties Windows are clearly visible on the screen. From the toolbox,
drag-and-drop a button and a textbox into the form. Thereafter, double click on
the button, to arrive at the Code Painter, and insert the following lines of
code:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>string items;</p>

<p class=VSPROG>items = &quot;good&quot;;</p>

<p class=VSPROG>textBox1.Text = items;</p>

<p class=VSPROG>MessageBox.Show(items);</p>

<p class=VSPROG>items = &quot;bad&quot;;</p>

<p class=VSPROG>textBox1.Text = items;</p>

<p class=VSPROG>MessageBox.Show(items);</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We have used a word called
'items', which stores a string. A string is a term used to represent a series
of characters or letters of the alphabet. On the next line, 'items' has been
assigned the value &quot;good&quot;. As all string values are to be enclosed
within double inverted quotes, the word &quot;good&quot; too is enclosed within
double quotes. The Text property of the textbox named textBox1, is then
initialized to items, as it contains the string literal. We iterate the same
procedure for the Show function. Build and run the project. The output screen
displays a textbox and a button at their respective positions. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>When you click on the button,
the word &quot;good&quot; will be highlighted in the textbox, as well as seen
in the message box. If you click on the OK button of MessageBox, the value
changes to &quot;bad&quot;.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=200 height=200 id="_x0000_i1026"
  src="chap5img/5.1.jpg"></p>
  </td>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=200 height=200 id="_x0000_i1027"
  src="chap5img/5.2.jpg"></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 5.1</p>
  </td>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 5.2</p>
  </td>
 </tr>
</table>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Thus, wherever a string can be used,
it can be effortlessly substituted with words like 'items', etc. We shall term
words like 'items' as variables. Thus, the variable 'items' will hold one of
the two values: &quot;good&quot; or &quot;bad&quot;.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Close the running program and
select the tab window of Form1.cs, which is the Code Painter. Amend the above
stated lines to the following:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>int products;</p>

<p class=VSPROG>products = 20;</p>

<p class=VSPROG>MessageBox.Show(products.ToString());</p>

<p class=VSPROG>products = products + 10;</p>

<p class=VSPROG>MessageBox.Show(products.ToString());</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>A new variable called 'products'
has been created, and since it has the word 'int' preceding it, it is capable
of storing numbers only. In a sense, C# is being unequivocally apprized about
the type of values that the variable would hold. The variable 'products', of
data type int, shall only store a number, whereas in the earlier case, the
variable 'items', of data type 'string', is permitted to store only character
literals. The variable 'products' is initialized to a value of 20, and
displayed in the MessageBox. Unfortunately, the Show function in MessageBox
demands a string. Under such circumstances, the ToString function is used to
convert a number into a string format.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Once the MessagBox is closed,
the next statement in succession gets executed. Here, we observe an 'equal to'
sign =. Any statement with an 'equal to' sign, must be read from right to left.
The statement 'products + 10' on the right hand side, will evaluate to 20 + 10;
thereby, adding up to a total of 30. This value is then allocated to the
variable on the left hand side. Thus, the line ultimately evaluates to
'products = 30'. The MessageBox pops up, displaying this new value of 30,
thereby, confirming our contention. Screen 5.3 and screen 5.4 provides ample
proof of this.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=200 height=200 id="_x0000_i1028"
  src="chap5img/5.3.jpg"></p>
  </td>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=200 height=200 id="_x0000_i1029"
  src="chap5img/5.4.jpg"></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 5.3</p>
  </td>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 5.4</p>
  </td>
 </tr>
</table>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, close the running application,
and replace the code with the new one, in exactly the same manner as is shown
below. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><i>abc();</i></p>

<p class=VSPROG>}</p>

<p class=VSPROG><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=VSPROG><i>void abc()<o:p></o:p></i></p>

<p class=VSPROG><i>{<o:p></o:p></i></p>

<p class=VSPROG><i>MessageBox.Show(&quot;hi&quot;);<o:p></o:p></i></p>

<p class=VSPROG><i>} </i></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>After inserting the above
statements, ensure that the code appears analogous to what is depicted below.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>private void button1_Click(object sender, System.EventArgs e)</p>

<p class=VSPROG>{</p>

<p class=VSPROG><span style='mso-tab-count:1'>            </span><i>abc();</i></p>

<p class=VSPROG>}</p>

<p class=VSPROG><i>void abc()<o:p></o:p></i></p>

<p class=VSPROG><i>{<o:p></o:p></i></p>

<p class=VSPROG><i><span style='mso-tab-count:1'>            </span>MessageBox.Show(&quot;hi&quot;);<o:p></o:p></i></p>

<p class=VSPROG><i>}</i></p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In due course of time, we shall
italicize, the freshly inserted code, in order to help you distinguish between the
recently added code and the previously existing one.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>When we run the above program
and click on the button, a MessageBox is displayed with the message
&quot;hi&quot;. Let us construe as to how this was made possible. A function is
a word, followed by a pair of round brackets ( ). Thus, abc is a function. The
perceptible difference here is that, unlike MessageBox.Show, which is a system
created function, the function abc is our handiwork. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>To create our own function, we
write the name of the function, followed by the () brackets. The data type of
the return value must also precede the name of the function. Since abc does not
return any value, the word 'void' has been used. Void denotes 'nothing'. The
code of the function is enclosed within the curly braces {}. We have written
just a single function named MessageBox.Show, which embodies the word
&quot;hi&quot; in it. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>When the application runs and
the button is clicked, the function abc gets called, in much the same fashion
as the MessageBox.Show was summoned earlier. The code of the function abc
executes the MessageBox.Show function. Thus, we see a message box, with the
word &quot;hi&quot; displayed in it.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, we shall learn to write a
function that accepts parameters. The code stipulated below corroborates this
concept. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>private void button1_Click(object sender, System.EventArgs e)</p>

<p class=VSPROG>{</p>

<p class=VSPROG><span style='mso-tab-count:1'>            </span><i>int i ;<o:p></o:p></i></p>

<p class=VSPROG><i><span style='mso-tab-count:1'>            </span>i
=abc(10,30);<o:p></o:p></i></p>

<p class=VSPROG><i><span style='mso-tab-count:1'>            </span>MessageBox.Show(i.ToString());</i></p>

<p class=VSPROG>}</p>

<p class=VSPROG><i>int abc(int j, int k)<o:p></o:p></i></p>

<p class=VSPROG><i>{<o:p></o:p></i></p>

<p class=VSPROG><i><span style='mso-tab-count:1'>            </span>return j +
k;<o:p></o:p></i></p>

<p class=VSPROG><i>}</i><b><o:p></o:p></b></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We commence by creating a variable
i, in much the same manner, as we created 'items' and 'products'.<span
style="mso-spacerun: yes">  </span>Thereafter, on the next line, we insert a
statement with the 'equal to' sign. We trust you to be able to recall the rules
of the 'equal to' sign. Always evaluate the expression from right to left. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The right hand side calls
function abc, with two parameters. In layman terms, the function abc is
supplied with two values. So, the code of function abc, must be able to accept
these two values. In order to effect this, two variables are created within the
round brackets () of the function abc, both having a data type of int. Thus, we
are calling upon C# to store the first value of 10 in the int parameter
variable j, and the second value of 30 in the int parameter variable j. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>As the function returns an int,
the datatype int precedes the word abc. C# can comprehend terms such as
'return'. So, it initially evaluates the expression j+k as 10+30, and returns
the result of 40 to the main program, which had called the function abc.
Effectively, the 'equal to' line evaluates to 'i = 40'. Thus, the variable i is
assigned the value of 40, which is displayed with the help of the
MessageBox.Show function. Functions return values, employing the 'return'
keyword. These return values may be of any data type. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, eliminate the entire newly
inserted code. This will ensure that the statements in the Code Painter appear
as follows:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>private void button1_Click(object sender, System.EventArgs e)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>It is time to revisit a few
concepts. Every time a button is inserted within a form, it is assigned a name,
by default. The name so assigned is 'button1' for the first button, button2 for
the second button, and so on. Similarly, the first textbox is assigned the name
'textBox1', and so on.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, when we double click on the
button in a form, we get transported to a certain location within the Code
Painter. The lines that are displayed exactly over and below this location, are
displayed above. Does this ring a bell somewhere? <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>You would realise that, we have
been transported to a position, within a function. This function is named as
button1_click. It does not return any value. Hence, its return value is void.
It accepts two parameters:<o:p></o:p></span></p>

<p class=VSBULLETS><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style="mso-spacerun: yes">   </span></span>'sender', having a datatype of
'object'.</p>

<p class=VSBULLETS><span style='mso-bidi-font-size:12.0pt;font-family:"Times New Roman"'>•<span
style="mso-spacerun: yes">   </span></span>'e', having a data type of 'System.EventArgs'.
</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>This is analogous to int j and
int k, which we had stumbled upon, earlier. The word 'private' is called an
access modifier. An access modifier determines who all are eligible to access
this function. We will elucidate this concept shortly.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Each time we click on a button
named zzz for instance, C# seeks out a function named zzz_Click, and executes
it. Being acquainted with these subtle concepts, enhances our understanding of
the techniques and workings of Visual Studio.Net, considerably. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, open a DOS box, and create
a folder called pqr, and go to this folder. Then, write the following lines of
code in a file called a.cs, using any word processor or editor.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT>C:\&gt;md pqr</p>

<p class=VSOUTPUT>C:\&gt;cd pqr</p>

<p class=VSOUTPUT>C:\pqr&gt;edit a.cs.</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We have created a function
called Main, which has no return value. Hence, its return value is of type
void. We will explain the term 'static' in a little while from now. At the DOS
prompt, give the following command.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT>C:\pqr&gt;Csc a.cs</p>

<p class=VSOUTPUT><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=VSOUTPUT><u>Output</u> </p>

<p class=VSOUTPUT>a.cs(1,1): error CS0116: A namespace does not directly
contain members such as fields or methods</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>On doing so, we come across the
above specified error message. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>You may receive an error message
disparate from the one displayed above; or you may even observe the error
message<span style="mso-spacerun: yes">  </span><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><span style="mso-spacerun: yes"> </span>'csc' is not
recognized as an internal or external command, operable program or batch file.</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In such cases, ensure that you
copy the file vcvars32.bat, located in C:\Program Files\Microsoft Visual
Studio.NET\Vc7\bin\, into your current directory. Thereafter, execute the
program.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT>C:\pqr&gt;vcvars32</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Run the csc command again, and
ascertain that the error displayed is akin to the one depicted above. The above
stated error message may make perfect sense to you; however, it is nothing but
mumbo-jumbo to us. Now, modify the file a.cs, to contain code as shown below,
and then, run the csc command on the file a.cs.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;hi&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT>c:\pqr&gt;csc a.cs</p>

<p class=VSOUTPUT>c:\pqr &gt;a</p>

<p class=VSOUTPUT><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>hi</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The csc command does not generate
any error, and produces a file called a.exe. The 'dir' command for directory
listing confirms this. Run this executable at the DOS prompt, and you will see
the output &quot;hi&quot; displayed on the screen.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>All code written in the C#
programming language, must be an integral part of a 'container'; or in
technospeak, it is part of a 'class'. Thus, to banish the earlier error, we
placed all our code in a class called zzz. The name zzz is actually of no
consequence at all. In the Main function, we have also added a function named
System.Console.WriteLine, which displays the string parameter passed to it, on
the screen. The function Main is always the first function to be called. Thus,
when we execute the program a.exe, &quot;hi&quot; gets displayed on the screen.
The Main function is thus, the starting point or entry point, and any code
statement placed within this function, gets executed first. If this function
had been assigned any other name, abc for instance, nothing at all would have
got executed.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public static void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In this program, we have
appended another class called yyy, following the class zzz. The class yyy contains
a function abc, whose sole business is to display &quot;abc&quot; on the
screen. Since the function does not belong to the current class, zzz, in order
to execute it, we have to specify the name of the class, followed by a dot
(which acts as a separator), and finally, the name of the function. As a
result, the final expression becomes yyy.abc. Thus, we find the text
&quot;abc&quot;<span style="mso-spacerun: yes">  </span>displayed, at the time
of executing the above program.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Akin to the word 'private', the
word 'public' is also an access modifier. An access modifier permits or
restricts access to a function. The word private allows only the members of the
same class to access its functions, whereas, the word 'public' permits all
other classes to call functions located within this class. Therefore, abc can be
called from zzz. If we change public to private and run the compiler, using the
csc command, an error message will be flashed. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(5,1): error CS0122: 'yyy.abc()' is inaccessible due to
its protection level</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Since abc is a member of the
class yyy, and as it is 'private', it forbids any outsider from accessing it.
This generates an error.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>namespace aaa</p>

<p class=VSPROG>{</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public static void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>If we add the term 'namespace'
to aaa, it generates the following error: <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(5,1): error CS0246: The type or namespace name 'yyy'
could not be found (are you missing a using directive or an assembly
reference?)</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>If you replace yyy.abc(); with
aaa.yyy.abc();, the error will disappear. In the real word, there are
innumerable classes containing functions. Consequently, these classes are
clubbed together, based on the similarity in the function or the task that they
perform. So, classes that deal with printing are placed into one group; while
those that deal with the Internet, are housed in another. Every such group is
called a 'namespace'.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Since the class yyy has been
placed in the namespace aaa, the full reference to the function is not merely
abc, but aaa.yyy.abc. In other words, it is the name of the namespace, followed
by the name of the class and finally, the name of the function, with each
entity separated by dots. The term System.Console.WriteLine refers to the
WriteLine function, within the class named Console, under the System namespace.
The first entity is the namespace name. The second entity is the name of the
class. And, the last entity is always the name of the function. The requirement
of providing the name of the namespace, each time that the function is to be
called, proves to be awfully tedious and irksome. Therefore, we use the term
'using', which eases our task.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using aaa;</p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>namespace aaa</p>

<p class=VSPROG>{</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public static void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Both, the WriteLine and abc
functions do not have the namespace preceding the class. Here, the 'using'
keyword handles the issue of attaching the appropriate namespace with each
class. So, whenever C# encounters a function like yyy.abc, it prefixes the
class name with the word that follows the 'using' keyword, before flagging an
error. If a match is found with an existing namespace, no error is generated.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now, let us effect a small
modification, by removing the word 'static' from the function abc. On running the
compiler with the command csc on the file a.cs, the following error will be
generated:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(6,1): error CS0120: An object reference is required for
the nonstatic field, method, or property 'yyy.abc()'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>What is the cause behind
occurrence of this error generated? And, what is the significance of the word
'static'? Before we confront this volley of questions, we want you to attempt
the following program:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>By writing int i in one of the
earlier program, we had created a variable i, of data type int. Instead of
calling int as a data type, we shall now call it a 'class', and instead of
terming i as a variable, we shall now term it as an 'object'. Thus, when we
write 'yyy a', it implies that 'a' is an object of data type yyy. In C#
parlance, 'a' is an 'object', which is an instance of the class 'yyy'.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>C# has divided classes into two
categories, viz. simple and complex. The class int is a simple class. Hence,
there is no need to create an object that is an instance of int. All data types
of the C programming language, have been converted into 'simple' classes in C#.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>However, yyy is a 'complex'
class. Hence, it requires the 'new' keyword. New results in the creation of an
instance of class yyy. Therefore, the line 'a = new yyy()' results in creating
a new instance of class yyy. Deletion of this line, saddles us with the
following error:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(8,1): error CS0165: Use of unassigned local variable 'a'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Thus, an object must be
instantiated or created by using the 'new' keyword, prior to accessing the
members embodied in it. Now, since the object 'a' has been initialized, a.abc()
will call the function abc, off class yyy. All other member can also be
accessed in a similar manner. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The C# purists term the 'simple'
class as the 'value' class, and the 'complex' class as the 'reference' class.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The 'static' keyword or
modifier, when used with a function, enables access to it without the need of
instantiating the class. Since a static function belongs to a class, and not to
an object, the name of the class must precede the static function during
access. References to non-static functions require the name of the instantiated
object.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>Console.WriteLine(&quot;Before&quot;);</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public yyy()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;yyy none&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>Before</p>

<p class=VSOUTPUT>yyy none</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>When we run the above program,
the first WriteLine function with 'Before' gets called. Thereafter, the
WriteLine function in the function yyy, within class yyy gets called, despite
our not having called this function.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>This act can be attributed to
the keyword 'new'. It first allocates code for the class, then it looks for a
function name that matches with the class name. If such a function exists, it
gets called instantly. Thus, this function gets called at the time of creation
of an object. In technical jargon, it is termed as a 'constructor'. Once the
function finishes execution, the object is created.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Constructors need special
handling, and cannot be called explicitly. They get called at the time of
creation of an object. If we place the statement a.yyy(); after the 'new'
statement in Main, it will yield the following error:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(9,1): error CS0117: 'yyy' does not contain a definition
for 'yyy'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Thus, any code that needs to be
called at the time of creation of an object, can be placed in the constructor.
The object is created only after the constructor completes execution.
Constructors are not permitted to return values. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Thus, modifying the constructor
as shown below, results in an error, as depicted below:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>public int yyy()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(13,12): error CS0542: 'yyy': member names cannot be the
same as their enclosing type</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Constructors are also empowered
to accept parameters. This has been clearly established in the program that
follows.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>Console.WriteLine(&quot;Before&quot;);</p>

<p class=VSPROG>a = new yyy(&quot;hi&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public yyy(string s)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(s);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>Before</p>

<p class=VSOUTPUT>Hi</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In the above program, the keyword
'new' along with yyy is assigned the word &quot;hi&quot;, as a parameter. This
is reflected in the signature of the constructor, that contains a parameter s,
of type 'string'. Thus, we can pass as many parameters to a constructor, as we
desire; and can also have scores of varied constructors, co-existing in the
same class. This concept has been expounded in great detail, in our books on
C#.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>xxx x;</p>

<p class=VSPROG>x = new xxx();</p>

<p class=VSPROG>x.abc();</p>

<p class=VSPROG>x.pqr();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc yyy&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void pqr()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;pqr xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSOUTPUT>pqr xxx</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>This mammoth program evinces a few
fundamental concepts about programming. The class yyy, which has one function
named abc, is instantiated using 'new'; and then, the function abc is called
from it.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Within this program, is another
class named xxx. This class ends with the words : yyy. This signifies that the
class xxx is allowed access to the entities existing in the class yyy. The
resultant effect is that, the code contained in yyy, also belongs to class xxx.
In C# parlance, class xxx 'inherits' from class yyy. Thus, the class yyy is called
the 'parent' class, while the class xxx is called the 'derived' class.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>x is instantiated to be an
instance of xxx. Since the class xxx encompasses both, xxx members and yyy
members, it is authorized to work with class yyy also. Thus, we are allowed to
call function abc from the object x, even though the object x does not contain
this function. It is an indirect reference, via class yyy. By using the concept
of inheritance, code written by other programmers can be borrowed or re-used in
a program, thereby, doing away with the need to re-invent the wheel every time!
<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>But, what if we want to enhance
the features of the function abc? In such a situation, the existing function
can be overridden with a new<span style="mso-spacerun: yes">  </span>copy of
abc, in the class xxx. In the next code block, everything remains unchanged,
except the introduction of the function abc.<span style="mso-spacerun: yes"> 
</span>So, modify the class xxx as shown below:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>public void pqr()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;pqr xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>To our utter amazement, the
following warnings are issued:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Warning</u></p>

<p class=VSOUTPUT>a.cs(23,13): warning CS0108: The keyword new is required on
'xxx.abc()' because it hides inherited member 'yyy.abc()'</p>

<p class=VSOUTPUT>a.cs(16,13): (Location of symbol related to previous warning)</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>To be honest, we are unable to
decipher the warning message. Despite the warnings, an executable file has been
created by the compiler. When we run the program, it produces the following
output:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSOUTPUT>abc xxx</p>

<p class=VSOUTPUT>pqr xxx</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Thus, we are able to call the
new function abc from the xxx class, albeit, with some warnings, which we shall
resolve subsequently. What happens if we wish to call the function from class
yyy also? This is easier said than done. We have rewritten the class xxx as
follows:<o:p></o:p></span></p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>base.abc();</p>

<p class=VSPROG>Console.WriteLine(&quot;abc xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>public void pqr()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;pqr xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSOUTPUT>abc xxx</p>

<p class=VSOUTPUT>pqr xxx</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The 'base' keyword calls the function
from the 'base' or the 'parent' class. Thus, we have access to the function abc
in the 'base' class, at the same time, in the 'derived' class. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>C# is very finicky about data
types. The MessageBox.Show function expects only a string data type. Hence, the
int data type had to be converted into a string type, using the ToString
function. An error is generated when two dissimilar data types are equated to
one another. The only exception to this rule arises, when a 'base' class is
equated to a 'derived' class. The next example illustrates this point.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc yyy&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public new void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc yyy</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We have initialized an object
'a', declared as class yyy, as an instance of the class xxx. This is
permissible, since we are equating an object of a 'base' class, to that of the
'derived' class. The sole point of concern here is that, the function will
always get called from the 'base' class and not from the 'derived' class. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The other point of interest here
is that, by adding the modifier 'new', the warnings do a vanishing act.
Warnings appeared, since the function in the 'derived' class had the same name
as the one in the 'base' class. It has to be explicitly declared as 'new',
because here, it has no relation to the function abc in the class yyy. Thus,
despite the fact that two functions share the same name of abc, they are
considered different, from C#'s point of view.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The term 'new' gets inserted by
default, incase it is omitted inadvertently. Therefore, C# gives us a benign
warning, and goes ahead with the generation of the exe file. At times, a warning
could be more dangerous than an error. This is because, notwithstanding the
fact that an exe file may have been created, there is always a possibility of a
serious problem lurking around the corner.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a ;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public virtual void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc yyy&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public override void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(&quot;abc xxx&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc xxx</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>After incorporating two changes in
the above program. The net result is that, the function abc gets called from
the class xxx, and not from the class yyy, since the object is initilalized to
the class xxx. The first modification is the introduction of the word 'virtual'
with the function 'abc' in the base class yyy. The second modification is the
replacement of the word 'new' with the modifier 'override', in the derived
class xxx. The 'override' modifier is the antithesis of 'new', as it overrides
the function in the base class. Therefore, unlike 'new', the function abc in
class xxx, now overrides the function abc in class yyy, thereby, eschewing the
creation of a new function.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Deletion of the modifier
'virtual' from the function abc in class yyy, generates the error that is
projected below. Therefore, the modifiers 'virtual' and 'new/override', go hand
in glove.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(20,22): error CS0506: 'xxx.abc()' : cannot override
inherited member 'yyy.abc()' because it is not marked virtual, abstract, or
override</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>protected static void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void pqr()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(6,1): error CS0122: 'yyy.abc()' is inaccessible due to
its protection level</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Out of the three access modifiers,
we have already touched upon two of them, viz. 'public' and 'private'. The
third one, i.e. 'protected' allows only the derived classes to access a
function. Therefore, the static function abc, marked as 'protected', permits
only the 'derived' class xxx to access it. Apart from this, members of a class
are allowed to access any other member of the same class. However, no other
function, including Main, is permitted to make a reference to this function.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a = new yyy();</p>

<p class=VSPROG>a.abc(20);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int i = 10;</p>

<p class=VSPROG>public void abc(int i)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Console.WriteLine(i);</p>

<p class=VSPROG>Console.WriteLine(this.i);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>20</p>

<p class=VSOUTPUT>10</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Variables or objects that have been
created within a function, are only accessible from within that function. If we
create them outside a function, they are accessible across functions, and are
termed as 'instance variables'. So, the variable i, which is created outside
all functions, is called an 'instance variable', and it is accessible to every
other function contained in the class. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The value of 20, assigned to the
function abc, is saved in a parameter named i. In a situation like this, the
parameter i is granted a higher priority, than the instance variable. Thus, i
by itself, refers to the parameter i, whereas, the term this.i refers to the
instance variable i. If we had named the parameter as j, then, i and this.i
would have referred to the same instance variable i.<span style="mso-spacerun:
yes">  </span>Thus, all instance variables are prefaced with the word 'this',
purely as a precautionary measure.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The point to be accentuated here
is that, the keyword 'this' prefaces only the instance variables, and not
parameters or local variables, the ones that are created within a function.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System;</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>// a Comment</p>

<p class=VSPROG>/// An XML comment</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT>&gt;csc a.cs /doc:a.xml</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.xml</u></p>

<p class=VSPROG>&lt;?xml version=&quot;1.0&quot;?&gt;</p>

<p class=VSPROG>&lt;doc&gt;</p>

<p class=VSPROG>&lt;assembly&gt;</p>

<p class=VSPROG>&lt;name&gt;a&lt;/name&gt;</p>

<p class=VSPROG>&lt;/assembly&gt;</p>

<p class=VSPROG>&lt;members&gt;</p>

<p class=VSPROG>&lt;member name=&quot;M:zzz.Main&quot;&gt;</p>

<p class=VSPROG>An XML comment</p>

<p class=VSPROG>&lt;/member&gt;</p>

<p class=VSPROG>&lt;/members&gt;</p>

<p class=VSPROG>&lt;/doc&gt;</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Programmers detest documenting
their code. The C# framework has toiled relentlessly, to ease this task. So,
when we run the C# compiler with the switch /doc:a.xml, it generates a pure XML
file named a.xml, which includes the comments that we may have added. Any line
that begins with the // symbol, is called a 'comment', and is ignored by the C#
compiler. However, any line beginning with the /// symbol, is part of the XML
documentation. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Let us write a simple C#
program, which would display an empty window. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>using System.Windows.Forms;</p>

<p class=VSPROG>namespace z10</p>

<p class=VSPROG>{</p>

<p class=VSPROG>class Form1 : System.Windows.Forms.Form</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>Application.Run(new Form1());</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Now compile the above program, and
then, run the executable. Screen 5.5 is what shows up on our screen. It is a
simple blank window. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<table border=0 cellspacing=0 cellpadding=0 style='border-collapse:collapse;
 mso-padding-alt:0in 5.4pt 0in 5.4pt'>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal><img width=200 height=200 id="_x0000_i1030"
  src="chap5img/5.5.jpg"></p>
  </td>
 </tr>
 <tr>
  <td valign=top style='padding:0in 5.4pt 0in 5.4pt'>
  <p class=MsoNormal>Screen 5.5</p>
  </td>
 </tr>
</table>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In the program, class Form1
derives from class System.Windows.Forms.Form, thereby, making Form1 the derived
class and System.Windows.Forms.Form the base class. In place of the full name,
we could have used : Form only, since System.Windows.Forms has been provided
with the 'using' keyword. But, you must be aware of the fact that, we are
afflicted with occasional fits of eccentricity!<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Then, the Run function is called
from the Application object. Since no error is generated, it may be safely
assumed that, the Application object must be present in the class Form, since
it is not created in Form1. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>You may recollect the rule
wherein it is specified that, members of the 'base' class, can be used in the
'derived' class. The parameter passed to the Run function, is a new instance of
the class Form1. As a result, a window is displayed as the output. What the run
function achieves internally, and how it works, is none of our concern! <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int [] a;</p>

<p class=VSPROG>a = new int[5];</p>

<p class=VSPROG>a[1] = 10;</p>

<p class=VSPROG>a[2] = 4;</p>

<p class=VSPROG>a[1]++;</p>

<p class=VSPROG>System.Console.WriteLine(a[1]);</p>

<p class=VSPROG>int i;</p>

<p class=VSPROG>i = 1;</p>

<p class=VSPROG>System.Console.WriteLine(a[i]);</p>

<p class=VSPROG>i = 2;</p>

<p class=VSPROG>System.Console.WriteLine(a[i]);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>11</p>

<p class=VSOUTPUT>11</p>

<p class=VSOUTPUT>4</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Any variable with a pair of
square brackets [] following it, is known as an array. An array is merely a collection
of a large number of variables, which share the same name and the data type. In
order to specify a size for this array, the good old 'new' statement is
employed. 'New' is passed a number, representing the quantity of variables that
need to be created. Thus, the array 'a' has 5 members, all belonging to the
data type, int. These ints are individually named as a[0] to a[4]. The name
a[5] is fallacious here, since the referencing begins from 0, and not from 1.
The only difference between a normal variable and an array variable is the
presence of the square brackets []. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Similar to a normal variable,
the value contained in the array, can be incremented with the help of the short
form ++. Thus, the array variable may be used in the same context as a normal
variable. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>An array can be exploited
optimally, when it is in the form a[i], wherein, a is the name of the array,
and i is a variable. Since the variable a[i] does not exist per se, C# begins
by determining the current value of i. Assuming it to be 0, a[i] evaluates to
a[0]. If i happens to be 1, the variable now evaluates to a[1], and so on.
Thus, the WriteLine function displays the value of a[1] as 11. Now, changing
the value of variable i to 2, will lead to renaming the variable as a[2]. Thus,
despite the two WriteLine functions being passed the variable a[i], the values
displayed also change, since the value of i changes.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Let us now pen down a small
program, which demonstrates how we can execute specific portions of the code,
repeatedly.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int i;</p>

<p class=VSPROG>for ( i = 10; i &lt;= 12 ; i++)</p>

<p class=VSPROG>System.Console.WriteLine(i);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>10</p>

<p class=VSOUTPUT>11</p>

<p class=VSOUTPUT>12</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The 'for' statement contains two
semi-colons enclosed within the open and close brackets. Whatever code is placed
before the first semicolon, is executed only once. Thus, the variable i is
assigned a value of 10. Then, there is a condition that is placed between the
two semicolons. This condition is evaluated before the loop is entered.
Thereafter, it is evaluated every time the loop finishes execution. The 'for'
loop will keep iterating, as long as, this condition evaluates to True. After
each such iteration, the code placed between the second semicolon and the
closing round bracket, is executed.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>If the value of i is less than
or equal to 12, the condition is True, and the line of code following the 'for'
statement is executed. As i currently has a value of 10, the condition
evaluates to True. The WriteLine function is then executed, resulting in the
display of a value. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Once this is done, the statement
between the second semi-colon and the closing bracket, is executed. In our
case, the value of i is increased by 1, making it 11. The condition is executed
once again, and it evaluates to True. Thus, the WriteLine function displays the
value of i as 11. Again, the variable i is incremented by 1. So, its value now
becomes 12, and the condition again results in True. This value of i is again
displayed using the WriteLine function. Once again, the value of i<span
style="mso-spacerun: yes">  </span>is incremented by 1, making it 13. This
time, the condition evaluates to False, because 13 is not less than 12. Thus,
the next line does not get executed, and the 'for' statement terminates.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int [] a;</p>

<p class=VSPROG>a = new int[3];</p>

<p class=VSPROG>int i;</p>

<p class=VSPROG>for ( i = 0; i &lt;= 2 ; i++)</p>

<p class=VSPROG>a[i] = i*10;</p>

<p class=VSPROG>for ( i = 0; i &lt;= 2 ; i++)</p>

<p class=VSPROG>System.Console.WriteLine(a[i]);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>0</p>

<p class=VSOUTPUT>10</p>

<p class=VSOUTPUT>20</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In this program, we have created
an array of ints. In fact, we could have created an array of any other data type
too. The array is initialized to three ints, using the 'for' statement. In the
first iteration, as the value of i is 0, the variable becomes a[0], and the
value that it stores is 0. In the next iteration, i becomes 1. Thus, the
variable a[1] is assigned the value of 10. Finally, in the last iteration, as
the value of i is 2, the variable a[2] is assigned a value of 20.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The second 'for' statement is
used, to display the values contained in the array. Thus, employing the same
approach, the WriteLine function displays the values stored in the 3 elements.
In short, the 'for' statement and an array, are a match made in heaven.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int i;</p>

<p class=VSPROG>short j;</p>

<p class=VSPROG>i = 10;</p>

<p class=VSPROG>j = i;</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(8,5): error CS0029: Cannot implicitly convert type 'int'
to 'short'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>C# is very fussy about the data
types present on the left and the right hand side of an 'equal to' sign. They
are required to be the same, but with a single exception. As i and j have
different data types, they cannot be equated. Thus, an error is generated, as
shown above. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>A 'short' is similar to an int,
except for the fact that, it stores a smaller range of numbers than an int. If
we want to equate the two variables, the only way out is, to convert the int
data type into a short. To effect this, we place the name of the data type in
brackets before the variable, <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><span style="mso-spacerun: yes"> </span>j = (short)i;</p>

<p class=VSBASE><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We replace the last line of the
earlier program, with the line stated above. So, during the execution of the
above statement, the int data type becomes a short. Now, since both sides of
the 'equal to' sign have the same data type, C# does not complain, and no error
is generated.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>a.i = 10;</p>

<p class=VSPROG>System.Console.WriteLine(a.i);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public int i;</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>10</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The above program seems
repetitive, but it illustrates a fundamental point. A variable can be
initialized to a value, such as a.i = 10. The value of the variable can be
displayed using the WriteLine function. The salient point is that, we can
accomplish only two things with a variable, set its value and get its value! <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>While assigning or retrieving
the value, no code can possibly be executed. Thus, no error checks can be
performed either. Now, let us endeavour to surmount this obstacle.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>a.i = 10;</p>

<p class=VSPROG>System.Console.WriteLine(a.i);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int ii;</p>

<p class=VSPROG>public int i</p>

<p class=VSPROG>{</p>

<p class=VSPROG>set</p>

<p class=VSPROG>{</p>

<p class=VSPROG>ii = value;</p>

<p class=VSPROG>System.Console.WriteLine(&quot;set &quot; + value);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>get</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;get &quot; + ii);</p>

<p class=VSPROG>return ii;</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>set 10</p>

<p class=VSOUTPUT>get 10</p>

<p class=VSOUTPUT>10</p>

<p class=VSBASE><span style='color:windowtext'>In the above example, the code
in the class zzz, remains totally unchanged. However, major changes have been
effected in the class yyy. In yyy, i is declared as a variable of data type
int, but with an open and close braces following it. Had it been a normal
variable, it would have ended with a semi-colon. Within the brackets, two new
words, 'get' and 'set' are inserted, with each of them followed by a pair of
braces. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Each time the value of the variable
is altered, the set block gets called; to be precise, the 'set accessor' is
called. This accessor is provided with a free variable called 'value', which
gets the value of 10 as a.i is initialized to 10. The reserved word 'value',
contains the number that is then assigned to an instance variable ii.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>While retrieving the value of
the variable i, the get accessor is called. The current value contained in the
variable ii, is returned. Code can now be called in these accessors. Since it
is very different from the normal variables, it has been termed as a property.
The class zzz is completely oblivious of these aspects, since it is unable to
distinguish between a property and a variable.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>a[&quot;vijay&quot;] = 10;</p>

<p class=VSPROG>System.Console.WriteLine(a[&quot;vijay&quot;]);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>int ii;</p>

<p class=VSPROG>public int this[string i]</p>

<p class=VSPROG>{</p>

<p class=VSPROG>set</p>

<p class=VSPROG>{</p>

<p class=VSPROG>ii = value;</p>

<p class=VSPROG>System.Console.WriteLine(&quot;set &quot; + i + &quot; &quot; +
value);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>get</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;get &quot; + ii);</p>

<p class=VSPROG>return ii;</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>set vijay 10</p>

<p class=VSOUTPUT>get 10</p>

<p class=VSOUTPUT>10</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Arrays are of great utility,
since they are a collection of similar items. In this program, we would like to
work with an array, without having to create one. 'a' is an instance of the
class yyy. It is not an array, since square brackets are missing. Now, despite
having clearly stated that, a is an instance of class yyy, and not an array, we
use the notation of <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>a[&quot;vijay&quot;]. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Class yyy has a property called
'this' with square brackets; thus, making this a unique property or an indexer.
An indexer provides the look and feel of an array, despite there being none at
all. The line a[&quot;vijay&quot;] = 10, calls the set accessor with 'vijay',
as a parameter to the 'this' indexer. The string 'vijay' is stored in i, and
the number 10 is stored in the reserved word 'value'. The values are printed
out, to ascertain the above explanation.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The 'get accessor' is called,
when the value of the variable has to be returned. Therefore, the output
displays a value of 10. i is used to figure out the array indexer, in case there
are multiple indexers. The array notation may be used to hold more than one
parameter. Conclusively, an indexer renders the usage of classes, much more
intuitive.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>yyy a;</p>

<p class=VSPROG>a = new yyy();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>interface yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(6,5): error CS0144: Cannot create an instance of the
abstract class or interface 'yyy'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The program introduces a new
term called 'interface', which we shall explain shortly. An interface cannot
have the keyword 'new' prefixed to it, in other words, it cannot be
instantiated.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>xxx a;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>interface yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>void<span style="mso-spacerun: yes">  </span>abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Error</u></p>

<p class=VSOUTPUT>a.cs(13,7): error CS0535: 'xxx' does not implement interface
member 'yyy.abc()'</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>We have an interface yyy, which
has a function called abc. Deriving the class xxx from the interface yyy,
generates the above error. To eliminate the error, we attempt the following:<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>xxx a;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>yyy b;</p>

<p class=VSPROG>b<span style="mso-spacerun: yes">  </span>= new xxx();</p>

<p class=VSPROG>b.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>interface yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>void abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx : yyy</p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;abc&quot;);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>abc</p>

<p class=VSOUTPUT>abc</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The above error is banished by
adding the function abc in the class xxx. Thus, whenever a class derives from
an interface, it must contain a body or code, for all the function names that
are present in the interface. If there are 100 function names or prototypes in
the interface, each one of the 100 functions, needs to be implemented in class
xxx.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>The concept of an 'interface',
is very different from that of a class. A class contains a lot of free code.
However, there is no code provided along with an interface. Instead, a function
body is to be provided for the function prototypes, which are present in the
interface for a class that derives from it. A class can be derived from
multiple interfaces, but not from multiple classes. Also, an object b, of data
type interface yyy, can be initialized to an instance of class xxx; but the
object can then access only the members of the interface yyy, and not those of
the class xxx.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>xxx a;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx </p>

<p class=VSPROG>{</p>

<p class=VSPROG>public delegate void pqr(int i);</p>

<p class=VSPROG>public void pqr1(int j)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;pqr1 &quot; + j);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>pqr a = new pqr(pqr1);</p>

<p class=VSPROG>a(100);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>pqr1 100</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In class xxx, the function
prototype of pqr specifies that, it accepts an int as a parameter, and returns
void. Also, a new keyword called delegate, has been introduced. This new introduction
makes pqr a 'delegate'. The function abc, which gets called from Main, creates
an instance of the delegate pqr, by using the same keyword 'new'. The only
difference here is that, pqr1, which is the name of a function, is provided as
a parameter to it, and round brackets are used in place of the square brackets.
<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>Calling the delegate function
would result in an indirect call to the function pqr1. Thus, we have been able
to execute a function indirectly. The next example unfurls the true powers of
delegates and events.<o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSPROG><u>a.cs</u></p>

<p class=VSPROG>public delegate void pqr(int p);</p>

<p class=VSPROG>class zzz</p>

<p class=VSPROG>{</p>

<p class=VSPROG>static void Main()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>xxx a;</p>

<p class=VSPROG>a = new xxx();</p>

<p class=VSPROG>a.c += new pqr(a.pqr1);</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>a.c += new pqr(a.pqr2);</p>

<p class=VSPROG>a.abc();</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSPROG>class xxx </p>

<p class=VSPROG>{</p>

<p class=VSPROG>public void pqr1(int j)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;pqr1 &quot; + j);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>public void pqr2(int j)</p>

<p class=VSPROG>{</p>

<p class=VSPROG>System.Console.WriteLine(&quot;pqr2 &quot; + j);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>public event pqr c;</p>

<p class=VSPROG>public void abc()</p>

<p class=VSPROG>{</p>

<p class=VSPROG>c(10);</p>

<p class=VSPROG>}</p>

<p class=VSPROG>}</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSOUTPUT><u>Output</u></p>

<p class=VSOUTPUT>pqr1 10</p>

<p class=VSOUTPUT>pqr1 10</p>

<p class=VSOUTPUT>pqr2 10</p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'>In the above program, the delegate
pqr has been made a global entity. A global entity is one, which is created
outside the class. In class xxx, c is a variable of data type pqr, and contains
the 'event' keyword. As a consequence, c is referred to, as an event object.<span
style="mso-spacerun: yes">  </span>In Main, we first create 'a' as an instance
of class xxx. Then, we use a special notation of += to initialize it to
delegate pqr. As we have seen in the earlier example, a function must be
specified with a delegate. So, the address of a function pqr1 in class xxx, has
been provided. 'c' is then initialized to delegate pqr. It throws no errors,
since 'c' is of data type pqr. When the abc function is called, it calls the
event c. Observe the use of open and close round brackets, while an event is
being called. The event, in turn, calls the function pqr1, with a parameter of
10. <o:p></o:p></span></p>

<p class=VSBASE><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=VSBASE>So, what is the remarkable achievement here? In the next line,
the same += is repeated, but with a new function named pqr2, as a parameter to
a delegate. Therefore, when we execute the two functions pqr1 and pqr2, both
the functions get called, since we have added pqr2 to the current event. Thus,
the event object keeps track of all the functions that need to be called,
whenever the event occurs. As a consequence, it relieves us of carrying out the
above housekeeping tasks. </p>

</div>

</body>


<!-- Mirrored from www.vijaymukhi.com/documents/books/vsnet/chap5.htm by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 11 Oct 2024 13:56:00 GMT -->
</html>
